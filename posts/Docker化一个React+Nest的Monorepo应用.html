<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><link rel="apple-touch-icon" sizes="180x180" href="/favicon/apple-touch-icon.png"/><link rel="icon" type="image/png" sizes="32x32" href="/favicon/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="16x16" href="/favicon/favicon-16x16.png"/><link rel="manifest" href="/favicon/site.webmanifest"/><link rel="mask-icon" href="/favicon/safari-pinned-tab.svg" color="#000000"/><link rel="shortcut icon" href="/favicon/favicon.ico"/><meta name="msapplication-TileColor" content="#000000"/><meta name="msapplication-config" content="/favicon/browserconfig.xml"/><meta name="theme-color" content="#000"/><link rel="alternate" type="application/rss+xml" href="/feed.xml"/><meta property="og:image" content="https://og-image.vercel.app/Next.js%20Blog%20Starter%20Example.png?theme=light&amp;md=1&amp;fontSize=100px&amp;images=https%3A%2F%2Fassets.vercel.com%2Fimage%2Fupload%2Ffront%2Fassets%2Fdesign%2Fnextjs-black-logo.svg"/><title>Docker化一个React+Nest的Monorepo应用 | Ai.Haibara codes</title><meta name="next-head-count" content="14"/><link rel="preload" href="/_next/static/css/4d9faa1c82c5289e.css" as="style"/><link rel="stylesheet" href="/_next/static/css/4d9faa1c82c5289e.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-8fa1640cc84ba8fe.js" defer=""></script><script src="/_next/static/chunks/framework-3b5a00d5d7e8d93b.js" defer=""></script><script src="/_next/static/chunks/main-59a90320855f5cf5.js" defer=""></script><script src="/_next/static/chunks/pages/_app-a2603426f792f9a7.js" defer=""></script><script src="/_next/static/chunks/799-575b46febca3af7d.js" defer=""></script><script src="/_next/static/chunks/399-cac0cd8ed02bf02a.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bslug%5D-ca05212d4081d62f.js" defer=""></script><script src="/_next/static/tq3FXJam7YL1cG21b1U6L/_buildManifest.js" defer=""></script><script src="/_next/static/tq3FXJam7YL1cG21b1U6L/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="min-h-screen"><header class="text-white bg-black drop-shadow-2xl"><div class="mx-auto my-0 max-w-[960px] py-6 px-4 flex items-center"><div class="flex items-center"><img alt="Ai.Haibara" src="/assets/blog/authors/haibara_2.jpg" width="100" height="100" decoding="async" data-nimg="1" class=" rounded-full" loading="lazy" style="color:transparent"/></div><div class="ml-6"><a class=" font-bold text-3xl" href="/">Ai.Haibara codes</a><div class="mt-2"><a class="p-1 rounded-sm text-xl mr-2 hover:border-b-2 border-indigo" href="/">Home</a><a class="p-1 rounded-sm text-xl mr-2 hover:border-b-2 border-indigo" href="/projects">Projects</a><a class="p-1 rounded-sm text-xl mr-2 hover:border-b-2 border-indigo" href="/talks">Talks</a><a class="p-1 rounded-sm text-xl mr-2 hover:border-b-2 border-indigo" href="/blogs">Blogs</a></div></div></div></header><main class="p-6 flex justify-center"><article><div class="flex justify-center font-[Arial]"><h1 class="text-5xl font-bold bg-indigo px-5 py-2 rounded-sm text-shadow-lg leading-[1.1]">Docker化一个React+Nest的Monorepo应用</h1></div><time dateTime="2023-04-25" class="text-center block my-4 text-sm opacity-60">April	25, 2023</time><section><div class="markdown-body-orange max-w-3xl"><h2 id="目标"><a aria-hidden="true" tabindex="-1" href="#目标"><span class="icon icon-link"></span></a>目标</h2>
<p>使用 <code>Docker</code> 和 <code>Docker Compose</code> 将一个使用 <a href="https://react.dev/">React</a> + <a href="https://nestjs.com/">NestJS</a> + <a href="https://www.postgresql.org/">PostgreSQL</a> + <a href="https://www.prisma.io/">prisma</a> 构建的 Web 应用程序 <strong>Dockerize</strong>。</p>
<h2 id="前置准备"><a aria-hidden="true" tabindex="-1" href="#前置准备"><span class="icon icon-link"></span></a>前置准备</h2>
<ul>
<li>安装 <a href="https://nodejs.org/en">Node.js</a>, 且保证 Node.js 版本为 v14.17.0 或者更高版本.</li>
<li>安装 <a href="https://docs.nestjs.com/cli/overview">Nest.js CLI</a></li>
<li>安装 <a href="https://pnpm.io/">Pnpm</a></li>
<li>安装 <a href="https://docs.docker.com/engine/install/">Docker Engine</a></li>
<li>安装 <a href="https://docs.docker.com/compose/install/">Docker Compose</a></li>
<li>安装 <a href="https://opensource.com/article/18/8/what-how-makefile">Make</a></li>
</ul>
<h2 id="项目结构"><a aria-hidden="true" tabindex="-1" href="#项目结构"><span class="icon icon-link"></span></a>项目结构</h2>
<h3 id="使用-pnpm-的-workspace-功能构建一个-monorepo"><a aria-hidden="true" tabindex="-1" href="#使用-pnpm-的-workspace-功能构建一个-monorepo"><span class="icon icon-link"></span></a>使用 Pnpm 的 <a href="https://pnpm.io/workspaces">Workspace</a> 功能构建一个 Monorepo</h3>
<p>对于一个 <code>Monorepo</code>, 我们需要创建在项目根路径创建一个 <code>packages</code> 文件夹. <code>packages</code> 里面包含了由 <a href="https://www.npmjs.com/package/create-vite">create-vite</a> 创建的 <code>React</code> 项目以及由 <code>Nest.js CLI</code> 创建的后端服务. 当然, 在项目根路径也需要创建一些全局的配置文件.</p>
<p>具体操作步骤如下:</p>
<ul>
<li>
<p>在根目录初始化一个新的 git 仓库并创建以下文件:</p>
<pre><code class="language-sh">.dockerignore
.gitignore
.env
.docker-compose.yaml
Makefile
</code></pre>
</li>
<li>
<p>创建 packages 文件用于存放前后端项目:</p>
<pre><code class="language-sh">mkdir packages &#x26;&#x26; cd packages
</code></pre>
</li>
<li>
<p>创建前端项目, 并添加 Dockerfile.local 以及 Dockerfile.production 文件</p>
<pre><code class="language-sh">pnpm create vite
</code></pre>
</li>
<li>
<p>创建后端项目, 并且在执行完后手动删除 node_modules, 同时也添加 Dockerfile.local 以及 Dockerfile.production 文件</p>
<pre><code class="language-sh">nest new backend
</code></pre>
</li>
<li>
<p>重新配置 tsconfig.json:</p>
<p>首先在项目根目录执行: <code>tsc --init</code>, 初始化一份 <code>tsconfig.json</code>, 并且将文件内容修改至以下内容:</p>
<pre><code class="language-json">  {
   "compilerOptions": {
     "module": "commonjs",
     "declaration": true,
     "removeComments": true,
     "emitDecoratorMetadata": true,
     "experimentalDecorators": true,
     "allowSyntheticDefaultImports": true,
     "target": "es2017",
     "sourceMap": true,
     "outDir": "./dist",
     "baseUrl": "./",
     "incremental": true,
     "skipLibCheck": true,
     "strictNullChecks": false,
     "noImplicitAny": false,
     "strictBindCallApply": false,
     "forceConsistentCasingInFileNames": true,
     "noFallthroughCasesInSwitch": false,
     "strict": true,
     "jsx": "react-jsx"
   },
   "include": ["packages/*/src"]
  }
</code></pre>
<p>最后将前后端项目中由工具创建的 <code>tsconfig.json</code> 文件内容修改至以下内容:</p>
<pre><code class="language-json">  {
   "extends": "../../tsconfig.json",
   "include": ["./src"]
  }
</code></pre>
</li>
<li>
<p>创建 pnpm-workspace.yml, 填充以下内容:</p>
<pre><code class="language-yml">  packages:
 - 'packages/**'
</code></pre>
</li>
<li>
<p>在根目录创建 package.json 文件, 并且将前后端相同的依赖项提取至其中. 执行 <code>pnpm install -r</code> , 完成依赖的安装.</p>
</li>
</ul>
<p>最后, 得到的项目结构应如下图所示</p>
<p><img src="/assets/docker-react-nest/example1.png" alt="alt"></p>
<h2 id="dockerize"><a aria-hidden="true" tabindex="-1" href="#dockerize"><span class="icon icon-link"></span></a>Dockerize</h2>
<h3 id="backend-dockerfile"><a aria-hidden="true" tabindex="-1" href="#backend-dockerfile"><span class="icon icon-link"></span></a>Backend Dockerfile</h3>
<p>回到本文主题, 现在, 我们的 Backend 文件夹中包含了两个 Dockerfile 文件. 其中一个用于在本地运行项目, 它用于docker-compose.yaml 文件, 而另一个用于生产环境.</p>
<p>现在将以下内容填充至 Dockerfile.local:</p>
<pre><code class="language-dockerfile">#获取node镜像源
FROM node:16.16.0-alpine

#设置工作目录
WORKDIR /projects

# 将 pnpm-lock.yaml 拷贝至工作目录, 为后续的 pnpm fetch 做准备
COPY ./pnpm-lock.yaml ./

# 安装 pnpm, 并且固定版本, 也可以考虑在获取node镜像源时直接获取带有pnpm的镜像, 这样就能省略这一步了
RUN npm install -g pnpm@8.3.1

# pnpm fetch 通过提供仅使用锁定文件中的信息将包加载到虚拟存储中的能力，完美地解决了上述问题. 具体见: https://pnpm.io/cli/fetch
RUN pnpm fetch

COPY . .

# 安装依赖, 关于 --offline 见: https://pnpm.io/cli/fetch
RUN pnpm install -r --offline

# https://zhuanlan.zhihu.com/p/89335014
VOLUME ["/projects/node_modules/", "/projects/packages/backend/node_modules/", "/projects/.pnpm-store/"]

# https://yeasy.gitbook.io/docker_practice/image/dockerfile/expose
EXPOSE $BACKEND_PORT

# 启动后端服务
CMD rm -rf dist &#x26;&#x26; cd packages/backend &#x26;&#x26; pnpm start:debug
</code></pre>
<h3 id="frontend-dockerfile"><a aria-hidden="true" tabindex="-1" href="#frontend-dockerfile"><span class="icon icon-link"></span></a>Frontend Dockerfile</h3>
<p>前端文件夹下的 Dockerfile:</p>
<pre><code class="language-dockerfile">#获取node镜像源
FROM node:16.16.0-alpine

#设置工作目录
WORKDIR /app

# 将 pnpm-lock.yaml 拷贝至工作目录, 为后续的 pnpm fetch 做准备
COPY ./pnpm-lock.yaml ./

# 安装 pnpm, 并且固定版本, 也可以考虑在获取node镜像源时直接获取带有pnpm的镜像, 这样就能省略这一步了
RUN npm install -g pnpm@8.3.1

# pnpm fetch 通过提供仅使用锁定文件中的信息将包加载到虚拟存储中的能力，完美地解决了上述问题. 具体见: https://pnpm.io/cli/fetch
RUN pnpm fetch

COPY . .

# 安装依赖, 关于 --offline 见: https://pnpm.io/cli/fetch
RUN pnpm install -r --offline

# https://zhuanlan.zhihu.com/p/89335014
VOLUME ["/app/node_modules/", "/app/packages/frontend/node_modules/", "/app/.pnpm-store/"]

# 启动前端服务
CMD cd packages/frontend &#x26;&#x26; pnpm start

</code></pre>
<h3 id="创建-docker-compose-文件并运行项目"><a aria-hidden="true" tabindex="-1" href="#创建-docker-compose-文件并运行项目"><span class="icon icon-link"></span></a>创建 Docker Compose 文件并运行项目</h3>
<ol>
<li>
<p>配置环境变量: 将以下内容填充至 <code>&#x3C;rootDir>/.env</code></p>
<pre><code class="language-sh">   NODE_ENV=development
   FRONTEND_PORT=7879
   BACKEND_PORT=7878
   JWT_SECRET=jwt_secret_key_here
   JWT_EXPIRES_IN=30d
   DB_HOST=bp-pg-db
   DB_NAME=bp-pg-db
   DB_USER=postgres
   DB_PASSWORD=root
   DB_PORT=5432
   PGADMIN_DEFAULT_EMAIL=admin@backend.com
   PGADMIN_DEFAULT_PASSWORD=pass@123
   PGADMIN_PORT=5055
</code></pre>
</li>
<li>
<p>将以下内容填充至 <code>&#x3C;rootDIr>/docker-compose.yml</code></p>
<pre><code class="language-yml">    version: '3.9'
    services:
      frontend:
        container_name: frontend
        build:
          context: ./
          dockerfile: ./packages/frontend/Dockerfile.local
        restart: always
        env_file: .env
        ports:
          - '${FRONTEND_PORT}:${FRONTEND_PORT}'
        volumes:
          - .:/app
        networks:
          bp-network:
            ipv4_address: 172.25.0.3
      backend:
        container_name: backend
        build:
          context: ./
          dockerfile: ./packages/backend/Dockerfile.local
        restart: always
        env_file: .env
        volumes:
          - .:/app
        networks:
          bp-network:
            ipv4_address: 172.25.0.2
        ports:
          - '${BACKEND_PORT}:${BACKEND_PORT}'
        depends_on:
          - bp-pg-db
        links:
          - bp-pg-db
      bp-pg-db:
        image: postgres:12-alpine
        restart: always
        container_name: bp-pg-db
        env_file:
          - .env
        environment:
          POSTGRES_PASSWORD: ${DB_PASSWORD}
          PGDATA: /var/lib/postgresql/data
          POSTGRES_USER: ${DB_USER}
          POSTGRES_DB: ${DB_NAME}
        ports:
          - '${DB_PORT}:${DB_PORT}'
        volumes:
          - pgdata:/var/lib/postgresql/data
        networks:
          bp-network:
            ipv4_address: 172.25.0.5
      pgadmin-portal:
        image: dpage/pgadmin4
        restart: always
        container_name: pgadmin-portal
        env_file:
          - .env
        environment:
          PGADMIN_DEFAULT_PASSWORD: '${PGADMIN_DEFAULT_PASSWORD}'
          PGADMIN_DEFAULT_EMAIL: '${PGADMIN_DEFAULT_EMAIL}'
        volumes:
          - pgadmin:/root/.pgadmin
        ports:
          - '${PGADMIN_PORT}:80'
        depends_on:
          - bp-pg-db
        networks:
          bp-network:
            ipv4_address: 172.25.0.6
    volumes:
      pgdata:
      pgadmin:
    networks:
      bp-network:
        driver: bridge
        ipam:
          config:
            - subnet: 172.25.0.0/16
    
</code></pre>
<ol>
<li><code>Services</code>: 每个服务代表一个将要创建的 Docker 容器</li>
</ol>
<ul>
<li>frontend: 基于前端项目的 Dockerfile.local 构建镜像以及容器. 此容器将会控制前端服务的启停.</li>
<li>backend: 基于后端项目的 Dockerfile.local 构建镜像以及容器. 此容器将会控制后端服务的启停.</li>
<li>bp-pg-db: 基于镜像 postgres:12-alpine 构建的 postgres 数据库容器.</li>
<li>pgadmin-portal: 基于镜像 dpage/pgadmin4 构建的 postgres 可视化界面操作服务.</li>
</ul>
</li>
<li>
<p>添加 Makefile 用来启动:</p>
<pre><code class="language-Makefile">local: 
   docker-compose stop &#x26;&#x26; docker-compose up --build -d --remove-orphans
</code></pre>
</li>
</ol>
<p>使用 <code>make local</code> 命令后, 将构建镜像并启动容器服务, 此时便能通过配置中暴露出的端口号来正常的访问到前端、后端以及数据库服务. 同时, 得益于 <code>VOlUME</code>, 我们在本地修改代码后能及时的映射到容器的挂卷中, 通过项目的热更新来开发项目.</p>
<h2 id="生产环境部署"><a aria-hidden="true" tabindex="-1" href="#生产环境部署"><span class="icon icon-link"></span></a>生产环境部署</h2>
<p>todo...</p></div></section></article></main><footer class="bg-neutral-50 border-t border-neutral-200 text-center text-xs opacity-50 py-4">© 2022,<!-- --> <a rel="noopener noreferrer" class="hover:underline hover:bg-indigo" href="https://github.com/LZS911" target="_blank">LZS_911</a>, build with<!-- --> <a rel="noopener noreferrer" class="underline hover:bg-indigo" href="https://nextjs.org/" target="_blank">Next.js</a> <!-- -->and<!-- --> <a rel="noopener noreferrer" class="underline hover:bg-indigo" href="https://pages.github.com/?(null)" target="_blank">GitHub Pages</a></footer></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"Docker化一个React+Nest的Monorepo应用","date":"2023-04-25","slug":"Docker化一个React+Nest的Monorepo应用","author":"Ai.Haibara","content":"\u003ch2 id=\"目标\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#目标\"\u003e\u003cspan class=\"icon icon-link\"\u003e\u003c/span\u003e\u003c/a\u003e目标\u003c/h2\u003e\n\u003cp\u003e使用 \u003ccode\u003eDocker\u003c/code\u003e 和 \u003ccode\u003eDocker Compose\u003c/code\u003e 将一个使用 \u003ca href=\"https://react.dev/\"\u003eReact\u003c/a\u003e + \u003ca href=\"https://nestjs.com/\"\u003eNestJS\u003c/a\u003e + \u003ca href=\"https://www.postgresql.org/\"\u003ePostgreSQL\u003c/a\u003e + \u003ca href=\"https://www.prisma.io/\"\u003eprisma\u003c/a\u003e 构建的 Web 应用程序 \u003cstrong\u003eDockerize\u003c/strong\u003e。\u003c/p\u003e\n\u003ch2 id=\"前置准备\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#前置准备\"\u003e\u003cspan class=\"icon icon-link\"\u003e\u003c/span\u003e\u003c/a\u003e前置准备\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e安装 \u003ca href=\"https://nodejs.org/en\"\u003eNode.js\u003c/a\u003e, 且保证 Node.js 版本为 v14.17.0 或者更高版本.\u003c/li\u003e\n\u003cli\u003e安装 \u003ca href=\"https://docs.nestjs.com/cli/overview\"\u003eNest.js CLI\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e安装 \u003ca href=\"https://pnpm.io/\"\u003ePnpm\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e安装 \u003ca href=\"https://docs.docker.com/engine/install/\"\u003eDocker Engine\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e安装 \u003ca href=\"https://docs.docker.com/compose/install/\"\u003eDocker Compose\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e安装 \u003ca href=\"https://opensource.com/article/18/8/what-how-makefile\"\u003eMake\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"项目结构\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#项目结构\"\u003e\u003cspan class=\"icon icon-link\"\u003e\u003c/span\u003e\u003c/a\u003e项目结构\u003c/h2\u003e\n\u003ch3 id=\"使用-pnpm-的-workspace-功能构建一个-monorepo\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#使用-pnpm-的-workspace-功能构建一个-monorepo\"\u003e\u003cspan class=\"icon icon-link\"\u003e\u003c/span\u003e\u003c/a\u003e使用 Pnpm 的 \u003ca href=\"https://pnpm.io/workspaces\"\u003eWorkspace\u003c/a\u003e 功能构建一个 Monorepo\u003c/h3\u003e\n\u003cp\u003e对于一个 \u003ccode\u003eMonorepo\u003c/code\u003e, 我们需要创建在项目根路径创建一个 \u003ccode\u003epackages\u003c/code\u003e 文件夹. \u003ccode\u003epackages\u003c/code\u003e 里面包含了由 \u003ca href=\"https://www.npmjs.com/package/create-vite\"\u003ecreate-vite\u003c/a\u003e 创建的 \u003ccode\u003eReact\u003c/code\u003e 项目以及由 \u003ccode\u003eNest.js CLI\u003c/code\u003e 创建的后端服务. 当然, 在项目根路径也需要创建一些全局的配置文件.\u003c/p\u003e\n\u003cp\u003e具体操作步骤如下:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e在根目录初始化一个新的 git 仓库并创建以下文件:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-sh\"\u003e.dockerignore\n.gitignore\n.env\n.docker-compose.yaml\nMakefile\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e创建 packages 文件用于存放前后端项目:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-sh\"\u003emkdir packages \u0026#x26;\u0026#x26; cd packages\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e创建前端项目, 并添加 Dockerfile.local 以及 Dockerfile.production 文件\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-sh\"\u003epnpm create vite\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e创建后端项目, 并且在执行完后手动删除 node_modules, 同时也添加 Dockerfile.local 以及 Dockerfile.production 文件\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-sh\"\u003enest new backend\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e重新配置 tsconfig.json:\u003c/p\u003e\n\u003cp\u003e首先在项目根目录执行: \u003ccode\u003etsc --init\u003c/code\u003e, 初始化一份 \u003ccode\u003etsconfig.json\u003c/code\u003e, 并且将文件内容修改至以下内容:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-json\"\u003e  {\n   \"compilerOptions\": {\n     \"module\": \"commonjs\",\n     \"declaration\": true,\n     \"removeComments\": true,\n     \"emitDecoratorMetadata\": true,\n     \"experimentalDecorators\": true,\n     \"allowSyntheticDefaultImports\": true,\n     \"target\": \"es2017\",\n     \"sourceMap\": true,\n     \"outDir\": \"./dist\",\n     \"baseUrl\": \"./\",\n     \"incremental\": true,\n     \"skipLibCheck\": true,\n     \"strictNullChecks\": false,\n     \"noImplicitAny\": false,\n     \"strictBindCallApply\": false,\n     \"forceConsistentCasingInFileNames\": true,\n     \"noFallthroughCasesInSwitch\": false,\n     \"strict\": true,\n     \"jsx\": \"react-jsx\"\n   },\n   \"include\": [\"packages/*/src\"]\n  }\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e最后将前后端项目中由工具创建的 \u003ccode\u003etsconfig.json\u003c/code\u003e 文件内容修改至以下内容:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-json\"\u003e  {\n   \"extends\": \"../../tsconfig.json\",\n   \"include\": [\"./src\"]\n  }\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e创建 pnpm-workspace.yml, 填充以下内容:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-yml\"\u003e  packages:\n - 'packages/**'\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e在根目录创建 package.json 文件, 并且将前后端相同的依赖项提取至其中. 执行 \u003ccode\u003epnpm install -r\u003c/code\u003e , 完成依赖的安装.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e最后, 得到的项目结构应如下图所示\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/docker-react-nest/example1.png\" alt=\"alt\"\u003e\u003c/p\u003e\n\u003ch2 id=\"dockerize\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#dockerize\"\u003e\u003cspan class=\"icon icon-link\"\u003e\u003c/span\u003e\u003c/a\u003eDockerize\u003c/h2\u003e\n\u003ch3 id=\"backend-dockerfile\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#backend-dockerfile\"\u003e\u003cspan class=\"icon icon-link\"\u003e\u003c/span\u003e\u003c/a\u003eBackend Dockerfile\u003c/h3\u003e\n\u003cp\u003e回到本文主题, 现在, 我们的 Backend 文件夹中包含了两个 Dockerfile 文件. 其中一个用于在本地运行项目, 它用于docker-compose.yaml 文件, 而另一个用于生产环境.\u003c/p\u003e\n\u003cp\u003e现在将以下内容填充至 Dockerfile.local:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-dockerfile\"\u003e#获取node镜像源\nFROM node:16.16.0-alpine\n\n#设置工作目录\nWORKDIR /projects\n\n# 将 pnpm-lock.yaml 拷贝至工作目录, 为后续的 pnpm fetch 做准备\nCOPY ./pnpm-lock.yaml ./\n\n# 安装 pnpm, 并且固定版本, 也可以考虑在获取node镜像源时直接获取带有pnpm的镜像, 这样就能省略这一步了\nRUN npm install -g pnpm@8.3.1\n\n# pnpm fetch 通过提供仅使用锁定文件中的信息将包加载到虚拟存储中的能力，完美地解决了上述问题. 具体见: https://pnpm.io/cli/fetch\nRUN pnpm fetch\n\nCOPY . .\n\n# 安装依赖, 关于 --offline 见: https://pnpm.io/cli/fetch\nRUN pnpm install -r --offline\n\n# https://zhuanlan.zhihu.com/p/89335014\nVOLUME [\"/projects/node_modules/\", \"/projects/packages/backend/node_modules/\", \"/projects/.pnpm-store/\"]\n\n# https://yeasy.gitbook.io/docker_practice/image/dockerfile/expose\nEXPOSE $BACKEND_PORT\n\n# 启动后端服务\nCMD rm -rf dist \u0026#x26;\u0026#x26; cd packages/backend \u0026#x26;\u0026#x26; pnpm start:debug\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"frontend-dockerfile\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#frontend-dockerfile\"\u003e\u003cspan class=\"icon icon-link\"\u003e\u003c/span\u003e\u003c/a\u003eFrontend Dockerfile\u003c/h3\u003e\n\u003cp\u003e前端文件夹下的 Dockerfile:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-dockerfile\"\u003e#获取node镜像源\nFROM node:16.16.0-alpine\n\n#设置工作目录\nWORKDIR /app\n\n# 将 pnpm-lock.yaml 拷贝至工作目录, 为后续的 pnpm fetch 做准备\nCOPY ./pnpm-lock.yaml ./\n\n# 安装 pnpm, 并且固定版本, 也可以考虑在获取node镜像源时直接获取带有pnpm的镜像, 这样就能省略这一步了\nRUN npm install -g pnpm@8.3.1\n\n# pnpm fetch 通过提供仅使用锁定文件中的信息将包加载到虚拟存储中的能力，完美地解决了上述问题. 具体见: https://pnpm.io/cli/fetch\nRUN pnpm fetch\n\nCOPY . .\n\n# 安装依赖, 关于 --offline 见: https://pnpm.io/cli/fetch\nRUN pnpm install -r --offline\n\n# https://zhuanlan.zhihu.com/p/89335014\nVOLUME [\"/app/node_modules/\", \"/app/packages/frontend/node_modules/\", \"/app/.pnpm-store/\"]\n\n# 启动前端服务\nCMD cd packages/frontend \u0026#x26;\u0026#x26; pnpm start\n\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"创建-docker-compose-文件并运行项目\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#创建-docker-compose-文件并运行项目\"\u003e\u003cspan class=\"icon icon-link\"\u003e\u003c/span\u003e\u003c/a\u003e创建 Docker Compose 文件并运行项目\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e配置环境变量: 将以下内容填充至 \u003ccode\u003e\u0026#x3C;rootDir\u003e/.env\u003c/code\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-sh\"\u003e   NODE_ENV=development\n   FRONTEND_PORT=7879\n   BACKEND_PORT=7878\n   JWT_SECRET=jwt_secret_key_here\n   JWT_EXPIRES_IN=30d\n   DB_HOST=bp-pg-db\n   DB_NAME=bp-pg-db\n   DB_USER=postgres\n   DB_PASSWORD=root\n   DB_PORT=5432\n   PGADMIN_DEFAULT_EMAIL=admin@backend.com\n   PGADMIN_DEFAULT_PASSWORD=pass@123\n   PGADMIN_PORT=5055\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e将以下内容填充至 \u003ccode\u003e\u0026#x3C;rootDIr\u003e/docker-compose.yml\u003c/code\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-yml\"\u003e    version: '3.9'\n    services:\n      frontend:\n        container_name: frontend\n        build:\n          context: ./\n          dockerfile: ./packages/frontend/Dockerfile.local\n        restart: always\n        env_file: .env\n        ports:\n          - '${FRONTEND_PORT}:${FRONTEND_PORT}'\n        volumes:\n          - .:/app\n        networks:\n          bp-network:\n            ipv4_address: 172.25.0.3\n      backend:\n        container_name: backend\n        build:\n          context: ./\n          dockerfile: ./packages/backend/Dockerfile.local\n        restart: always\n        env_file: .env\n        volumes:\n          - .:/app\n        networks:\n          bp-network:\n            ipv4_address: 172.25.0.2\n        ports:\n          - '${BACKEND_PORT}:${BACKEND_PORT}'\n        depends_on:\n          - bp-pg-db\n        links:\n          - bp-pg-db\n      bp-pg-db:\n        image: postgres:12-alpine\n        restart: always\n        container_name: bp-pg-db\n        env_file:\n          - .env\n        environment:\n          POSTGRES_PASSWORD: ${DB_PASSWORD}\n          PGDATA: /var/lib/postgresql/data\n          POSTGRES_USER: ${DB_USER}\n          POSTGRES_DB: ${DB_NAME}\n        ports:\n          - '${DB_PORT}:${DB_PORT}'\n        volumes:\n          - pgdata:/var/lib/postgresql/data\n        networks:\n          bp-network:\n            ipv4_address: 172.25.0.5\n      pgadmin-portal:\n        image: dpage/pgadmin4\n        restart: always\n        container_name: pgadmin-portal\n        env_file:\n          - .env\n        environment:\n          PGADMIN_DEFAULT_PASSWORD: '${PGADMIN_DEFAULT_PASSWORD}'\n          PGADMIN_DEFAULT_EMAIL: '${PGADMIN_DEFAULT_EMAIL}'\n        volumes:\n          - pgadmin:/root/.pgadmin\n        ports:\n          - '${PGADMIN_PORT}:80'\n        depends_on:\n          - bp-pg-db\n        networks:\n          bp-network:\n            ipv4_address: 172.25.0.6\n    volumes:\n      pgdata:\n      pgadmin:\n    networks:\n      bp-network:\n        driver: bridge\n        ipam:\n          config:\n            - subnet: 172.25.0.0/16\n    \n\u003c/code\u003e\u003c/pre\u003e\n\u003col\u003e\n\u003cli\u003e\u003ccode\u003eServices\u003c/code\u003e: 每个服务代表一个将要创建的 Docker 容器\u003c/li\u003e\n\u003c/ol\u003e\n\u003cul\u003e\n\u003cli\u003efrontend: 基于前端项目的 Dockerfile.local 构建镜像以及容器. 此容器将会控制前端服务的启停.\u003c/li\u003e\n\u003cli\u003ebackend: 基于后端项目的 Dockerfile.local 构建镜像以及容器. 此容器将会控制后端服务的启停.\u003c/li\u003e\n\u003cli\u003ebp-pg-db: 基于镜像 postgres:12-alpine 构建的 postgres 数据库容器.\u003c/li\u003e\n\u003cli\u003epgadmin-portal: 基于镜像 dpage/pgadmin4 构建的 postgres 可视化界面操作服务.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e添加 Makefile 用来启动:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-Makefile\"\u003elocal: \n   docker-compose stop \u0026#x26;\u0026#x26; docker-compose up --build -d --remove-orphans\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e使用 \u003ccode\u003emake local\u003c/code\u003e 命令后, 将构建镜像并启动容器服务, 此时便能通过配置中暴露出的端口号来正常的访问到前端、后端以及数据库服务. 同时, 得益于 \u003ccode\u003eVOlUME\u003c/code\u003e, 我们在本地修改代码后能及时的映射到容器的挂卷中, 通过项目的热更新来开发项目.\u003c/p\u003e\n\u003ch2 id=\"生产环境部署\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#生产环境部署\"\u003e\u003cspan class=\"icon icon-link\"\u003e\u003c/span\u003e\u003c/a\u003e生产环境部署\u003c/h2\u003e\n\u003cp\u003etodo...\u003c/p\u003e","theme":"orange","tag":["Docker","Docker Compose","React","Nest","Monorepo","Pnpm","Nginx","Jenkins","PostgreSQL"]}},"__N_SSG":true},"page":"/posts/[slug]","query":{"slug":"Docker化一个React+Nest的Monorepo应用"},"buildId":"tq3FXJam7YL1cG21b1U6L","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>