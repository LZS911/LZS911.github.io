<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><link rel="apple-touch-icon" sizes="180x180" href="/favicon/apple-touch-icon.png"/><link rel="icon" type="image/png" sizes="32x32" href="/favicon/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="16x16" href="/favicon/favicon-16x16.png"/><link rel="manifest" href="/favicon/site.webmanifest"/><link rel="mask-icon" href="/favicon/safari-pinned-tab.svg" color="#000000"/><link rel="shortcut icon" href="/favicon/favicon.ico"/><meta name="msapplication-TileColor" content="#000000"/><meta name="msapplication-config" content="/favicon/browserconfig.xml"/><meta name="theme-color" content="#000"/><link rel="alternate" type="application/rss+xml" href="/feed.xml"/><meta property="og:image" content="https://og-image.vercel.app/Next.js%20Blog%20Starter%20Example.png?theme=light&amp;md=1&amp;fontSize=100px&amp;images=https%3A%2F%2Fassets.vercel.com%2Fimage%2Fupload%2Ffront%2Fassets%2Fdesign%2Fnextjs-black-logo.svg"/><title>Docker化一个React+Nest的Monorepo应用 | Ai.Haibara codes</title><meta name="next-head-count" content="14"/><link rel="preload" href="/_next/static/css/8681f744d5932be6.css" as="style"/><link rel="stylesheet" href="/_next/static/css/8681f744d5932be6.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-8fa1640cc84ba8fe.js" defer=""></script><script src="/_next/static/chunks/framework-3b5a00d5d7e8d93b.js" defer=""></script><script src="/_next/static/chunks/main-59a90320855f5cf5.js" defer=""></script><script src="/_next/static/chunks/pages/_app-f46e289d7ac5e197.js" defer=""></script><script src="/_next/static/chunks/799-575b46febca3af7d.js" defer=""></script><script src="/_next/static/chunks/399-cac0cd8ed02bf02a.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bslug%5D-e2afa3a98c674f72.js" defer=""></script><script src="/_next/static/xlPHhR-wYr_8CmIOtMS6f/_buildManifest.js" defer=""></script><script src="/_next/static/xlPHhR-wYr_8CmIOtMS6f/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="min-h-screen"><header class="text-white bg-black drop-shadow-2xl"><div class="mx-auto my-0 max-w-[960px] py-6 px-4 flex items-center"><div class="flex items-center"><img alt="Ai.Haibara" src="/assets/blog/authors/haibara_2.jpg" width="100" height="100" decoding="async" data-nimg="1" class=" rounded-full" loading="lazy" style="color:transparent"/></div><div class="ml-6"><a class=" font-bold text-3xl" href="/">Ai.Haibara codes</a><div class="mt-2"><a class="p-1 rounded-sm text-xl mr-2 hover:border-b-2 border-indigo" href="/">Home</a><a class="p-1 rounded-sm text-xl mr-2 hover:border-b-2 border-indigo" href="/projects">Projects</a><a class="p-1 rounded-sm text-xl mr-2 hover:border-b-2 border-indigo" href="/talks">Talks</a><a class="p-1 rounded-sm text-xl mr-2 hover:border-b-2 border-indigo" href="/blogs">Blogs</a></div></div></div></header><main class="p-6 flex justify-center"><article><div class="flex justify-center font-[Arial] max-w-[864px] text-center"><h1 class="text-5xl font-bold bg-indigo px-5 py-2 rounded-sm text-shadow-lg leading-[1.1]">Docker化一个React+Nest的Monorepo应用</h1></div><time dateTime="2023-04-25" class="text-center block my-4 text-sm opacity-60">April	25, 2023</time><section><div class="markdown-body-orange max-w-3xl"><h2 id="目标"><a aria-hidden="true" tabindex="-1" href="#目标"><span class="icon icon-link"></span></a>目标</h2>
<p>使用 <code>Docker</code> 和 <code>Docker Compose</code> 将一个使用 <a href="https://react.dev/">React</a> + <a href="https://nestjs.com/">NestJS</a> + <a href="https://www.postgresql.org/">PostgreSQL</a> + <a href="https://www.prisma.io/">prisma</a> 构建的 Web 应用程序 <strong>Dockerize</strong>。</p>
<h2 id="前置准备"><a aria-hidden="true" tabindex="-1" href="#前置准备"><span class="icon icon-link"></span></a>前置准备</h2>
<ul>
<li>安装 <a href="https://nodejs.org/en">Node.js</a>, 且保证 Node.js 版本为 v14.17.0 或者更高版本.</li>
<li>安装 <a href="https://docs.nestjs.com/cli/overview">Nest.js CLI</a></li>
<li>安装 <a href="https://pnpm.io/">Pnpm</a></li>
<li>安装 <a href="https://docs.docker.com/engine/install/">Docker Engine</a></li>
<li>安装 <a href="https://docs.docker.com/compose/install/">Docker Compose</a></li>
<li>安装 <a href="https://opensource.com/article/18/8/what-how-makefile">Make</a></li>
</ul>
<h2 id="项目结构"><a aria-hidden="true" tabindex="-1" href="#项目结构"><span class="icon icon-link"></span></a>项目结构</h2>
<h3 id="使用-pnpm-的-workspace-功能构建一个-monorepo"><a aria-hidden="true" tabindex="-1" href="#使用-pnpm-的-workspace-功能构建一个-monorepo"><span class="icon icon-link"></span></a>使用 Pnpm 的 <a href="https://pnpm.io/workspaces">Workspace</a> 功能构建一个 Monorepo</h3>
<p>对于一个 <code>Monorepo</code>, 我们需要创建在项目根路径创建一个 <code>packages</code> 文件夹. <code>packages</code> 里面包含了由 <a href="https://www.npmjs.com/package/create-vite">create-vite</a> 创建的 <code>React</code> 项目以及由 <code>Nest.js CLI</code> 创建的后端服务. 当然, 在项目根路径也需要创建一些全局的配置文件.</p>
<p>具体操作步骤如下:</p>
<ul>
<li>
<p>在根目录初始化一个新的 git 仓库并创建以下文件:</p>
<pre><code class="language-sh">.dockerignore
.gitignore
.env
.docker-compose.yaml
Makefile
</code></pre>
</li>
<li>
<p>创建 packages 文件用于存放前后端项目:</p>
<pre><code class="language-sh">mkdir packages &#x26;&#x26; cd packages
</code></pre>
</li>
<li>
<p>创建前端项目, 并添加 Dockerfile.local 以及 Dockerfile.production 文件</p>
<pre><code class="language-sh">pnpm create vite
</code></pre>
</li>
<li>
<p>创建后端项目, 并且在执行完后手动删除 node_modules, 同时也添加 Dockerfile.local 以及 Dockerfile.production 文件</p>
<pre><code class="language-sh">nest new backend
</code></pre>
</li>
<li>
<p>重新配置 tsconfig.json:</p>
<p>首先在项目根目录执行: <code>tsc --init</code>, 初始化一份 <code>tsconfig.json</code>, 并且将文件内容修改至以下内容:</p>
<pre><code class="language-json">  {
   "compilerOptions": {
     "module": "commonjs",
     "declaration": true,
     "removeComments": true,
     "emitDecoratorMetadata": true,
     "experimentalDecorators": true,
     "allowSyntheticDefaultImports": true,
     "target": "es2017",
     "sourceMap": true,
     "outDir": "./dist",
     "baseUrl": "./",
     "incremental": true,
     "skipLibCheck": true,
     "strictNullChecks": false,
     "noImplicitAny": false,
     "strictBindCallApply": false,
     "forceConsistentCasingInFileNames": true,
     "noFallthroughCasesInSwitch": false,
     "strict": true,
     "jsx": "react-jsx"
   },
   "include": ["packages/*/src"]
  }
</code></pre>
<p>最后将前后端项目中由工具创建的 <code>tsconfig.json</code> 文件内容修改至以下内容:</p>
<pre><code class="language-json">  {
   "extends": "../../tsconfig.json",
   "include": ["./src"]
  }
</code></pre>
</li>
<li>
<p>创建 pnpm-workspace.yml, 填充以下内容:</p>
<pre><code class="language-yml">  packages:
 - 'packages/**'
</code></pre>
</li>
<li>
<p>在根目录创建 package.json 文件, 并且将前后端相同的依赖项提取至其中. 执行 <code>pnpm install -r</code> , 完成依赖的安装.</p>
</li>
</ul>
<p>最后, 得到的项目结构应如下图所示</p>
<p><img src="/assets/docker-react-nest/example1.png" alt="alt"></p>
<h2 id="dockerize"><a aria-hidden="true" tabindex="-1" href="#dockerize"><span class="icon icon-link"></span></a>Dockerize</h2>
<h3 id="backend-dockerfile"><a aria-hidden="true" tabindex="-1" href="#backend-dockerfile"><span class="icon icon-link"></span></a>Backend Dockerfile</h3>
<p>回到本文主题, 现在, 我们的 Backend 文件夹中包含了两个 Dockerfile 文件. 其中一个用于在本地运行项目, 它用于docker-compose.yaml 文件, 而另一个用于生产环境.</p>
<p>现在将以下内容填充至 Dockerfile.local:</p>
<pre><code class="language-dockerfile">#获取node镜像源
FROM node:16.16.0-alpine

#设置工作目录
WORKDIR /projects

# 将 pnpm-lock.yaml 拷贝至工作目录, 为后续的 pnpm fetch 做准备
COPY ./pnpm-lock.yaml ./

# 安装 pnpm, 并且固定版本, 也可以考虑在获取node镜像源时直接获取带有pnpm的镜像, 这样就能省略这一步了
RUN npm install -g pnpm@8.3.1

# pnpm fetch 通过提供仅使用锁定文件中的信息将包加载到虚拟存储中的能力，完美地解决了上述问题. 具体见: https://pnpm.io/cli/fetch
RUN pnpm fetch

COPY . .

# 安装依赖, 关于 --offline 见: https://pnpm.io/cli/fetch
RUN pnpm install -r --offline

# https://zhuanlan.zhihu.com/p/89335014
VOLUME ["/projects/node_modules/", "/projects/packages/backend/node_modules/", "/projects/.pnpm-store/"]

# https://yeasy.gitbook.io/docker_practice/image/dockerfile/expose
EXPOSE $BACKEND_PORT

# 启动后端服务
CMD rm -rf dist &#x26;&#x26; cd packages/backend &#x26;&#x26; pnpm start:debug
</code></pre>
<h3 id="frontend-dockerfile"><a aria-hidden="true" tabindex="-1" href="#frontend-dockerfile"><span class="icon icon-link"></span></a>Frontend Dockerfile</h3>
<p>前端文件夹下的 Dockerfile:</p>
<pre><code class="language-dockerfile">#获取node镜像源
FROM node:16.16.0-alpine

#设置工作目录
WORKDIR /app

# 将 pnpm-lock.yaml 拷贝至工作目录, 为后续的 pnpm fetch 做准备
COPY ./pnpm-lock.yaml ./

# 安装 pnpm, 并且固定版本, 也可以考虑在获取node镜像源时直接获取带有pnpm的镜像, 这样就能省略这一步了
RUN npm install -g pnpm@8.3.1

# pnpm fetch 通过提供仅使用锁定文件中的信息将包加载到虚拟存储中的能力，完美地解决了上述问题. 具体见: https://pnpm.io/cli/fetch
RUN pnpm fetch

COPY . .

# 安装依赖, 关于 --offline 见: https://pnpm.io/cli/fetch
RUN pnpm install -r --offline

# https://zhuanlan.zhihu.com/p/89335014
VOLUME ["/app/node_modules/", "/app/packages/frontend/node_modules/", "/app/.pnpm-store/"]

# 启动前端服务
CMD cd packages/frontend &#x26;&#x26; pnpm start

</code></pre>
<h3 id="创建-docker-compose-文件并运行项目"><a aria-hidden="true" tabindex="-1" href="#创建-docker-compose-文件并运行项目"><span class="icon icon-link"></span></a>创建 Docker Compose 文件并运行项目</h3>
<ol>
<li>
<p>配置环境变量: 将以下内容填充至 <code>&#x3C;rootDir>/.env</code></p>
<pre><code class="language-sh">   NODE_ENV=development
   FRONTEND_PORT=7879
   BACKEND_PORT=7878
   JWT_SECRET=jwt_secret_key_here
   JWT_EXPIRES_IN=30d
   DB_HOST=bp-pg-db
   DB_NAME=bp-pg-db
   DB_USER=postgres
   DB_PASSWORD=root
   DB_PORT=5432
   PGADMIN_DEFAULT_EMAIL=admin@backend.com
   PGADMIN_DEFAULT_PASSWORD=pass@123
   PGADMIN_PORT=5055
</code></pre>
</li>
<li>
<p>将以下内容填充至 <code>&#x3C;rootDIr>/docker-compose.yml</code></p>
<pre><code class="language-yml">    version: '3.9'
    services:
      frontend:
        container_name: frontend
        build:
          context: ./
          dockerfile: ./packages/frontend/Dockerfile.local
        restart: always
        env_file: .env
        ports:
          - '${FRONTEND_PORT}:${FRONTEND_PORT}'
        volumes:
          - .:/app
        networks:
          bp-network:
            ipv4_address: 172.25.0.3
      backend:
        container_name: backend
        build:
          context: ./
          dockerfile: ./packages/backend/Dockerfile.local
        restart: always
        env_file: .env
        volumes:
          - .:/app
        networks:
          bp-network:
            ipv4_address: 172.25.0.2
        ports:
          - '${BACKEND_PORT}:${BACKEND_PORT}'
        depends_on:
          - bp-pg-db
        links:
          - bp-pg-db
      bp-pg-db:
        image: postgres:12-alpine
        restart: always
        container_name: bp-pg-db
        env_file:
          - .env
        environment:
          POSTGRES_PASSWORD: ${DB_PASSWORD}
          PGDATA: /var/lib/postgresql/data
          POSTGRES_USER: ${DB_USER}
          POSTGRES_DB: ${DB_NAME}
        ports:
          - '${DB_PORT}:${DB_PORT}'
        volumes:
          - pgdata:/var/lib/postgresql/data
        networks:
          bp-network:
            ipv4_address: 172.25.0.5
      pgadmin-portal:
        image: dpage/pgadmin4
        restart: always
        container_name: pgadmin-portal
        env_file:
          - .env
        environment:
          PGADMIN_DEFAULT_PASSWORD: '${PGADMIN_DEFAULT_PASSWORD}'
          PGADMIN_DEFAULT_EMAIL: '${PGADMIN_DEFAULT_EMAIL}'
        volumes:
          - pgadmin:/root/.pgadmin
        ports:
          - '${PGADMIN_PORT}:80'
        depends_on:
          - bp-pg-db
        networks:
          bp-network:
            ipv4_address: 172.25.0.6
    volumes:
      pgdata:
      pgadmin:
    networks:
      bp-network:
        driver: bridge
        ipam:
          config:
            - subnet: 172.25.0.0/16
    
</code></pre>
<ol>
<li><code>Services</code>: 每个服务代表一个将要创建的 Docker 容器</li>
</ol>
<ul>
<li>frontend: 基于前端项目的 Dockerfile.local 构建镜像以及容器. 此容器将会控制前端服务的启停.</li>
<li>backend: 基于后端项目的 Dockerfile.local 构建镜像以及容器. 此容器将会控制后端服务的启停.</li>
<li>bp-pg-db: 基于镜像 postgres:12-alpine 构建的 postgres 数据库容器.</li>
<li>pgadmin-portal: 基于镜像 dpage/pgadmin4 构建的 postgres 可视化界面操作服务.</li>
</ul>
</li>
<li>
<p>添加 Makefile 用来启动:</p>
<pre><code class="language-Makefile">local: 
   docker-compose stop &#x26;&#x26; docker-compose up --build -d --remove-orphans
</code></pre>
</li>
</ol>
<p>使用 <code>make local</code> 命令后, 将构建镜像并启动容器服务, 此时便能通过配置中暴露出的端口号来正常的访问到前端、后端以及数据库服务. 同时, 得益于 <code>VOlUME</code>, 我们在本地修改代码后能及时的映射到容器的挂卷中, 通过项目的热更新来开发项目.</p>
<h2 id="生产环境部署"><a aria-hidden="true" tabindex="-1" href="#生产环境部署"><span class="icon icon-link"></span></a>生产环境部署</h2>
<h3 id="frontend-项目"><a aria-hidden="true" tabindex="-1" href="#frontend-项目"><span class="icon icon-link"></span></a>frontend 项目</h3>
<p><strong>目标: 利用 github webhook 在项目push代码后自动触发 jenkins 流水线用来构建项目</strong></p>
<p>环境准备:</p>
<ol>
<li>
<p>创建以下文件夹:</p>
<ul>
<li>jenkins/jenkins/home: 用来存放 jenkins 配置文件以及插件和 jenkins 的工作区等内容.</li>
<li>nginx/default.conf: nginx 的配置文件</li>
<li>webserver/static/jenkins/dist: 存放前端项目打包后的产物</li>
<li>docker-compose.yml: docker-compose 的配置文件</li>
</ul>
<p>default.conf 内容如下(本文不涉及 nginx 配置知识, 所以这里使用一个最基本的配置文件):</p>
<pre><code class="language-conf">  server{
    listen  80;
    server_name localhost;
    root /usr/share/nginx/html;
    index index.html;
  
    location / {
       try_files $uri $uri/ /index.html =404;
    }
          
  # location /v {
  # 根据项目配置反向代理  
  #   proxy_pass &#x3C;http://localhost:7878>
  # }
}
</code></pre>
</li>
<li>
<p>编写 <code>docker-compose.yml</code> 来构建 jenkins 容器以及部署前端项目的 nginx 容器, 内容如下:</p>
<pre><code class="language-yml">   version: "3.9"
     services:                                      
       docker_jenkins:
         environment:
           - TZ=Asia/Shanghai
         user: root                                
         restart: always                           
         image: jenkins/jenkins:lts              
         container_name: cicd-jenkins                 
         ports:                                
           - 8077:8080                             
           - 50000:50000                          
         volumes:                               
           - ./jenkins/jenkins_home/:/var/jenkins_home  
           - /var/run/docker.sock:/var/run/docker.sock
           - /usr/bin/docker:/usr/bin/docker              
           - /usr/local/bin/docker-compose:/usr/local/bin/docker-compose
       docker_nginx:
         environment:
           - TZ=Asia/Shanghai
         restart: always
         image: nginx:stable-alpine               
         container_name: cicd-nginx
         ports:
           - 7070:80                             
         volumes:
           - ./nginx/:/etc/nginx/conf.d/
           - ./webserver/static/jenkins/dist/:/usr/share/nginx/html/
</code></pre>
</li>
<li>
<p>执行 <code>docker-compose up --build -d --remove-orphans</code> 后, 此时应该会成功启动两个容器, 可以使用 <code>docker container ls</code> 查看:, 大致内容如下:</p>
<p><img src="/assets/docker-react-nest/example2.png" alt="alt"></p>
<p>此时在本地访问 <code>http://ip(容器的宿主主机ip地址):8077</code> 应该能够正常访问 jenkins 服务, 初始化界面应该如下:</p>
<p><img src="/assets/docker-react-nest/example3.png" alt="alt"></p>
<p>在宿主主机上执行 <code>docker logs [container_id]</code>, 从 log 信息从获取管理源密码, 然后进入插件安装页面, 这里安装推荐插件即可.</p>
</li>
<li>
<p>插件安装完成且创建用户进入 jenkins 后点击 <strong>Manage Jenkins</strong>, 然后再点击进入<strong>Manage Plugins</strong>. 这里需要安装 <code>Node</code> 插件以及 <code>Publish over SSH</code>.</p>
<p>前者为构建流程提供 <code>NodeJs</code> 环境, 后者将构建完成后得到的前端产物压缩包上传至目标服务器.</p>
<p><img src="/assets/docker-react-nest/example4.png" alt="alt"></p>
</li>
<li>
<p>配置 <code>NodeJs</code> 环境. 点击 <strong>系统管理</strong>, 然后再点击进入<strong>全局工具配置</strong>, 找到 NodeJS, 点击 <strong>新增NodeJS</strong>. 最后根据项目的需求进行选择 <code>Node</code> 版本以及是否要安装全局工具即可.</p>
<p><img src="/assets/docker-react-nest/example5.png" alt="alt"></p>
</li>
<li>
<p>点击系统管理中的<strong>Credentials</strong>, 然后添加 github 的凭据. 可以添加 github 的 token、账号密码以及公私钥三种类型的凭据.</p>
</li>
<li>
<p>配置 github-webhook. 点击系统管理中的<strong>系统配置</strong>, 找到 Github, 然后点击<strong>添加Github</strong>服务器, 在凭据一栏添加在上一步添加的 Github 凭据.</p>
<p><img src="/assets/docker-react-nest/example6.png" alt="alt"></p>
<p>找到最下方的更多按钮, 点击后会出现覆盖 Hook URL的选项, 将这里的地址绑定到 github 项目上的 webhook 即可.
当然, 如果 jenkins 容器宿主主机为本地主机或者为内网主机, 可使用 <a href="https://dashboard.ngrok.com/">ngrok</a> 实现内网穿透, 来保证 github 能访问到 jenkins.</p>
<p>注意事项:</p>
<ol>
<li>github-webhook地址前缀需与 jenkins 配置中的 <strong>Jenkins URL</strong> 保持一致.</li>
<li>关于 <a href="https://docs.github.com/en/webhooks-and-events/webhooks/about-webhooks">github webhook</a>.</li>
</ol>
</li>
<li>
<p>添加服务器信息. 在系统配置中找到<strong>Publish over SSH</strong>, 在 Passphrase 一栏填入服务器密码, 然后点击<strong>新增</strong>, 填入服务器信息.</p>
<p><img src="/assets/docker-react-nest/example7.png" alt="alt"></p>
</li>
<li>
<p>创建任务</p>
<ul>
<li>
<p>点击新建任务, 输入任务名称后选择<strong>构建一个自由风格的软件项目</strong>
<img src="/assets/docker-react-nest/example8.png" alt="alt"></p>
</li>
<li>
<p>源码管理里输入项目地址、添加 Github 凭据, 选择项目分支.
<img src="/assets/docker-react-nest/example9.png" alt="alt"></p>
</li>
<li>
<p>构建触发器里选择 <strong>GitHub hook trigger for GITScm polling</strong>
<img src="/assets/docker-react-nest/example10.png" alt="alt"></p>
</li>
<li>
<p>选择构建环境
<img src="/assets/docker-react-nest/example11.png" alt="alt"></p>
</li>
<li>
<p>添加构建步骤. 这里可以将步骤放在 <code>Makefile</code> 文件中或者 <code>sh</code> 脚本中, 这样每次更新步骤只需要更新配置文件, 而不用修改 jenkins 配置. 当然这一步也可以用 <a href="https://www.jenkins.io/zh/doc/book/pipeline/jenkinsfile/">Jenkinsfile</a>替代.
<img src="/assets/docker-react-nest/example12.png" alt="alt"></p>
<p><code>build.sh</code>:</p>
<pre><code class="language-sh"> pnpm fetch
 pnpm install -r --offline
 
 # frontend
 pnpm build:frontend
 cd ./packages/frontend
 tar zcf frontend.tar.gz ./dist
 mv ./frontend.tar.gz ../../frontend.tar.gz
</code></pre>
</li>
<li>
<p>添加构建后的操作. 这里选择 <strong>Send build artifacts over SSH</strong>, 填入以下内容:
<img src="/assets/docker-react-nest/example13.png" alt="alt">
其中 SSH Server Name 为上一步添加的服务器名称.</p>
</li>
</ul>
</li>
</ol>
<p>到这里, 一个前端项目的自动化部署基本完成了. 在提交项目代码后, 便会自动触发任务, 进行项目构建, 并将构建后的产物上传至目标服务器. 然后将文件内容映射到 nginx 容器中.</p>
<p>关于 <code>NestJs</code> 服务的部署, 将构建开发环境中的 <code>docker-compose.yml</code>稍微进行改造即可, 内容如下:</p>
<pre><code class="language-yml">version: '3.9'
services:
  backend-prod:
    container_name: backend-prod
    user: root
    build:
      context: ./
      dockerfile: ./packages/backend/Dockerfile.prod
    image: webserver-backend-prod
    restart: always
    env_file: .env
    networks:
      bp-network:
        ipv4_address: 172.25.0.2
    ports:
      - '${BACKEND_PORT}:3535'
    depends_on:
      - bp-pg-db-prod
    command: [sh, -c, "cd packages/backend &#x26;&#x26; pnpm migrate:postgres &#x26;&#x26; pnpm prisma:gen &#x26;&#x26; pnpm build &#x26;&#x26; pnpm start:prod"]
  bp-pg-db-prod:
    image: postgres:12-alpine
    restart: always
    container_name: bp-pg-db-prod
    env_file:
      - .env
    environment:
      POSTGRES_PASSWORD: ${DB_PASSWORD}
      PGDATA: /var/lib/postgresql/data
      POSTGRES_USER: ${DB_USER}
      POSTGRES_DB: ${DB_NAME}
    ports:
      - '${DB_PORT}:${DB_PORT}'
    volumes:
      - pgdata:/var/lib/postgresql/data
    networks:
      bp-network:
        ipv4_address: 172.25.0.5
  pgadmin-portal-prod:
    image: dpage/pgadmin4
    restart: always
    container_name: pgadmin-portal-prod
    env_file:
      - .env
    environment:
      PGADMIN_DEFAULT_PASSWORD: '${PGADMIN_DEFAULT_PASSWORD}'
      PGADMIN_DEFAULT_EMAIL: '${PGADMIN_DEFAULT_EMAIL}'
    volumes:
      - pgadmin:/root/.pgadmin
    ports:
      - '${PGADMIN_PORT}:80'
    depends_on:
      - bp-pg-db-prod
    networks:
      bp-network:
        ipv4_address: 172.25.0.6
volumes:
  pgdata:
  pgadmin:
networks:
  bp-network:
    driver: bridge
    ipam:
      config:
        - subnet: 172.25.0.0/16

</code></pre>
<p>Dockerfile.prod:</p>
<pre><code class="language-dockerfile">FROM node:16.16.0-alpine


WORKDIR /app

COPY ./pnpm-lock.yaml ./

RUN npm install -g pnpm@8.3.1

RUN pnpm fetch

COPY . .

RUN pnpm install -r --offline

VOLUME ["/app/node_modules/", "/app/packages/backend/node_modules/", "/app/.pnpm-store/"]
</code></pre>
<p>由于本文所构建项目为一个 Monorepo, 所以在提交前端代码时同时会触发后端项目的构建, 所以我们仅需将以下内容添加至前端构建流程中的 <code>./scripts/build.sh</code>即可:</p>
<pre><code class="language-sh">docker-compose -f docker-compose.server.yaml stop &#x26;&#x26; docker-compose -f docker-compose.server.yaml up --build -d --remove-orphans
</code></pre>
<p>注意事项:</p>
<ol>
<li>需要移除 docker-compose 中后端服务的 volume. 由于jenkins在构建完成后会清空工作区, 所以这里不需要同构建开发环境一样进行文件映射.</li>
<li>NestJS 项目中开发环境以及生产环境中环境变量的区分.</li>
</ol>
<p>最后, 构建完成后, 宿主主机上容器列表如下:</p>
<p><img src="/assets/docker-react-nest/example14.png" alt="alt"></p>
<p>通过 http:[ip]:7878 即可正常访问后端服务, http:[ip]:5055 可访问 pgadmin.</p>
<p>项目地址: <a href="https://github.com/LZS911/todo-react-nest-docker">https://github.com/LZS911/todo-react-nest-docker</a></p>
<p>jenkins+nginx容器构建: <a href="https://github.com/LZS911/jenkins-nginx-docker">https://github.com/LZS911/jenkins-nginx-docker</a></p></div></section></article></main><footer class="bg-neutral-50 border-t border-neutral-200 text-center text-xs opacity-50 py-4">© 2022,<!-- --> <a rel="noopener noreferrer" class="hover:underline hover:bg-indigo" href="https://github.com/LZS911" target="_blank">LZS_911</a>, build with<!-- --> <a rel="noopener noreferrer" class="underline hover:bg-indigo" href="https://nextjs.org/" target="_blank">Next.js</a> <!-- -->and<!-- --> <a rel="noopener noreferrer" class="underline hover:bg-indigo" href="https://pages.github.com/?(null)" target="_blank">GitHub Pages</a></footer></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"Docker化一个React+Nest的Monorepo应用","date":"2023-04-25","slug":"Docker化一个React+Nest的Monorepo应用","author":"Ai.Haibara","content":"\u003ch2 id=\"目标\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#目标\"\u003e\u003cspan class=\"icon icon-link\"\u003e\u003c/span\u003e\u003c/a\u003e目标\u003c/h2\u003e\n\u003cp\u003e使用 \u003ccode\u003eDocker\u003c/code\u003e 和 \u003ccode\u003eDocker Compose\u003c/code\u003e 将一个使用 \u003ca href=\"https://react.dev/\"\u003eReact\u003c/a\u003e + \u003ca href=\"https://nestjs.com/\"\u003eNestJS\u003c/a\u003e + \u003ca href=\"https://www.postgresql.org/\"\u003ePostgreSQL\u003c/a\u003e + \u003ca href=\"https://www.prisma.io/\"\u003eprisma\u003c/a\u003e 构建的 Web 应用程序 \u003cstrong\u003eDockerize\u003c/strong\u003e。\u003c/p\u003e\n\u003ch2 id=\"前置准备\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#前置准备\"\u003e\u003cspan class=\"icon icon-link\"\u003e\u003c/span\u003e\u003c/a\u003e前置准备\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e安装 \u003ca href=\"https://nodejs.org/en\"\u003eNode.js\u003c/a\u003e, 且保证 Node.js 版本为 v14.17.0 或者更高版本.\u003c/li\u003e\n\u003cli\u003e安装 \u003ca href=\"https://docs.nestjs.com/cli/overview\"\u003eNest.js CLI\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e安装 \u003ca href=\"https://pnpm.io/\"\u003ePnpm\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e安装 \u003ca href=\"https://docs.docker.com/engine/install/\"\u003eDocker Engine\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e安装 \u003ca href=\"https://docs.docker.com/compose/install/\"\u003eDocker Compose\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e安装 \u003ca href=\"https://opensource.com/article/18/8/what-how-makefile\"\u003eMake\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"项目结构\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#项目结构\"\u003e\u003cspan class=\"icon icon-link\"\u003e\u003c/span\u003e\u003c/a\u003e项目结构\u003c/h2\u003e\n\u003ch3 id=\"使用-pnpm-的-workspace-功能构建一个-monorepo\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#使用-pnpm-的-workspace-功能构建一个-monorepo\"\u003e\u003cspan class=\"icon icon-link\"\u003e\u003c/span\u003e\u003c/a\u003e使用 Pnpm 的 \u003ca href=\"https://pnpm.io/workspaces\"\u003eWorkspace\u003c/a\u003e 功能构建一个 Monorepo\u003c/h3\u003e\n\u003cp\u003e对于一个 \u003ccode\u003eMonorepo\u003c/code\u003e, 我们需要创建在项目根路径创建一个 \u003ccode\u003epackages\u003c/code\u003e 文件夹. \u003ccode\u003epackages\u003c/code\u003e 里面包含了由 \u003ca href=\"https://www.npmjs.com/package/create-vite\"\u003ecreate-vite\u003c/a\u003e 创建的 \u003ccode\u003eReact\u003c/code\u003e 项目以及由 \u003ccode\u003eNest.js CLI\u003c/code\u003e 创建的后端服务. 当然, 在项目根路径也需要创建一些全局的配置文件.\u003c/p\u003e\n\u003cp\u003e具体操作步骤如下:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e在根目录初始化一个新的 git 仓库并创建以下文件:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-sh\"\u003e.dockerignore\n.gitignore\n.env\n.docker-compose.yaml\nMakefile\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e创建 packages 文件用于存放前后端项目:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-sh\"\u003emkdir packages \u0026#x26;\u0026#x26; cd packages\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e创建前端项目, 并添加 Dockerfile.local 以及 Dockerfile.production 文件\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-sh\"\u003epnpm create vite\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e创建后端项目, 并且在执行完后手动删除 node_modules, 同时也添加 Dockerfile.local 以及 Dockerfile.production 文件\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-sh\"\u003enest new backend\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e重新配置 tsconfig.json:\u003c/p\u003e\n\u003cp\u003e首先在项目根目录执行: \u003ccode\u003etsc --init\u003c/code\u003e, 初始化一份 \u003ccode\u003etsconfig.json\u003c/code\u003e, 并且将文件内容修改至以下内容:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-json\"\u003e  {\n   \"compilerOptions\": {\n     \"module\": \"commonjs\",\n     \"declaration\": true,\n     \"removeComments\": true,\n     \"emitDecoratorMetadata\": true,\n     \"experimentalDecorators\": true,\n     \"allowSyntheticDefaultImports\": true,\n     \"target\": \"es2017\",\n     \"sourceMap\": true,\n     \"outDir\": \"./dist\",\n     \"baseUrl\": \"./\",\n     \"incremental\": true,\n     \"skipLibCheck\": true,\n     \"strictNullChecks\": false,\n     \"noImplicitAny\": false,\n     \"strictBindCallApply\": false,\n     \"forceConsistentCasingInFileNames\": true,\n     \"noFallthroughCasesInSwitch\": false,\n     \"strict\": true,\n     \"jsx\": \"react-jsx\"\n   },\n   \"include\": [\"packages/*/src\"]\n  }\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e最后将前后端项目中由工具创建的 \u003ccode\u003etsconfig.json\u003c/code\u003e 文件内容修改至以下内容:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-json\"\u003e  {\n   \"extends\": \"../../tsconfig.json\",\n   \"include\": [\"./src\"]\n  }\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e创建 pnpm-workspace.yml, 填充以下内容:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-yml\"\u003e  packages:\n - 'packages/**'\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e在根目录创建 package.json 文件, 并且将前后端相同的依赖项提取至其中. 执行 \u003ccode\u003epnpm install -r\u003c/code\u003e , 完成依赖的安装.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e最后, 得到的项目结构应如下图所示\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/docker-react-nest/example1.png\" alt=\"alt\"\u003e\u003c/p\u003e\n\u003ch2 id=\"dockerize\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#dockerize\"\u003e\u003cspan class=\"icon icon-link\"\u003e\u003c/span\u003e\u003c/a\u003eDockerize\u003c/h2\u003e\n\u003ch3 id=\"backend-dockerfile\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#backend-dockerfile\"\u003e\u003cspan class=\"icon icon-link\"\u003e\u003c/span\u003e\u003c/a\u003eBackend Dockerfile\u003c/h3\u003e\n\u003cp\u003e回到本文主题, 现在, 我们的 Backend 文件夹中包含了两个 Dockerfile 文件. 其中一个用于在本地运行项目, 它用于docker-compose.yaml 文件, 而另一个用于生产环境.\u003c/p\u003e\n\u003cp\u003e现在将以下内容填充至 Dockerfile.local:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-dockerfile\"\u003e#获取node镜像源\nFROM node:16.16.0-alpine\n\n#设置工作目录\nWORKDIR /projects\n\n# 将 pnpm-lock.yaml 拷贝至工作目录, 为后续的 pnpm fetch 做准备\nCOPY ./pnpm-lock.yaml ./\n\n# 安装 pnpm, 并且固定版本, 也可以考虑在获取node镜像源时直接获取带有pnpm的镜像, 这样就能省略这一步了\nRUN npm install -g pnpm@8.3.1\n\n# pnpm fetch 通过提供仅使用锁定文件中的信息将包加载到虚拟存储中的能力，完美地解决了上述问题. 具体见: https://pnpm.io/cli/fetch\nRUN pnpm fetch\n\nCOPY . .\n\n# 安装依赖, 关于 --offline 见: https://pnpm.io/cli/fetch\nRUN pnpm install -r --offline\n\n# https://zhuanlan.zhihu.com/p/89335014\nVOLUME [\"/projects/node_modules/\", \"/projects/packages/backend/node_modules/\", \"/projects/.pnpm-store/\"]\n\n# https://yeasy.gitbook.io/docker_practice/image/dockerfile/expose\nEXPOSE $BACKEND_PORT\n\n# 启动后端服务\nCMD rm -rf dist \u0026#x26;\u0026#x26; cd packages/backend \u0026#x26;\u0026#x26; pnpm start:debug\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"frontend-dockerfile\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#frontend-dockerfile\"\u003e\u003cspan class=\"icon icon-link\"\u003e\u003c/span\u003e\u003c/a\u003eFrontend Dockerfile\u003c/h3\u003e\n\u003cp\u003e前端文件夹下的 Dockerfile:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-dockerfile\"\u003e#获取node镜像源\nFROM node:16.16.0-alpine\n\n#设置工作目录\nWORKDIR /app\n\n# 将 pnpm-lock.yaml 拷贝至工作目录, 为后续的 pnpm fetch 做准备\nCOPY ./pnpm-lock.yaml ./\n\n# 安装 pnpm, 并且固定版本, 也可以考虑在获取node镜像源时直接获取带有pnpm的镜像, 这样就能省略这一步了\nRUN npm install -g pnpm@8.3.1\n\n# pnpm fetch 通过提供仅使用锁定文件中的信息将包加载到虚拟存储中的能力，完美地解决了上述问题. 具体见: https://pnpm.io/cli/fetch\nRUN pnpm fetch\n\nCOPY . .\n\n# 安装依赖, 关于 --offline 见: https://pnpm.io/cli/fetch\nRUN pnpm install -r --offline\n\n# https://zhuanlan.zhihu.com/p/89335014\nVOLUME [\"/app/node_modules/\", \"/app/packages/frontend/node_modules/\", \"/app/.pnpm-store/\"]\n\n# 启动前端服务\nCMD cd packages/frontend \u0026#x26;\u0026#x26; pnpm start\n\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"创建-docker-compose-文件并运行项目\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#创建-docker-compose-文件并运行项目\"\u003e\u003cspan class=\"icon icon-link\"\u003e\u003c/span\u003e\u003c/a\u003e创建 Docker Compose 文件并运行项目\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e配置环境变量: 将以下内容填充至 \u003ccode\u003e\u0026#x3C;rootDir\u003e/.env\u003c/code\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-sh\"\u003e   NODE_ENV=development\n   FRONTEND_PORT=7879\n   BACKEND_PORT=7878\n   JWT_SECRET=jwt_secret_key_here\n   JWT_EXPIRES_IN=30d\n   DB_HOST=bp-pg-db\n   DB_NAME=bp-pg-db\n   DB_USER=postgres\n   DB_PASSWORD=root\n   DB_PORT=5432\n   PGADMIN_DEFAULT_EMAIL=admin@backend.com\n   PGADMIN_DEFAULT_PASSWORD=pass@123\n   PGADMIN_PORT=5055\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e将以下内容填充至 \u003ccode\u003e\u0026#x3C;rootDIr\u003e/docker-compose.yml\u003c/code\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-yml\"\u003e    version: '3.9'\n    services:\n      frontend:\n        container_name: frontend\n        build:\n          context: ./\n          dockerfile: ./packages/frontend/Dockerfile.local\n        restart: always\n        env_file: .env\n        ports:\n          - '${FRONTEND_PORT}:${FRONTEND_PORT}'\n        volumes:\n          - .:/app\n        networks:\n          bp-network:\n            ipv4_address: 172.25.0.3\n      backend:\n        container_name: backend\n        build:\n          context: ./\n          dockerfile: ./packages/backend/Dockerfile.local\n        restart: always\n        env_file: .env\n        volumes:\n          - .:/app\n        networks:\n          bp-network:\n            ipv4_address: 172.25.0.2\n        ports:\n          - '${BACKEND_PORT}:${BACKEND_PORT}'\n        depends_on:\n          - bp-pg-db\n        links:\n          - bp-pg-db\n      bp-pg-db:\n        image: postgres:12-alpine\n        restart: always\n        container_name: bp-pg-db\n        env_file:\n          - .env\n        environment:\n          POSTGRES_PASSWORD: ${DB_PASSWORD}\n          PGDATA: /var/lib/postgresql/data\n          POSTGRES_USER: ${DB_USER}\n          POSTGRES_DB: ${DB_NAME}\n        ports:\n          - '${DB_PORT}:${DB_PORT}'\n        volumes:\n          - pgdata:/var/lib/postgresql/data\n        networks:\n          bp-network:\n            ipv4_address: 172.25.0.5\n      pgadmin-portal:\n        image: dpage/pgadmin4\n        restart: always\n        container_name: pgadmin-portal\n        env_file:\n          - .env\n        environment:\n          PGADMIN_DEFAULT_PASSWORD: '${PGADMIN_DEFAULT_PASSWORD}'\n          PGADMIN_DEFAULT_EMAIL: '${PGADMIN_DEFAULT_EMAIL}'\n        volumes:\n          - pgadmin:/root/.pgadmin\n        ports:\n          - '${PGADMIN_PORT}:80'\n        depends_on:\n          - bp-pg-db\n        networks:\n          bp-network:\n            ipv4_address: 172.25.0.6\n    volumes:\n      pgdata:\n      pgadmin:\n    networks:\n      bp-network:\n        driver: bridge\n        ipam:\n          config:\n            - subnet: 172.25.0.0/16\n    \n\u003c/code\u003e\u003c/pre\u003e\n\u003col\u003e\n\u003cli\u003e\u003ccode\u003eServices\u003c/code\u003e: 每个服务代表一个将要创建的 Docker 容器\u003c/li\u003e\n\u003c/ol\u003e\n\u003cul\u003e\n\u003cli\u003efrontend: 基于前端项目的 Dockerfile.local 构建镜像以及容器. 此容器将会控制前端服务的启停.\u003c/li\u003e\n\u003cli\u003ebackend: 基于后端项目的 Dockerfile.local 构建镜像以及容器. 此容器将会控制后端服务的启停.\u003c/li\u003e\n\u003cli\u003ebp-pg-db: 基于镜像 postgres:12-alpine 构建的 postgres 数据库容器.\u003c/li\u003e\n\u003cli\u003epgadmin-portal: 基于镜像 dpage/pgadmin4 构建的 postgres 可视化界面操作服务.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e添加 Makefile 用来启动:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-Makefile\"\u003elocal: \n   docker-compose stop \u0026#x26;\u0026#x26; docker-compose up --build -d --remove-orphans\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e使用 \u003ccode\u003emake local\u003c/code\u003e 命令后, 将构建镜像并启动容器服务, 此时便能通过配置中暴露出的端口号来正常的访问到前端、后端以及数据库服务. 同时, 得益于 \u003ccode\u003eVOlUME\u003c/code\u003e, 我们在本地修改代码后能及时的映射到容器的挂卷中, 通过项目的热更新来开发项目.\u003c/p\u003e\n\u003ch2 id=\"生产环境部署\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#生产环境部署\"\u003e\u003cspan class=\"icon icon-link\"\u003e\u003c/span\u003e\u003c/a\u003e生产环境部署\u003c/h2\u003e\n\u003ch3 id=\"frontend-项目\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#frontend-项目\"\u003e\u003cspan class=\"icon icon-link\"\u003e\u003c/span\u003e\u003c/a\u003efrontend 项目\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003e目标: 利用 github webhook 在项目push代码后自动触发 jenkins 流水线用来构建项目\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e环境准备:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e创建以下文件夹:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003ejenkins/jenkins/home: 用来存放 jenkins 配置文件以及插件和 jenkins 的工作区等内容.\u003c/li\u003e\n\u003cli\u003enginx/default.conf: nginx 的配置文件\u003c/li\u003e\n\u003cli\u003ewebserver/static/jenkins/dist: 存放前端项目打包后的产物\u003c/li\u003e\n\u003cli\u003edocker-compose.yml: docker-compose 的配置文件\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003edefault.conf 内容如下(本文不涉及 nginx 配置知识, 所以这里使用一个最基本的配置文件):\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-conf\"\u003e  server{\n    listen  80;\n    server_name localhost;\n    root /usr/share/nginx/html;\n    index index.html;\n  \n    location / {\n       try_files $uri $uri/ /index.html =404;\n    }\n          \n  # location /v {\n  # 根据项目配置反向代理  \n  #   proxy_pass \u0026#x3C;http://localhost:7878\u003e\n  # }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e编写 \u003ccode\u003edocker-compose.yml\u003c/code\u003e 来构建 jenkins 容器以及部署前端项目的 nginx 容器, 内容如下:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-yml\"\u003e   version: \"3.9\"\n     services:                                      \n       docker_jenkins:\n         environment:\n           - TZ=Asia/Shanghai\n         user: root                                \n         restart: always                           \n         image: jenkins/jenkins:lts              \n         container_name: cicd-jenkins                 \n         ports:                                \n           - 8077:8080                             \n           - 50000:50000                          \n         volumes:                               \n           - ./jenkins/jenkins_home/:/var/jenkins_home  \n           - /var/run/docker.sock:/var/run/docker.sock\n           - /usr/bin/docker:/usr/bin/docker              \n           - /usr/local/bin/docker-compose:/usr/local/bin/docker-compose\n       docker_nginx:\n         environment:\n           - TZ=Asia/Shanghai\n         restart: always\n         image: nginx:stable-alpine               \n         container_name: cicd-nginx\n         ports:\n           - 7070:80                             \n         volumes:\n           - ./nginx/:/etc/nginx/conf.d/\n           - ./webserver/static/jenkins/dist/:/usr/share/nginx/html/\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e执行 \u003ccode\u003edocker-compose up --build -d --remove-orphans\u003c/code\u003e 后, 此时应该会成功启动两个容器, 可以使用 \u003ccode\u003edocker container ls\u003c/code\u003e 查看:, 大致内容如下:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/docker-react-nest/example2.png\" alt=\"alt\"\u003e\u003c/p\u003e\n\u003cp\u003e此时在本地访问 \u003ccode\u003ehttp://ip(容器的宿主主机ip地址):8077\u003c/code\u003e 应该能够正常访问 jenkins 服务, 初始化界面应该如下:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/docker-react-nest/example3.png\" alt=\"alt\"\u003e\u003c/p\u003e\n\u003cp\u003e在宿主主机上执行 \u003ccode\u003edocker logs [container_id]\u003c/code\u003e, 从 log 信息从获取管理源密码, 然后进入插件安装页面, 这里安装推荐插件即可.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e插件安装完成且创建用户进入 jenkins 后点击 \u003cstrong\u003eManage Jenkins\u003c/strong\u003e, 然后再点击进入\u003cstrong\u003eManage Plugins\u003c/strong\u003e. 这里需要安装 \u003ccode\u003eNode\u003c/code\u003e 插件以及 \u003ccode\u003ePublish over SSH\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003e前者为构建流程提供 \u003ccode\u003eNodeJs\u003c/code\u003e 环境, 后者将构建完成后得到的前端产物压缩包上传至目标服务器.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/docker-react-nest/example4.png\" alt=\"alt\"\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e配置 \u003ccode\u003eNodeJs\u003c/code\u003e 环境. 点击 \u003cstrong\u003e系统管理\u003c/strong\u003e, 然后再点击进入\u003cstrong\u003e全局工具配置\u003c/strong\u003e, 找到 NodeJS, 点击 \u003cstrong\u003e新增NodeJS\u003c/strong\u003e. 最后根据项目的需求进行选择 \u003ccode\u003eNode\u003c/code\u003e 版本以及是否要安装全局工具即可.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/docker-react-nest/example5.png\" alt=\"alt\"\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e点击系统管理中的\u003cstrong\u003eCredentials\u003c/strong\u003e, 然后添加 github 的凭据. 可以添加 github 的 token、账号密码以及公私钥三种类型的凭据.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e配置 github-webhook. 点击系统管理中的\u003cstrong\u003e系统配置\u003c/strong\u003e, 找到 Github, 然后点击\u003cstrong\u003e添加Github\u003c/strong\u003e服务器, 在凭据一栏添加在上一步添加的 Github 凭据.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/docker-react-nest/example6.png\" alt=\"alt\"\u003e\u003c/p\u003e\n\u003cp\u003e找到最下方的更多按钮, 点击后会出现覆盖 Hook URL的选项, 将这里的地址绑定到 github 项目上的 webhook 即可.\n当然, 如果 jenkins 容器宿主主机为本地主机或者为内网主机, 可使用 \u003ca href=\"https://dashboard.ngrok.com/\"\u003engrok\u003c/a\u003e 实现内网穿透, 来保证 github 能访问到 jenkins.\u003c/p\u003e\n\u003cp\u003e注意事项:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003egithub-webhook地址前缀需与 jenkins 配置中的 \u003cstrong\u003eJenkins URL\u003c/strong\u003e 保持一致.\u003c/li\u003e\n\u003cli\u003e关于 \u003ca href=\"https://docs.github.com/en/webhooks-and-events/webhooks/about-webhooks\"\u003egithub webhook\u003c/a\u003e.\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e添加服务器信息. 在系统配置中找到\u003cstrong\u003ePublish over SSH\u003c/strong\u003e, 在 Passphrase 一栏填入服务器密码, 然后点击\u003cstrong\u003e新增\u003c/strong\u003e, 填入服务器信息.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/docker-react-nest/example7.png\" alt=\"alt\"\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e创建任务\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e点击新建任务, 输入任务名称后选择\u003cstrong\u003e构建一个自由风格的软件项目\u003c/strong\u003e\n\u003cimg src=\"/assets/docker-react-nest/example8.png\" alt=\"alt\"\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e源码管理里输入项目地址、添加 Github 凭据, 选择项目分支.\n\u003cimg src=\"/assets/docker-react-nest/example9.png\" alt=\"alt\"\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e构建触发器里选择 \u003cstrong\u003eGitHub hook trigger for GITScm polling\u003c/strong\u003e\n\u003cimg src=\"/assets/docker-react-nest/example10.png\" alt=\"alt\"\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e选择构建环境\n\u003cimg src=\"/assets/docker-react-nest/example11.png\" alt=\"alt\"\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e添加构建步骤. 这里可以将步骤放在 \u003ccode\u003eMakefile\u003c/code\u003e 文件中或者 \u003ccode\u003esh\u003c/code\u003e 脚本中, 这样每次更新步骤只需要更新配置文件, 而不用修改 jenkins 配置. 当然这一步也可以用 \u003ca href=\"https://www.jenkins.io/zh/doc/book/pipeline/jenkinsfile/\"\u003eJenkinsfile\u003c/a\u003e替代.\n\u003cimg src=\"/assets/docker-react-nest/example12.png\" alt=\"alt\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003ebuild.sh\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-sh\"\u003e pnpm fetch\n pnpm install -r --offline\n \n # frontend\n pnpm build:frontend\n cd ./packages/frontend\n tar zcf frontend.tar.gz ./dist\n mv ./frontend.tar.gz ../../frontend.tar.gz\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e添加构建后的操作. 这里选择 \u003cstrong\u003eSend build artifacts over SSH\u003c/strong\u003e, 填入以下内容:\n\u003cimg src=\"/assets/docker-react-nest/example13.png\" alt=\"alt\"\u003e\n其中 SSH Server Name 为上一步添加的服务器名称.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e到这里, 一个前端项目的自动化部署基本完成了. 在提交项目代码后, 便会自动触发任务, 进行项目构建, 并将构建后的产物上传至目标服务器. 然后将文件内容映射到 nginx 容器中.\u003c/p\u003e\n\u003cp\u003e关于 \u003ccode\u003eNestJs\u003c/code\u003e 服务的部署, 将构建开发环境中的 \u003ccode\u003edocker-compose.yml\u003c/code\u003e稍微进行改造即可, 内容如下:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-yml\"\u003eversion: '3.9'\nservices:\n  backend-prod:\n    container_name: backend-prod\n    user: root\n    build:\n      context: ./\n      dockerfile: ./packages/backend/Dockerfile.prod\n    image: webserver-backend-prod\n    restart: always\n    env_file: .env\n    networks:\n      bp-network:\n        ipv4_address: 172.25.0.2\n    ports:\n      - '${BACKEND_PORT}:3535'\n    depends_on:\n      - bp-pg-db-prod\n    command: [sh, -c, \"cd packages/backend \u0026#x26;\u0026#x26; pnpm migrate:postgres \u0026#x26;\u0026#x26; pnpm prisma:gen \u0026#x26;\u0026#x26; pnpm build \u0026#x26;\u0026#x26; pnpm start:prod\"]\n  bp-pg-db-prod:\n    image: postgres:12-alpine\n    restart: always\n    container_name: bp-pg-db-prod\n    env_file:\n      - .env\n    environment:\n      POSTGRES_PASSWORD: ${DB_PASSWORD}\n      PGDATA: /var/lib/postgresql/data\n      POSTGRES_USER: ${DB_USER}\n      POSTGRES_DB: ${DB_NAME}\n    ports:\n      - '${DB_PORT}:${DB_PORT}'\n    volumes:\n      - pgdata:/var/lib/postgresql/data\n    networks:\n      bp-network:\n        ipv4_address: 172.25.0.5\n  pgadmin-portal-prod:\n    image: dpage/pgadmin4\n    restart: always\n    container_name: pgadmin-portal-prod\n    env_file:\n      - .env\n    environment:\n      PGADMIN_DEFAULT_PASSWORD: '${PGADMIN_DEFAULT_PASSWORD}'\n      PGADMIN_DEFAULT_EMAIL: '${PGADMIN_DEFAULT_EMAIL}'\n    volumes:\n      - pgadmin:/root/.pgadmin\n    ports:\n      - '${PGADMIN_PORT}:80'\n    depends_on:\n      - bp-pg-db-prod\n    networks:\n      bp-network:\n        ipv4_address: 172.25.0.6\nvolumes:\n  pgdata:\n  pgadmin:\nnetworks:\n  bp-network:\n    driver: bridge\n    ipam:\n      config:\n        - subnet: 172.25.0.0/16\n\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eDockerfile.prod:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-dockerfile\"\u003eFROM node:16.16.0-alpine\n\n\nWORKDIR /app\n\nCOPY ./pnpm-lock.yaml ./\n\nRUN npm install -g pnpm@8.3.1\n\nRUN pnpm fetch\n\nCOPY . .\n\nRUN pnpm install -r --offline\n\nVOLUME [\"/app/node_modules/\", \"/app/packages/backend/node_modules/\", \"/app/.pnpm-store/\"]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e由于本文所构建项目为一个 Monorepo, 所以在提交前端代码时同时会触发后端项目的构建, 所以我们仅需将以下内容添加至前端构建流程中的 \u003ccode\u003e./scripts/build.sh\u003c/code\u003e即可:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-sh\"\u003edocker-compose -f docker-compose.server.yaml stop \u0026#x26;\u0026#x26; docker-compose -f docker-compose.server.yaml up --build -d --remove-orphans\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e注意事项:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e需要移除 docker-compose 中后端服务的 volume. 由于jenkins在构建完成后会清空工作区, 所以这里不需要同构建开发环境一样进行文件映射.\u003c/li\u003e\n\u003cli\u003eNestJS 项目中开发环境以及生产环境中环境变量的区分.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e最后, 构建完成后, 宿主主机上容器列表如下:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/docker-react-nest/example14.png\" alt=\"alt\"\u003e\u003c/p\u003e\n\u003cp\u003e通过 http:[ip]:7878 即可正常访问后端服务, http:[ip]:5055 可访问 pgadmin.\u003c/p\u003e\n\u003cp\u003e项目地址: \u003ca href=\"https://github.com/LZS911/todo-react-nest-docker\"\u003ehttps://github.com/LZS911/todo-react-nest-docker\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003ejenkins+nginx容器构建: \u003ca href=\"https://github.com/LZS911/jenkins-nginx-docker\"\u003ehttps://github.com/LZS911/jenkins-nginx-docker\u003c/a\u003e\u003c/p\u003e","theme":"orange","tag":["Docker","Docker Compose","React","Nest","Monorepo","Pnpm","Nginx","Jenkins","PostgreSQL"]}},"__N_SSG":true},"page":"/posts/[slug]","query":{"slug":"Docker化一个React+Nest的Monorepo应用"},"buildId":"xlPHhR-wYr_8CmIOtMS6f","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>