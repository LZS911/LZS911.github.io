1:"$Sreact.fragment"
2:I[996,["874","static/chunks/874-0197bf8342d89979.js","766","static/chunks/766-28cafc2b8349fbd8.js","177","static/chunks/app/layout-bb1da1aafb2c343b.js"],"default"]
3:I[7555,[],""]
4:I[1901,["874","static/chunks/874-0197bf8342d89979.js","39","static/chunks/app/error-d036ecfd03716e30.js"],"default"]
5:I[1295,[],""]
6:I[9543,["874","static/chunks/874-0197bf8342d89979.js","345","static/chunks/app/not-found-2113bbd7a2f55e8f.js"],"default"]
8:I[9665,[],"MetadataBoundary"]
a:I[9665,[],"OutletBoundary"]
d:I[4911,[],"AsyncMetadataOutlet"]
f:I[8460,["209","static/chunks/app/loading-b73dd9bd22c3caa2.js"],"default"]
10:I[9665,[],"ViewportBoundary"]
12:I[6614,[],""]
:HL["/_next/static/media/569ce4b8f30dc480-s.p.woff2","font",{"crossOrigin":"","type":"font/woff2"}]
:HL["/_next/static/media/93f479601ee12b01-s.p.woff2","font",{"crossOrigin":"","type":"font/woff2"}]
:HL["/_next/static/css/e948a5c1bf791e9e.css","style"]
:HL["/_next/static/css/36a97ca7ae61047e.css","style"]
:HL["/_next/static/css/cb28a8db79c7a247.css","style"]
:HL["/_next/static/css/90e48aee015d076a.css","style"]
0:{"P":null,"b":"zqV1dHPRggiwu9nwtjnlM","p":"","c":["","posts","Node.js-Stream%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95"],"i":false,"f":[[["",{"children":["posts",{"children":[["slug","Node.js-Stream%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95","d"],{"children":["__PAGE__",{}]}]}]},"$undefined","$undefined",true],["",["$","$1","c",{"children":[[["$","link","0",{"rel":"stylesheet","href":"/_next/static/css/e948a5c1bf791e9e.css","precedence":"next","crossOrigin":"$undefined","nonce":"$undefined"}]],["$","html",null,{"lang":"en","children":["$","body",null,{"className":"__variable_4d318d __variable_ea5f4b antialiased","children":["$","div",null,{"className":"min-h-screen","children":[["$","$L2",null,{}],["$","main",null,{"className":"p-6 flex justify-center","children":["$","$L3",null,{"parallelRouterKey":"children","error":"$4","errorStyles":[],"errorScripts":[],"template":["$","$L5",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":[["$","$L6",null,{}],[]],"forbidden":"$undefined","unauthorized":"$undefined"}]}],["$","footer",null,{"className":"bg-neutral-50 border-t border-neutral-200 text-center text-xs opacity-50 py-4","children":["© 2022 - ",2025,["$","a",null,{"rel":"noopener noreferrer","className":"hover:underline hover:bg-indigo","href":"https://github.com/LZS911","target":"_blank","children":", LZS_911"}],", build with"," ",["$","a",null,{"rel":"noopener noreferrer","className":"underline hover:bg-indigo","href":"https://nextjs.org/","target":"_blank","children":"Next.js"}]," ","and"," ",["$","a",null,{"rel":"noopener noreferrer","className":"underline hover:bg-indigo","href":"https://pages.github.com/?(null)","target":"_blank","children":"GitHub Pages"}]]}]]}]}]}]]}],{"children":["posts",["$","$1","c",{"children":[null,["$","$L3",null,{"parallelRouterKey":"children","error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L5",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","forbidden":"$undefined","unauthorized":"$undefined"}]]}],{"children":[["slug","Node.js-Stream%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95","d"],["$","$1","c",{"children":[null,["$","$L3",null,{"parallelRouterKey":"children","error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L5",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","forbidden":"$undefined","unauthorized":"$undefined"}]]}],{"children":["__PAGE__",["$","$1","c",{"children":["$L7",["$","$L8",null,{"children":"$L9"}],[["$","link","0",{"rel":"stylesheet","href":"/_next/static/css/36a97ca7ae61047e.css","precedence":"next","crossOrigin":"$undefined","nonce":"$undefined"}],["$","link","1",{"rel":"stylesheet","href":"/_next/static/css/cb28a8db79c7a247.css","precedence":"next","crossOrigin":"$undefined","nonce":"$undefined"}],["$","link","2",{"rel":"stylesheet","href":"/_next/static/css/90e48aee015d076a.css","precedence":"next","crossOrigin":"$undefined","nonce":"$undefined"}]],["$","$La",null,{"children":["$Lb","$Lc",["$","$Ld",null,{"promise":"$@e"}]]}]]}],{},null,false]},null,false]},null,false]},[["$","$Lf","l",{}],[],[]],false],["$","$1","h",{"children":[null,["$","$1","_28q4_a4pnxLB9-od2dUD",{"children":[["$","$L10",null,{"children":"$L11"}],["$","meta",null,{"name":"next-size-adjust","content":""}]]}],null]}],false]],"m":"$undefined","G":["$12","$undefined"],"s":false,"S":true}
13:"$Sreact.suspense"
14:I[4911,[],"AsyncMetadata"]
9:["$","$13",null,{"fallback":null,"children":["$","$L14",null,{"promise":"$@15"}]}]
c:null
16:T52a9,<h2 id="什么是-stream流"><a aria-hidden="true" tabindex="-1" href="#什么是-stream流"><span class="icon icon-link"></span></a>什么是 Stream（流）</h2>
<p>先看一下 Node 官网中对于 Stream 的介绍</p>
<blockquote>
<p>A stream is an abstract interface for working with streaming data in Node.js.</p>
</blockquote>
<p>其实我们写的 Node.js 代码经常会用到流。</p>
<p>来看一段代码</p>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// src/test.mjs</span>
<span class="hljs-keyword">import</span> http <span class="hljs-keyword">from</span> <span class="hljs-string">'node:http'</span>;
<span class="hljs-keyword">import</span> fs <span class="hljs-keyword">from</span> <span class="hljs-string">'node:fs'</span>;
<span class="hljs-keyword">import</span> path <span class="hljs-keyword">from</span> <span class="hljs-string">'node:path'</span>;

<span class="hljs-keyword">const</span> server = http.<span class="hljs-title function_">createServer</span>(<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">req, res</span>) {
  <span class="hljs-keyword">const</span> data = fs.<span class="hljs-title function_">readFileSync</span>(
    path.<span class="hljs-title function_">join</span>(<span class="hljs-keyword">import</span>.<span class="hljs-property">meta</span>.<span class="hljs-property">dirname</span>, <span class="hljs-string">'..'</span>, <span class="hljs-string">'package.json'</span>),
    <span class="hljs-string">'utf-8'</span>
  );
  res.<span class="hljs-title function_">end</span>(data);
});

server.<span class="hljs-title function_">listen</span>(<span class="hljs-number">8000</span>);
</code></pre>
<p>我们跑了个 http 服务。</p>
<p>用 fs.readFileSync 读取项目中 package.json 的内容返回。</p>
<p>启动服务后使用 curl 访问下</p>
<pre><code class="hljs language-shell">curl -i http://localhost:8000
</code></pre>
<p><img src="https://github.com/user-attachments/assets/775ccae6-26e8-4149-abbe-8244ce84b035" alt="image"></p>
<p>因为是全部读完返回的，所以可以知道 Content-Length，也就是响应体的长度。</p>
<p>当文件比较小的时候，这样读取、返回没啥问题。</p>
<p>那如果文件非常大呢？</p>
<p>比如有好几百 M，这时候全部读取完再返回是不是就合适了？</p>
<p>因为要等好久才能读取完文件，之后才有响应。</p>
<p>这就需要用到流了：</p>
<pre><code class="hljs language-typescript"><span class="hljs-comment">//更新 src/test.mjs</span>
<span class="hljs-keyword">import</span> http <span class="hljs-keyword">from</span> <span class="hljs-string">'node:http'</span>;
<span class="hljs-keyword">import</span> fs <span class="hljs-keyword">from</span> <span class="hljs-string">'node:fs'</span>;
<span class="hljs-keyword">import</span> path <span class="hljs-keyword">from</span> <span class="hljs-string">'node:path'</span>;

<span class="hljs-keyword">const</span> server = http.<span class="hljs-title function_">createServer</span>(<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">req, res</span>) {
  <span class="hljs-keyword">const</span> readStream = fs.<span class="hljs-title function_">createReadStream</span>(
    path.<span class="hljs-title function_">join</span>(<span class="hljs-keyword">import</span>.<span class="hljs-property">meta</span>.<span class="hljs-property">dirname</span>, <span class="hljs-string">'..'</span>, <span class="hljs-string">'package.json'</span>),
    <span class="hljs-string">'utf-8'</span>
  );
  readStream.<span class="hljs-title function_">pipe</span>(res);
});

server.<span class="hljs-title function_">listen</span>(<span class="hljs-number">8000</span>);
</code></pre>
<p><img src="https://github.com/user-attachments/assets/7d9096be-3d6b-4640-ac7d-09a3700b32b2" alt="image"></p>
<p>结果一样，但是因为现在是流式返回的，并不知道响应体的 Content-Length。</p>
<p>所以是用 Transfer-Encoding: chunked 的方式返回流式内容。</p>
<p>从服务器下载一个文件的时候，如何知道文件下载完了呢？</p>
<p>有两种方式：</p>
<p>一种是 header 里带上 Content-Length，浏览器下载到这个长度就结束。</p>
<p><img src="https://github.com/user-attachments/assets/05f39e48-2f39-4fdd-9c51-2a1f4736991e" alt="image"></p>
<p>另一种是设置 transfer-encoding:chunked，它是不固定长度的，服务器不断返回内容，直到返回一个空的内容代表结束。</p>
<p>比如这样：</p>
<pre><code class="hljs language-shell">5
Hello
1
,
5
World
1
!
0
</code></pre>
<p>这里分了 “Hello” “,” “World”“!” 这 4 个块，长度分别为 5、1、5、1</p>
<p>最后以一个长度为 0 的块代表传输结束。</p>
<p>这样，不管内容多少都可以分块返回，就不用指定 Content-Length 了。</p>
<p>这就是大文件的流式传输的原理，就是 transfer-encoding:chunked。</p>
<p>当然，这是 http 传输时的流，在用 shell 命令的时候，也经常会用到流：</p>
<p>比如</p>
<pre><code class="hljs language-shell">ls | grep pack
</code></pre>
<p><img src="https://github.com/user-attachments/assets/e7d69e47-5a8a-4717-b3e7-7251d5924dc6" alt="image"></p>
<p>ls 命令的输出流，作为 grep 命令的输入流。</p>
<p>当然，我们也可以把 grep 命令的输出流，作为 node 脚本的输入流。</p>
<pre><code class="hljs language-javascript"><span class="hljs-comment">//src/read.mjs</span>
process.<span class="hljs-property">stdin</span>.<span class="hljs-title function_">on</span>(<span class="hljs-string">'readable'</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
    <span class="hljs-keyword">const</span> buf = process.<span class="hljs-property">stdin</span>.<span class="hljs-title function_">read</span>();
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(buf?.<span class="hljs-title function_">toString</span>(<span class="hljs-string">'utf-8'</span>));
});
</code></pre>
<p>process.stdin 就是输入流，监听 readable 事件，用 read 读取数据。</p>
<p>执行一下</p>
<pre><code class="hljs language-shell">ls | grep pack | node src/read.mjs
</code></pre>
<p><img src="https://github.com/user-attachments/assets/e51ce88c-f842-4e5c-8758-4d203085a0ac" alt="image"></p>
<p>可以看到，我们的 node 脚本接收到了 grep 的输出流作为输入流。</p>
<p>这就是管道 pipe 的含义。</p>
<p>综上，可以小结下我们对流的认识：</p>
<p><strong>流就是分段的传输内容，比如从服务端像浏览器返回响应数据的流，读取文件的流等。</strong></p>
<p><strong>流和流之间可以通过管道 pipe 连接，上个流的输出作为下个流的输入。</strong></p>
<h2 id="流的类型"><a aria-hidden="true" tabindex="-1" href="#流的类型"><span class="icon icon-link"></span></a>流的类型</h2>
<p>在 node 里，流一共有 4 种：可读流 Readable、可写流 Writable、双工流 Duplex、转换流 Transform。</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">import</span> stream <span class="hljs-keyword">from</span> <span class="hljs-string">'node:stream'</span>;

<span class="hljs-comment">// 可读流</span>
<span class="hljs-keyword">const</span> <span class="hljs-title class_">Readable</span> = stream.<span class="hljs-property">Readable</span>;
<span class="hljs-comment">// 可写流</span>
<span class="hljs-keyword">const</span> <span class="hljs-title class_">Writable</span> = stream.<span class="hljs-property">Writable</span>;
<span class="hljs-comment">// 双工流</span>
<span class="hljs-keyword">const</span> <span class="hljs-title class_">Duplex</span> = stream.<span class="hljs-property">Duplex</span>;
<span class="hljs-comment">// 转换流</span>
<span class="hljs-keyword">const</span> <span class="hljs-title class_">Transform</span> = stream.<span class="hljs-property">Transform</span>;
</code></pre>
<p>其余的流都是基于这 4 种流封装出来的。</p>
<h3 id="readable"><a aria-hidden="true" tabindex="-1" href="#readable"><span class="icon icon-link"></span></a>Readable</h3>
<p>Readable 要实现 _read 方法，通过 push 返回具体的数据。</p>
<pre><code class="hljs language-javascript"><span class="hljs-comment">//readable.mjs</span>
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">Readable</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'node:stream'</span>;

<span class="hljs-keyword">const</span> readableStream = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Readable</span>();

readableStream.<span class="hljs-property">_read</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">push</span>(<span class="hljs-string">'阿门阿前一棵葡萄树，'</span>);
    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">push</span>(<span class="hljs-string">'阿东阿东绿的刚发芽，'</span>);
    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">push</span>(<span class="hljs-string">'阿东背着那重重的的壳呀，'</span>);
    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">push</span>(<span class="hljs-string">'一步一步地往上爬。'</span>)
    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">push</span>(<span class="hljs-literal">null</span>);
}

readableStream.<span class="hljs-title function_">on</span>(<span class="hljs-string">'data'</span>, <span class="hljs-function">(<span class="hljs-params">data</span>)=></span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data.<span class="hljs-title function_">toString</span>())
});

readableStream.<span class="hljs-title function_">on</span>(<span class="hljs-string">'end'</span>, <span class="hljs-function">() =></span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'done'</span>);
});
</code></pre>
<p>当 push 一个 null 时，就代表结束流。</p>
<p>执行一下</p>
<pre><code class="hljs language-shell">node src/readable.mjs
</code></pre>
<p><img src="https://github.com/user-attachments/assets/184fe685-1a0b-4a88-b846-c4ebe37a705c" alt="image"></p>
<p>创建 Readable 流也可以通过继承的方式：</p>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// src/readable2.mjs</span>
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">Readable</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'node:stream'</span>;

<span class="hljs-keyword">class</span> <span class="hljs-title class_">ReadableDong</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Readable</span> {

    <span class="hljs-title function_">_read</span>(<span class="hljs-params"></span>) {
        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">push</span>(<span class="hljs-string">'阿门阿前一棵葡萄树，'</span>);
        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">push</span>(<span class="hljs-string">'阿东阿东绿的刚发芽，'</span>);
        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">push</span>(<span class="hljs-string">'阿东背着那重重的的壳呀，'</span>);
        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">push</span>(<span class="hljs-string">'一步一步地往上爬。'</span>)
        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">push</span>(<span class="hljs-literal">null</span>);
    }

}

<span class="hljs-keyword">const</span> readableStream = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReadableDong</span>();

readableStream.<span class="hljs-title function_">on</span>(<span class="hljs-string">'data'</span>, <span class="hljs-function">(<span class="hljs-params">data</span>)=></span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data.<span class="hljs-title function_">toString</span>())
});

readableStream.<span class="hljs-title function_">on</span>(<span class="hljs-string">'end'</span>, <span class="hljs-function">() =></span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'done'</span>);
});

</code></pre>
<p><img src="https://github.com/user-attachments/assets/267137eb-e992-4c71-9bd3-3325e05a74a7" alt="image"></p>
<p>可读流是生成内容的，那么很自然可以和生成器结合：</p>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// src/readable3.mjs</span>

<span class="hljs-keyword">import</span> { <span class="hljs-title class_">Readable</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'node:stream'</span>;

<span class="hljs-keyword">class</span> <span class="hljs-title class_">ReadableDong</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Readable</span> {

    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">iterator</span>) {
        <span class="hljs-variable language_">super</span>();
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">iterator</span> = iterator;
    }

    <span class="hljs-title function_">_read</span>(<span class="hljs-params"></span>) {
        <span class="hljs-keyword">const</span> next = <span class="hljs-variable language_">this</span>.<span class="hljs-property">iterator</span>.<span class="hljs-title function_">next</span>();
        <span class="hljs-keyword">if</span>(next.<span class="hljs-property">done</span>) {
            <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">push</span>(<span class="hljs-literal">null</span>);
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">push</span>(next.<span class="hljs-property">value</span>)
        }
    }

}

<span class="hljs-keyword">function</span> *<span class="hljs-title function_">songGenerator</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">yield</span> <span class="hljs-string">'阿门阿前一棵葡萄树，'</span>;
    <span class="hljs-keyword">yield</span> <span class="hljs-string">'阿东阿东绿的刚发芽，'</span>;
    <span class="hljs-keyword">yield</span> <span class="hljs-string">'阿东背着那重重的的壳呀，'</span>;
    <span class="hljs-keyword">yield</span> <span class="hljs-string">'一步一步地往上爬。'</span>;
}

<span class="hljs-keyword">const</span> songIterator = <span class="hljs-title function_">songGenerator</span>();

<span class="hljs-keyword">const</span> readableStream = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReadableDong</span>(songIterator);

readableStream.<span class="hljs-title function_">on</span>(<span class="hljs-string">'data'</span>, <span class="hljs-function">(<span class="hljs-params">data</span>)=></span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data.<span class="hljs-title function_">toString</span>())
});

readableStream.<span class="hljs-title function_">on</span>(<span class="hljs-string">'end'</span>, <span class="hljs-function">() =></span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'done'</span>);
});
</code></pre>
<ul>
<li>和 yield 是 js 的 generator 的语法，它是异步返回 yield 后的内容，通过 iterator 的 next 来取下一个。</li>
</ul>
<p><img src="https://github.com/user-attachments/assets/c2290823-cc7b-45b7-b2d6-cbcd5febfaaf" alt="image"></p>
<p>我们封装个工厂方法：</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">createReadStream</span>(<span class="hljs-params">iterator</span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReadableDong</span>(iterator);
}

<span class="hljs-keyword">const</span> readableStream = <span class="hljs-title function_">createReadStream</span>(songIterator);

readableStream.<span class="hljs-title function_">on</span>(<span class="hljs-string">'data'</span>, <span class="hljs-function">(<span class="hljs-params">data</span>) =></span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data.<span class="hljs-title function_">toString</span>());
});

readableStream.<span class="hljs-title function_">on</span>(<span class="hljs-string">'end'</span>, <span class="hljs-function">() =></span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'done'</span>);
});
</code></pre>
<p>是不是就和 fs.createReadStream 很像了？</p>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// 创建 src/fsReadStream.mjs</span>
<span class="hljs-keyword">import</span> fs <span class="hljs-keyword">from</span> <span class="hljs-string">'node:fs'</span>;
<span class="hljs-keyword">import</span> path <span class="hljs-keyword">from</span> <span class="hljs-string">'node:path'</span>;

<span class="hljs-keyword">const</span> readStream = fs.<span class="hljs-title function_">createReadStream</span>(
  path.<span class="hljs-title function_">join</span>(<span class="hljs-keyword">import</span>.<span class="hljs-property">meta</span>.<span class="hljs-property">dirname</span>, <span class="hljs-string">'..'</span>, <span class="hljs-string">'package.json'</span>),
  <span class="hljs-string">'utf-8'</span>
);

readStream.<span class="hljs-title function_">on</span>(<span class="hljs-string">'data'</span>, <span class="hljs-function">(<span class="hljs-params">data</span>) =></span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data.<span class="hljs-title function_">toString</span>());
});

readStream.<span class="hljs-title function_">on</span>(<span class="hljs-string">'end'</span>, <span class="hljs-function">() =></span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'done'</span>);
});
</code></pre>
<p><img src="https://github.com/user-attachments/assets/1e7bb2ed-6be6-479f-a4fe-f3318766f17d" alt="image"></p>
<p>其实文件的 ReadStream 就是基于 stream 的 Readable 封装出来的。</p>
<p>这就是可读流。</p>
<p>http 服务的 request 就是 Readable 的实例：</p>
<p><img src="https://github.com/user-attachments/assets/bca3ed3c-fd44-4ff4-974e-7e5830ae21b7" alt="image"></p>
<p>所以我们可以这样写：</p>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// src/test2.mjs</span>
<span class="hljs-keyword">import</span> http <span class="hljs-keyword">from</span> <span class="hljs-string">'node:http'</span>;
<span class="hljs-keyword">import</span> fs <span class="hljs-keyword">from</span> <span class="hljs-string">'node:fs'</span>;

<span class="hljs-keyword">const</span> server = http.<span class="hljs-title function_">createServer</span>(<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">req, res</span>) {
    <span class="hljs-keyword">const</span> writeStream = fs.<span class="hljs-title function_">createWriteStream</span>(<span class="hljs-string">'aaa.txt'</span>, <span class="hljs-string">'utf-8'</span>);
    req.<span class="hljs-title function_">pipe</span>(writeStream);
    res.<span class="hljs-title function_">end</span>(<span class="hljs-string">'done'</span>);
});

server.<span class="hljs-title function_">listen</span>(<span class="hljs-number">8000</span>);
</code></pre>
<p>启动服务后访问一下</p>
<pre><code>curl -X POST -d "a=1&#x26;b=2" http://localhost:8000
</code></pre>
<p><img src="https://github.com/user-attachments/assets/df08f683-77d2-4252-84fe-742c42d5c230" alt="image"></p>
<p>可以看到，从 request 的流中读出的内容写入了文件的 WriteStream</p>
<h3 id="writable"><a aria-hidden="true" tabindex="-1" href="#writable"><span class="icon icon-link"></span></a>Writable</h3>7:["$","article",null,{"children":[["$","div",null,{"className":"flex justify-center font-[Arial] max-w-[864px] text-center","children":["$","h1",null,{"className":"text-[2.5rem] font-bold bg-lime-300 px-5 py-2 rounded-sm text-shadow-lg leading-[1.1]","children":"Node.js-Stream学习记录"}]}],["$","time",null,{"dateTime":"2024-12-20","className":"text-center block my-4 text-sm opacity-60","children":"December\t20, 2024"}],[null,["$","section",null,{"className":"markdown-body-fancy max-w-3xl","dangerouslySetInnerHTML":{"__html":"$16"}}]],null]}]
11:[["$","meta","0",{"charSet":"utf-8"}],["$","meta","1",{"name":"viewport","content":"width=device-width, initial-scale=1"}]]
b:null
15:{"metadata":[["$","title","0",{"children":"Ai.Haibara codes"}],["$","meta","1",{"name":"description","content":"LZS Blog"}],["$","link","2",{"rel":"icon","href":"/favicon.ico","type":"image/x-icon","sizes":"96x96"}]],"error":null,"digest":"$undefined"}
e:{"metadata":"$15:metadata","error":null,"digest":"$undefined"}
