1:"$Sreact.fragment"
2:I[7555,[],""]
3:I[1901,["874","static/chunks/874-90f68e0a3827b559.js","39","static/chunks/app/error-d036ecfd03716e30.js"],"default"]
4:I[1295,[],""]
5:I[9543,["874","static/chunks/874-90f68e0a3827b559.js","345","static/chunks/app/not-found-2113bbd7a2f55e8f.js"],"default"]
8:I[9665,[],"MetadataBoundary"]
a:I[9665,[],"OutletBoundary"]
d:I[4911,[],"AsyncMetadataOutlet"]
f:I[8460,["209","static/chunks/app/loading-b73dd9bd22c3caa2.js"],"default"]
10:I[9665,[],"ViewportBoundary"]
12:I[6614,[],""]
:HL["/_next/static/media/569ce4b8f30dc480-s.p.woff2","font",{"crossOrigin":"","type":"font/woff2"}]
:HL["/_next/static/media/93f479601ee12b01-s.p.woff2","font",{"crossOrigin":"","type":"font/woff2"}]
:HL["/_next/static/css/60adccb42f39203c.css","style"]
:HL["/_next/static/css/c7f6e508dc13ee25.css","style"]
0:{"P":null,"b":"fPyRDf3jU8EaKreMEXeMB","p":"","c":["","posts","53a32daf66dcb375c89529bd"],"i":false,"f":[[["",{"children":["(article)",{"children":["posts",{"children":[["slug","53a32daf66dcb375c89529bd","d"],{"children":["__PAGE__",{}]}]}]}]},"$undefined","$undefined",true],["",["$","$1","c",{"children":[[["$","link","0",{"rel":"stylesheet","href":"/_next/static/css/60adccb42f39203c.css","precedence":"next","crossOrigin":"$undefined","nonce":"$undefined"}]],["$","html",null,{"lang":"en","children":["$","body",null,{"className":"__variable_5cfdac __variable_9a8899 antialiased","children":["$","$L2",null,{"parallelRouterKey":"children","error":"$3","errorStyles":[],"errorScripts":[],"template":["$","$L4",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":[["$","$L5",null,{}],[]],"forbidden":"$undefined","unauthorized":"$undefined"}]}]}]]}],{"children":["(article)",["$","$1","c",{"children":[[["$","link","0",{"rel":"stylesheet","href":"/_next/static/css/c7f6e508dc13ee25.css","precedence":"next","crossOrigin":"$undefined","nonce":"$undefined"}]],"$L6"]}],{"children":["posts",["$","$1","c",{"children":[null,["$","$L2",null,{"parallelRouterKey":"children","error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L4",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","forbidden":"$undefined","unauthorized":"$undefined"}]]}],{"children":[["slug","53a32daf66dcb375c89529bd","d"],["$","$1","c",{"children":[null,["$","$L2",null,{"parallelRouterKey":"children","error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L4",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","forbidden":"$undefined","unauthorized":"$undefined"}]]}],{"children":["__PAGE__",["$","$1","c",{"children":["$L7",["$","$L8",null,{"children":"$L9"}],null,["$","$La",null,{"children":["$Lb","$Lc",["$","$Ld",null,{"promise":"$@e"}]]}]]}],{},null,false]},null,false]},null,false]},null,false]},[["$","$Lf","l",{}],[],[]],false],["$","$1","h",{"children":[null,["$","$1","R-a8gY79Ot_sEOx9iKOLQ",{"children":[["$","$L10",null,{"children":"$L11"}],["$","meta",null,{"name":"next-size-adjust","content":""}]]}],null]}],false]],"m":"$undefined","G":["$12","$undefined"],"s":false,"S":true}
13:I[2034,["874","static/chunks/874-90f68e0a3827b559.js","296","static/chunks/296-93bf38127a29d878.js","766","static/chunks/766-3404ce8492c1c2aa.js","846","static/chunks/846-5073d6248f7e4d01.js","651","static/chunks/app/(article)/layout-0113e097a12c4d28.js"],"default"]
14:"$Sreact.suspense"
15:I[4911,[],"AsyncMetadata"]
6:["$","html",null,{"lang":"en","children":["$","body",null,{"className":"__variable_5cfdac __variable_9a8899 antialiased","children":[["$","div",null,{"className":"min-h-screen","children":[["$","$L13",null,{}],["$","main",null,{"className":"p-6 flex justify-center","children":["$","$L2",null,{"parallelRouterKey":"children","error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L4",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","forbidden":"$undefined","unauthorized":"$undefined"}]}],["$","footer",null,{"className":"bg-neutral-50 border-t border-neutral-200 text-center text-xs opacity-50 py-4","children":["© 2022 - ",2025,["$","a",null,{"rel":"noopener noreferrer","className":"hover:underline hover:bg-indigo","href":"https://github.com/LZS911","target":"_blank","children":", LZS_911"}],", build with"," ",["$","a",null,{"rel":"noopener noreferrer","className":"underline hover:bg-indigo","href":"https://nextjs.org/","target":"_blank","children":"Next.js"}]," ","and"," ",["$","a",null,{"rel":"noopener noreferrer","className":"underline hover:bg-indigo","href":"https://vercel.com/","target":"_blank","children":"Vercel"}]]}]]}],false]}]}]
9:["$","$14",null,{"fallback":null,"children":["$","$L15",null,{"promise":"$@16"}]}]
c:null
17:I[5099,["874","static/chunks/874-90f68e0a3827b559.js","296","static/chunks/296-93bf38127a29d878.js","766","static/chunks/766-3404ce8492c1c2aa.js","520","static/chunks/app/(article)/posts/%5Bslug%5D/page-15870e626cfa21a8.js"],"ThemeLoader"]
18:T6bdd,<h2 id="前言"><a aria-hidden="true" tabindex="-1" href="#前言"><span class="icon icon-link"></span></a>前言</h2>
<p>作为一名长期使用 Vite 进行前端开发的工程师，当看到官方发布 rolldown-vite 的消息时，我对这个基于 Rust 的新构建工具产生了浓厚的兴趣。</p>
<p>本文将记录我在实际项目中使用 rolldown-vite 的体验过程，包括迁移步骤、性能对比、新特性分析以及使用建议。</p>
<h2 id="rolldown-概述"><a aria-hidden="true" tabindex="-1" href="#rolldown-概述"><span class="icon icon-link"></span></a>Rolldown 概述</h2>
<h3 id="技术背景"><a aria-hidden="true" tabindex="-1" href="#技术背景"><span class="icon icon-link"></span></a>技术背景</h3>
<p>Rolldown 是一个用 Rust 编写的现代化 JavaScript 打包工具，定位为 Rollup 的高性能替代方案。在当前前端工具链普遍向 Rust 迁移的趋势下（如 swc、esbuild、turbo），Vite 团队也选择了这条技术路线。</p>
<p>Rolldown 的核心目标是在保持与现有生态系统完全兼容的前提下，通过 Rust 的性能优势实现显著的构建速度提升。</p>
<h3 id="架构优势分析"><a aria-hidden="true" tabindex="-1" href="#架构优势分析"><span class="icon icon-link"></span></a>架构优势分析</h3>
<p>相比传统方案，Rolldown 带来了三个主要改进：</p>
<p><strong>1. 工具链统一</strong></p>
<p>传统 Vite 架构存在二元化问题：</p>
<ul>
<li>开发环境：esbuild 负责依赖预打包</li>
<li>生产环境：Rollup 负责最终构建</li>
</ul>
<p>这种架构分离偶尔会导致开发与生产环境的行为不一致。Rolldown 通过统一的构建引擎解决了这一问题。</p>
<p><strong>2. 性能优化</strong></p>
<p>Rust 的系统级性能优势在 I/O 密集型的构建任务中表现尤为明显。虽然具体提升程度因项目规模而异，但理论上应该有显著的性能收益。</p>
<h2 id="迁移实践"><a aria-hidden="true" tabindex="-1" href="#迁移实践"><span class="icon icon-link"></span></a>迁移实践</h2>
<h3 id="迁移流程"><a aria-hidden="true" tabindex="-1" href="#迁移流程"><span class="icon icon-link"></span></a>迁移流程</h3>
<p>迁移过程相对简单，主要通过 npm 别名机制实现：</p>
<pre><code class="hljs language-json"><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"dependencies"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
    <span class="hljs-attr">"vite"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"npm:rolldown-vite@latest"</span>
  <span class="hljs-punctuation">}</span>
<span class="hljs-punctuation">}</span>
</code></pre>
<p>完成依赖更新后，重新执行 <code>npm install</code> 即可。需要注意的是，首次安装可能需要较长时间，建议使用稳定的网络环境或配置国内镜像源。</p>
<h3 id="性能测试结果"><a aria-hidden="true" tabindex="-1" href="#性能测试结果"><span class="icon icon-link"></span></a>性能测试结果</h3>
<p>我在一个包含约 200+ 组件的中型 React 项目上进行了构建性能对比：</p>
<p><strong>原版 Vite 构建时间：</strong>
<img src="/assets/blog/posts/image-1749636229985-8a74u9y.png" alt="图片"></p>
<p><strong>Rolldown-Vite 构建时间：</strong>
<img src="/assets/blog/posts/image-1749636117701-v9ijxti.png" alt="图片"></p>
<p>从测试结果来看，在构建项目产物场景下确实能观察到性能提升。</p>
<h2 id="核心特性变化"><a aria-hidden="true" tabindex="-1" href="#核心特性变化"><span class="icon icon-link"></span></a>核心特性变化</h2>
<h3 id="分块策略调整"><a aria-hidden="true" tabindex="-1" href="#分块策略调整"><span class="icon icon-link"></span></a>分块策略调整</h3>
<p>Rolldown 最显著的变化是将 <code>manualChunks</code> 替换为 <code>advancedChunks</code>，这是一个更具表达力的分块配置系统：</p>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// 传统 Rollup 配置</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
  <span class="hljs-attr">build</span>: {
    <span class="hljs-attr">rollupOptions</span>: {
      <span class="hljs-attr">output</span>: {
        <span class="hljs-title function_">manualChunks</span>(<span class="hljs-params">id</span>) {
          <span class="hljs-keyword">if</span> (<span class="hljs-regexp">/\/react(?:-dom)?/</span>.<span class="hljs-title function_">test</span>(id)) {
            <span class="hljs-keyword">return</span> <span class="hljs-string">'vendor'</span>
          }
        }
      }
    }
  }
}

<span class="hljs-comment">// Rolldown 新配置</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
  <span class="hljs-attr">build</span>: {
    <span class="hljs-attr">rollupOptions</span>: {
      <span class="hljs-attr">output</span>: {
        <span class="hljs-attr">advancedChunks</span>: {
          <span class="hljs-attr">groups</span>: [{ <span class="hljs-attr">name</span>: <span class="hljs-string">'vendor'</span>, <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\/react(?:-dom)?/</span> }]
        }
      }
    }
  }
}
</code></pre>
<p><code>advancedChunks</code> 的行为模式更接近 webpack 的 <code>splitChunks</code>，提供了更精细的分块控制能力。</p>
<h3 id="runtime-chunk-机制"><a aria-hidden="true" tabindex="-1" href="#runtime-chunk-机制"><span class="icon icon-link"></span></a>Runtime Chunk 机制</h3>
<p>使用 <code>advancedChunks</code> 后，构建产物会自动生成一个 <code>rolldown-runtime-{hash}</code> 文件。这个看似简单的变化，实际上解决了传统 Rollup <code>manualChunks</code> 配置中的一个重要痛点。</p>
<h4 id="传统-manualchunks-的依赖问题"><a aria-hidden="true" tabindex="-1" href="#传统-manualchunks-的依赖问题"><span class="icon icon-link"></span></a>传统 manualChunks 的依赖问题</h4>
<p>在使用 Rollup 的 <code>manualChunks</code> 功能时，我们经常会遇到这样的配置：</p>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// 典型的 manualChunks 配置</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
  <span class="hljs-attr">build</span>: {
    <span class="hljs-attr">rollupOptions</span>: {
      <span class="hljs-attr">output</span>: {
        <span class="hljs-attr">manualChunks</span>: {
          <span class="hljs-string">'vendor'</span>: [<span class="hljs-string">'react'</span>, <span class="hljs-string">'react-dom'</span>],
          <span class="hljs-string">'utils'</span>: [<span class="hljs-string">'lodash'</span>, <span class="hljs-string">'axios'</span>],
          <span class="hljs-string">'ui'</span>: [<span class="hljs-string">'antd'</span>, <span class="hljs-string">'@ant-design/icons'</span>]
        }
      }
    }
  }
}
</code></pre>
<p>这种配置在大多数情况下工作正常，但在复杂项目中容易产生以下问题：</p>
<p><strong>1. 循环依赖导致的加载顺序问题</strong></p>
<p>假设我们有这样的模块依赖关系：</p>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// moduleA.js</span>
<span class="hljs-keyword">import</span> { utilB } <span class="hljs-keyword">from</span> <span class="hljs-string">'./moduleB.js'</span>
<span class="hljs-keyword">import</span> { thirdPartyLib } <span class="hljs-keyword">from</span> <span class="hljs-string">'some-lib'</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">utilA</span> = (<span class="hljs-params"></span>) => {
  <span class="hljs-keyword">return</span> <span class="hljs-title function_">utilB</span>() + <span class="hljs-title function_">thirdPartyLib</span>()
}

<span class="hljs-comment">// moduleB.js  </span>
<span class="hljs-keyword">import</span> { utilA } <span class="hljs-keyword">from</span> <span class="hljs-string">'./moduleA.js'</span>
<span class="hljs-keyword">import</span> { anotherLib } <span class="hljs-keyword">from</span> <span class="hljs-string">'another-lib'</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">utilB</span> = (<span class="hljs-params"></span>) => {
  <span class="hljs-comment">// 在某些条件下可能会调用 utilA</span>
  <span class="hljs-keyword">return</span> someCondition ? <span class="hljs-title function_">utilA</span>() : <span class="hljs-title function_">anotherLib</span>()
}
</code></pre>
<p>当 <code>manualChunks</code> 将这些模块分配到不同的 chunk 时，可能会产生这样的输出：</p>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// chunk-vendor.js (包含 some-lib, another-lib)</span>
<span class="hljs-comment">// chunk-utils.js (包含 moduleA, moduleB)</span>
<span class="hljs-comment">// main.js (应用入口)</span>
</code></pre>
<p><strong>2. 运行时错误的具体表现</strong></p>
<p>在实际项目中，我曾遇到过这样的错误：</p>
<pre><code class="hljs language-bash">Uncaught ReferenceError: Cannot access <span class="hljs-string">'utilA'</span> before initialization
</code></pre>
<p>或者更隐蔽的问题：</p>
<pre><code class="hljs language-bash">Uncaught TypeError: utilB is not a <span class="hljs-keyword">function</span>
</code></pre>
<p>这类错误通常只在生产环境出现，因为开发环境使用的是非打包模式，模块加载顺序由浏览器的 ES Module 机制保证。</p>
<p><strong>3. 问题的根本原因</strong></p>
<p>问题的核心在于：当模块被分割到不同的 chunk 后，模块的初始化顺序变得不可预测。Rollup 在生成 chunk 时，可能会将循环依赖的模块放在不同的文件中，导致：</p>
<ul>
<li>Chunk A 需要 Chunk B 中的模块</li>
<li>Chunk B 也需要 Chunk A 中的模块</li>
<li>但运行时加载顺序无法保证正确的初始化序列</li>
</ul>
<h4 id="rolldown-的-runtime-chunk-解决方案"><a aria-hidden="true" tabindex="-1" href="#rolldown-的-runtime-chunk-解决方案"><span class="icon icon-link"></span></a>Rolldown 的 Runtime Chunk 解决方案</h4>
<p>Rolldown 通过强制生成 <code>runtime.js</code> 文件来解决这个问题：</p>
<p><strong>1. 运行时代码提取</strong></p>
<p><code>runtime.js</code> 包含了所有必要的运行时帮助函数和模块加载逻辑：</p>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// runtime.js (简化示例)</span>
<span class="hljs-keyword">var</span> <span class="hljs-title function_">__esm</span> = (<span class="hljs-params">fn, <span class="hljs-variable language_">module</span></span>) => {
  <span class="hljs-keyword">return</span> <span class="hljs-function">() =></span> {
    <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">module</span>.<span class="hljs-property">init</span>) {
      <span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {};
      <span class="hljs-variable language_">module</span>.<span class="hljs-property">init</span> = <span class="hljs-literal">true</span>;
      fn.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span>, <span class="hljs-variable language_">module</span>, <span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span>);
    }
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span>;
  };
};

<span class="hljs-keyword">var</span> <span class="hljs-title function_">__export</span> = (<span class="hljs-params">target, all</span>) => {
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> name <span class="hljs-keyword">in</span> all)
    target[name] = all[name];
};

<span class="hljs-comment">// 模块注册表</span>
<span class="hljs-keyword">var</span> __modules = {};
<span class="hljs-keyword">var</span> <span class="hljs-title function_">__register</span> = (<span class="hljs-params">id, fn</span>) => {
  __modules[id] = { fn, <span class="hljs-attr">exports</span>: {}, <span class="hljs-attr">init</span>: <span class="hljs-literal">false</span> };
};
</code></pre>
<p><strong>2. 确定的加载顺序</strong></p>
<p>所有其他 chunk 都会依赖 <code>runtime.js</code>，确保运行时代码始终最先执行：</p>
<pre><code class="hljs language-html"><span class="hljs-comment">&#x3C;!-- HTML 中的加载顺序 --></span>
<span class="hljs-tag">&#x3C;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"/assets/runtime-abc123.js"</span>></span><span class="hljs-tag">&#x3C;/<span class="hljs-name">script</span>></span>
<span class="hljs-tag">&#x3C;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"/assets/vendor-def456.js"</span>></span><span class="hljs-tag">&#x3C;/<span class="hljs-name">script</span>></span>
<span class="hljs-tag">&#x3C;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"/assets/main-ghi789.js"</span>></span><span class="hljs-tag">&#x3C;/<span class="hljs-name">script</span>></span>
</code></pre>
<p><strong>3. 安全的模块初始化</strong></p>
<p>通过运行时的模块管理机制，即使存在循环依赖，也能保证安全的初始化：</p>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// 在 runtime 管理下的模块加载</span>
<span class="hljs-keyword">var</span> init_moduleA = <span class="hljs-title function_">__esm</span>({
  <span class="hljs-string">"moduleA.js"</span>() {
    <span class="hljs-comment">// 延迟初始化，避免循环依赖问题</span>
    <span class="hljs-keyword">var</span> moduleB = <span class="hljs-title function_">__require</span>(<span class="hljs-string">"moduleB.js"</span>);
    <span class="hljs-built_in">exports</span>.<span class="hljs-property">utilA</span> = <span class="hljs-function">() =></span> {
      <span class="hljs-keyword">return</span> moduleB.<span class="hljs-title function_">utilB</span>() + <span class="hljs-title function_">thirdPartyLib</span>();
    };
  }
});
</code></pre>
<h4 id="权衡考虑"><a aria-hidden="true" tabindex="-1" href="#权衡考虑"><span class="icon icon-link"></span></a>权衡考虑</h4>
<p>当然，<code>runtime.js</code> 也带来了一些权衡：</p>
<p><strong>优势：</strong></p>
<ul>
<li>彻底解决循环依赖问题</li>
<li>提高大型项目的运行时稳定性</li>
<li>为模块联邦等高级功能奠定基础</li>
</ul>
<p><strong>成本：</strong></p>
<ul>
<li>增加一个额外的 HTTP 请求</li>
<li>轻微增加总的 bundle 大小（通常 &#x3C; 5KB）</li>
<li>需要调整构建流水线以适应新的文件结构</li>
</ul>
<p>从我的实际使用体验来看，这个权衡是值得的。相比于在生产环境中调试循环依赖问题的复杂性，多一个 runtime 文件的成本几乎可以忽略不计。</p>
<h2 id="插件生态适配"><a aria-hidden="true" tabindex="-1" href="#插件生态适配"><span class="icon icon-link"></span></a>插件生态适配</h2>
<h3 id="react-插件优化"><a aria-hidden="true" tabindex="-1" href="#react-插件优化"><span class="icon icon-link"></span></a>React 插件优化</h3>
<p>对于 React 项目，官方推荐使用 <code>@vitejs/plugin-react-oxc</code> 替代传统的 React 插件：</p>
<ul>
<li><strong>技术基础</strong>：基于 Oxc（Rust 编写的前端工具链）</li>
<li><strong>性能优势</strong>：与 rolldown-vite 的 Rust 架构更好匹配</li>
<li><strong>限制条件</strong>：不支持自定义 Babel 或 SWC 插件</li>
</ul>
<p>这个限制对于依赖复杂 Babel 配置的项目可能是个障碍，需要权衡性能收益与功能需求。</p>
<h3 id="钩子过滤机制"><a aria-hidden="true" tabindex="-1" href="#钩子过滤机制"><span class="icon icon-link"></span></a>钩子过滤机制</h3>
<p>Rolldown 引入了插件钩子过滤功能，这是一个重要的性能优化特性，解决了 Rust 打包器中跨语言调用的性能瓶颈问题。</p>
<h4 id="传统插件钩子的性能问题"><a aria-hidden="true" tabindex="-1" href="#传统插件钩子的性能问题"><span class="icon icon-link"></span></a>传统插件钩子的性能问题</h4>
<p>在传统的 Rollup 插件中，我们经常看到这样的模式：</p>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// 典型的 Rollup 插件写法</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">stylePlugin</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">return</span> {
    <span class="hljs-attr">name</span>: <span class="hljs-string">'style-processor'</span>,
    <span class="hljs-title function_">transform</span>(<span class="hljs-params">code, id</span>) {
      <span class="hljs-comment">// 每个模块都会触发这个钩子</span>
      <span class="hljs-keyword">if</span> (!id.<span class="hljs-title function_">endsWith</span>(<span class="hljs-string">'.css'</span>) &#x26;&#x26; !id.<span class="hljs-title function_">endsWith</span>(<span class="hljs-string">'.scss'</span>)) {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span> <span class="hljs-comment">// 大部分情况下都是早期返回</span>
      }
      
      <span class="hljs-comment">// 实际的样式处理逻辑</span>
      <span class="hljs-keyword">return</span> <span class="hljs-title function_">processStyles</span>(code, id)
    },
    <span class="hljs-title function_">load</span>(<span class="hljs-params">id</span>) {
      <span class="hljs-keyword">if</span> (!id.<span class="hljs-title function_">includes</span>(<span class="hljs-string">'?inline'</span>)) {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span> <span class="hljs-comment">// 又是一次无效调用</span>
      }
      
      <span class="hljs-keyword">return</span> <span class="hljs-title function_">inlineStyleLoader</span>(id)
    }
  }
}
</code></pre>
<p>这种设计在 JavaScript 打包器中工作良好，但在 Rust 打包器中存在严重的性能问题：</p>
<p><strong>1. 频繁的跨语言调用开销</strong></p>
<p>在一个包含 1000+ 模块的项目中：</p>
<ul>
<li>每个模块都会触发 <code>transform</code> 钩子</li>
<li>大部分调用最终都是无效的（早期返回）</li>
<li>Rust 到 JS 的调用本身就有开销</li>
<li>累积起来成为显著的性能瓶颈</li>
</ul>
<p><strong>2. 破坏 Rust 的并行优化</strong></p>
<p>由于 JavaScript 的单线程特性：</p>
<ul>
<li>即使 Rust 端可以并行处理多个模块</li>
<li>但插件调用必须串行化到 JS 主线程</li>
<li>降低了整体的并行处理效率</li>
</ul>
<h4 id="rolldown-的过滤器设计"><a aria-hidden="true" tabindex="-1" href="#rolldown-的过滤器设计"><span class="icon icon-link"></span></a>Rolldown 的过滤器设计</h4>
<p>Rolldown 通过在插件钩子中引入 <code>filter</code> 属性来解决这个问题：</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">stylePlugin</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">return</span> {
    <span class="hljs-attr">name</span>: <span class="hljs-string">'style-processor'</span>,
    <span class="hljs-attr">transform</span>: {
      <span class="hljs-comment">// 在 Rust 层面进行预过滤</span>
      <span class="hljs-attr">filter</span>: {
        <span class="hljs-attr">id</span>: {
          <span class="hljs-attr">include</span>: [<span class="hljs-regexp">/\.css$/</span>, <span class="hljs-regexp">/\.scss$/</span>],
          <span class="hljs-attr">exclude</span>: <span class="hljs-regexp">/\.module\./</span>
        }
      },
      <span class="hljs-title function_">handler</span>(<span class="hljs-params">code, id</span>) {
        <span class="hljs-comment">// 只有通过过滤器的模块才会到达这里</span>
        <span class="hljs-keyword">return</span> <span class="hljs-title function_">processStyles</span>(code, id)
      }
    },
    <span class="hljs-attr">load</span>: {
      <span class="hljs-attr">filter</span>: {
        <span class="hljs-attr">id</span>: <span class="hljs-regexp">/\?inline$/</span>
      },
      <span class="hljs-title function_">handler</span>(<span class="hljs-params">id</span>) {
        <span class="hljs-keyword">return</span> <span class="hljs-title function_">inlineStyleLoader</span>(id)
      }
    }
  }
}
</code></pre>
<h4 id="过滤器的详细配置"><a aria-hidden="true" tabindex="-1" href="#过滤器的详细配置"><span class="icon icon-link"></span></a>过滤器的详细配置</h4>
<p>过滤器支持多种匹配条件：</p>
<pre><code class="hljs language-javascript">{
  <span class="hljs-attr">transform</span>: {
    <span class="hljs-attr">filter</span>: {
      <span class="hljs-comment">// 基于文件 ID 过滤</span>
      <span class="hljs-attr">id</span>: {
        <span class="hljs-attr">include</span>: [<span class="hljs-regexp">/\.ts$/</span>, <span class="hljs-regexp">/\.tsx$/</span>],
        <span class="hljs-attr">exclude</span>: [<span class="hljs-regexp">/\.d\.ts$/</span>, <span class="hljs-regexp">/node_modules/</span>]
      },
      
      <span class="hljs-comment">// 基于模块类型过滤</span>
      <span class="hljs-attr">moduleType</span>: <span class="hljs-string">'js'</span>,
      
      <span class="hljs-comment">// 基于源代码内容过滤</span>
      <span class="hljs-attr">code</span>: {
        <span class="hljs-attr">include</span>: [<span class="hljs-string">'export default'</span>, <span class="hljs-string">'export const'</span>],
        <span class="hljs-attr">exclude</span>: [<span class="hljs-string">'// @skip-transform'</span>]
      }
    },
    <span class="hljs-title function_">handler</span>(<span class="hljs-params">code, id</span>) {
      <span class="hljs-keyword">return</span> <span class="hljs-title function_">transformTypeScript</span>(code, id)
    }
  }
}
</code></pre>
<p><strong>过滤逻辑：</strong></p>
<ul>
<li><code>include</code> 数组中任意一个匹配即可通过</li>
<li><code>exclude</code> 优先级高于 <code>include</code></li>
<li>多个过滤属性之间是 AND 关系（必须全部匹配）</li>
</ul>
<h2 id="全量打包模式探索"><a aria-hidden="true" tabindex="-1" href="#全量打包模式探索"><span class="icon icon-link"></span></a>全量打包模式探索</h2>
<p>全量打包模式是 rolldown-vite 的一个实验性功能，代表了对传统 Vite 开发模式的重要反思和创新尝试。</p>
<h4 id="传统-vite-开发模式的挑战"><a aria-hidden="true" tabindex="-1" href="#传统-vite-开发模式的挑战"><span class="icon icon-link"></span></a>传统 Vite 开发模式的挑战</h4>
<p>Vite 的核心竞争力源于其非打包开发服务器，这种设计在早期带来了显著的性能优势：</p>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// 传统开发模式：每个模块独立请求</span>
<span class="hljs-comment">// /src/App.tsx -> http://localhost:3000/src/App.tsx</span>
<span class="hljs-comment">// /src/components/Header.tsx -> http://localhost:3000/src/components/Header.tsx  </span>
<span class="hljs-comment">// /src/utils/api.ts -> http://localhost:3000/src/utils/api.ts</span>
</code></pre>
<p>然而，随着项目规模增长，这种模式逐渐暴露出两个核心问题：</p>
<p><strong>1. 开发与生产环境的行为差异</strong></p>
<p>我在实际项目中遇到过这样的问题：</p>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// 开发环境正常运行的代码</span>
<span class="hljs-keyword">import</span> { debounce } <span class="hljs-keyword">from</span> <span class="hljs-string">'lodash'</span>
<span class="hljs-keyword">import</span> utils <span class="hljs-keyword">from</span> <span class="hljs-string">'./utils'</span> <span class="hljs-comment">// 这里存在循环依赖</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">SearchComponent</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">const</span> debouncedSearch = <span class="hljs-title function_">debounce</span>(utils.<span class="hljs-property">search</span>, <span class="hljs-number">300</span>)
  <span class="hljs-comment">// ...</span>
}
</code></pre>
<ul>
<li><strong>开发环境</strong>：浏览器的原生 ES Module 机制处理模块加载，循环依赖被自然解决</li>
<li><strong>生产环境</strong>：Rollup 打包后，模块的初始化顺序发生变化，导致运行时错误</li>
</ul>
<p><strong>2. 网络性能衰减问题</strong></p>
<p>在一个包含 300+ 组件的大型项目中，初始页面加载可能触发：</p>
<pre><code class="hljs language-bash"><span class="hljs-comment"># Chrome DevTools Network 面板中的典型场景</span>
200+ HTTP requests (modules)
150+ HTTP requests (dependencies)  
50+ HTTP requests (assets)
---
Total: 400+ requests during development
</code></pre>
<p>这带来了几个实际问题：</p>
<ul>
<li><strong>开发服务器启动延迟</strong>：大量模块的按需编译</li>
<li><strong>页面刷新缓慢</strong>：特别是在网络代理环境下</li>
<li><strong>调试困难</strong>：网络面板中充斥着大量的模块请求</li>
</ul>
<h4 id="全量打包模式的设计理念"><a aria-hidden="true" tabindex="-1" href="#全量打包模式的设计理念"><span class="icon icon-link"></span></a>全量打包模式的设计理念</h4>
<p>rolldown-vite 的全量打包模式试图在保持开发性能的同时解决上述问题：</p>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// 全量打包模式的工作流程</span>
<span class="hljs-number">1.</span> 启动时进行快速的全量打包 (基于 <span class="hljs-title class_">Rust</span> 的高性能)
<span class="hljs-number">2.</span> 生成统一的 bundle，但保持模块边界清晰
<span class="hljs-number">3.</span> <span class="hljs-variable constant_">HMR</span> 仍然基于模块级别进行精确更新
<span class="hljs-number">4.</span> 开发与生产环境使用相同的模块加载机制
</code></pre>
<h2 id="结语"><a aria-hidden="true" tabindex="-1" href="#结语"><span class="icon icon-link"></span></a>结语</h2>
<p>rolldown-vite 作为 Vite 生态的重要演进，展现了前端构建工具向 Rust 生态迁移的技术趋势。通过实际体验，可以感受到其在性能优化、开发一致性等方面的改进。新的分块机制、钩子过滤、以及实验性的全量打包模式，都体现了对传统构建工具痛点的深度思考和创新尝试。</p>7:["$","article",null,{"children":[["$","div",null,{"className":"flex justify-center font-[Arial] max-w-[864px] text-center","children":["$","h1",null,{"className":"text-[2.5rem] font-bold bg-lime-300 px-5 py-2 rounded-sm text-shadow-lg leading-[1.1]","children":"Rolldown-Vite 实践体验：基于 Rust 的新一代构建工具"}]}],["$","div",null,{"className":"flex flex-wrap items-center gap-4 mb-6","children":[["$","time",null,{"dateTime":"2025-06-11","className":"text-center block my-4 text-sm opacity-60","children":"June\t11, 2025"}],["$","span",null,{"className":"px-3 py-1 text-sm rounded bg-gray-100 dark:bg-gray-800","children":"blog"}],"$undefined"]}],[null,["$","$L17",null,{"theme":"fancy"}],["$","section",null,{"className":"markdown-body-fancy max-w-3xl","dangerouslySetInnerHTML":{"__html":"$18"}}]],null]}]
11:[["$","meta","0",{"charSet":"utf-8"}],["$","meta","1",{"name":"viewport","content":"width=device-width, initial-scale=1"}]]
b:null
16:{"metadata":[["$","title","0",{"children":"Ai.Haibara codes"}],["$","meta","1",{"name":"description","content":"LZS Blog"}],["$","link","2",{"rel":"icon","href":"/favicon.ico","type":"image/x-icon","sizes":"96x96"}]],"error":null,"digest":"$undefined"}
e:{"metadata":"$16:metadata","error":null,"digest":"$undefined"}
