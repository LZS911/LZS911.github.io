<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><link rel="apple-touch-icon" sizes="180x180" href="/favicon/apple-touch-icon.png"/><link rel="icon" type="image/png" sizes="32x32" href="/favicon/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="16x16" href="/favicon/favicon-16x16.png"/><link rel="manifest" href="/favicon/site.webmanifest"/><link rel="mask-icon" href="/favicon/safari-pinned-tab.svg" color="#000000"/><link rel="shortcut icon" href="/favicon/favicon.ico"/><meta name="msapplication-TileColor" content="#000000"/><meta name="msapplication-config" content="/favicon/browserconfig.xml"/><meta name="theme-color" content="#000"/><link rel="alternate" type="application/rss+xml" href="/feed.xml"/><meta property="og:image" content="https://og-image.vercel.app/Next.js%20Blog%20Starter%20Example.png?theme=light&amp;md=1&amp;fontSize=100px&amp;images=https%3A%2F%2Fassets.vercel.com%2Fimage%2Fupload%2Ffront%2Fassets%2Fdesign%2Fnextjs-black-logo.svg"/><title>《图解Http》 阅读记录 | Ai.Haibara codes</title><meta name="next-head-count" content="14"/><link rel="preload" href="/_next/static/css/8681f744d5932be6.css" as="style"/><link rel="stylesheet" href="/_next/static/css/8681f744d5932be6.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-8fa1640cc84ba8fe.js" defer=""></script><script src="/_next/static/chunks/framework-3b5a00d5d7e8d93b.js" defer=""></script><script src="/_next/static/chunks/main-59a90320855f5cf5.js" defer=""></script><script src="/_next/static/chunks/pages/_app-f46e289d7ac5e197.js" defer=""></script><script src="/_next/static/chunks/799-575b46febca3af7d.js" defer=""></script><script src="/_next/static/chunks/399-cac0cd8ed02bf02a.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bslug%5D-e2afa3a98c674f72.js" defer=""></script><script src="/_next/static/Rfvy9WK71nLCZ90Ws6Jh7/_buildManifest.js" defer=""></script><script src="/_next/static/Rfvy9WK71nLCZ90Ws6Jh7/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="min-h-screen"><header class="text-white bg-black drop-shadow-2xl"><div class="mx-auto my-0 max-w-[960px] py-6 px-4 flex items-center"><div class="flex items-center"><img alt="Ai.Haibara" src="/assets/blog/authors/haibara_2.jpg" width="100" height="100" decoding="async" data-nimg="1" class=" rounded-full" loading="lazy" style="color:transparent"/></div><div class="ml-6"><a class=" font-bold text-3xl" href="/">Ai.Haibara codes</a><div class="mt-2"><a class="p-1 rounded-sm text-xl mr-2 hover:border-b-2 border-indigo" href="/">Home</a><a class="p-1 rounded-sm text-xl mr-2 hover:border-b-2 border-indigo" href="/projects">Projects</a><a class="p-1 rounded-sm text-xl mr-2 hover:border-b-2 border-indigo" href="/talks">Talks</a><a class="p-1 rounded-sm text-xl mr-2 hover:border-b-2 border-indigo" href="/blogs">Blogs</a></div></div></div></header><main class="p-6 flex justify-center"><article><div class="flex justify-center font-[Arial] max-w-[864px] text-center"><h1 class="text-5xl font-bold bg-indigo px-5 py-2 rounded-sm text-shadow-lg leading-[1.1]">《图解Http》 阅读记录</h1></div><time dateTime="2022-11-21" class="text-center block my-4 text-sm opacity-60">November	21, 2022</time><section><div class="markdown-body-fancy max-w-3xl"><h2 id="1-tcpip-协议族"><a aria-hidden="true" tabindex="-1" href="#1-tcpip-协议族"><span class="icon icon-link"></span></a>1. TCP/IP 协议族</h2>
<p>不同的硬件、操作系统之间的通信, 所有的一切都需要一种规则. 而我们就将这种规则称为协议( protocol ). 协议中存在着各种各样的内容, 像这样把互联网相关的协议集合统称为 TCP/IP.</p>
<h3 id="tcpip-的分层管理"><a aria-hidden="true" tabindex="-1" href="#tcpip-的分层管理"><span class="icon icon-link"></span></a>TCP/IP 的分层管理</h3>
<ol>
<li>
<p>应用层 决定了向用户提供应用服务时的通信的活动. http 协议处于该层.</p>
</li>
<li>
<p>传输层 为上层应用层提供了处于网络连接中的两台计算机之前的数据传输. TCP 协议以及 UDP 协议.</p>
</li>
<li>
<p>网络层 处理在网络上流动的数据包. 改成规定了通过怎样的路径(传输路线)到达对方计算机, 并将数据包传输给对方.</p>
</li>
<li>
<p>链路层  硬件相关, 例如设备驱动、网卡、光纤等.</p>
</li>
</ol>
<h3 id="tcpip-通信传输流"><a aria-hidden="true" tabindex="-1" href="#tcpip-通信传输流"><span class="icon icon-link"></span></a>TCP/IP 通信传输流</h3>
<p><img src="/assets/%E5%9B%BE%E8%A7%A3http/example-1.png" alt="alt"></p>
<h3 id="与-http-密切相关的协议-iptcp-以及-dns"><a aria-hidden="true" tabindex="-1" href="#与-http-密切相关的协议-iptcp-以及-dns"><span class="icon icon-link"></span></a>与 Http 密切相关的协议: IP、TCP 以及 DNS</h3>
<p><img src="/assets/%E5%9B%BE%E8%A7%A3http/example-2.png" alt="alt"></p>
<h3 id="uri-和-url"><a aria-hidden="true" tabindex="-1" href="#uri-和-url"><span class="icon icon-link"></span></a>URI 和 URL</h3>
<p>URI 用字符串标识某一互联网资源, URL 表示资源的地点. URL 属于 URI 的子集.</p>
<p>URI 格式:</p>
<pre><code class="language-ssh">ftp://user:pass@127.0.0.1:8181/URI/test.txt
http://www.exapmle.com:80/dir/index.html?uid=1#ch=1
</code></pre>
<p>具体每项信息如下图:</p>
<p><img src="/assets/%E5%9B%BE%E8%A7%A3http/example-3.png" alt="alt"></p>
<h2 id="2-简单的-http-协议"><a aria-hidden="true" tabindex="-1" href="#2-简单的-http-协议"><span class="icon icon-link"></span></a>2. 简单的 Http 协议</h2>
<h3 id="http-协议用于客户端和服务端之间的通信"><a aria-hidden="true" tabindex="-1" href="#http-协议用于客户端和服务端之间的通信"><span class="icon icon-link"></span></a>HTTP 协议用于客户端和服务端之间的通信</h3>
<p>http 协议规定, 请求从客户端发出, 最后服务端响应该请求并返回. 换句话说, 肯定是先从客户端开始建立通信, 服务端在没有接收到请求之前不会发送响应.</p>
<p>举个栗子:</p>
<p><img src="/assets/%E5%9B%BE%E8%A7%A3http/example-4.png" alt="alt"></p>
<p>下面是从客户端发送给某个 HTTP 服务端的请求报文内容.</p>
<pre><code class="language-code">Get /index.html HTTP/1.1
</code></pre>
<p>其表示为 请求访问某台 HTTP 服务器上的 /index.html 页面资源. 请求报文是由请求方法(GET), 请求 URI (/index.html) 、协议版本(HTTP/1.1)、可选的请求首部字段和内容实体构成的.</p>
<p><img src="/assets/%E5%9B%BE%E8%A7%A3http/example-5.png" alt="alt"></p>
<h3 id="http-是一种无状态协议"><a aria-hidden="true" tabindex="-1" href="#http-是一种无状态协议"><span class="icon icon-link"></span></a>HTTP 是一种无状态协议</h3>
<p>HTTP 协议自身不对请求和响应之间的通信状态进行保存. 使用 HTTP 协议时, 每当有新的请求发送时, 就会有对应的新响应产生, 协议本身并不会保留之前一切的请求或响应报文的信息. 这是为了更快的处理大量事务, 确保协议的可伸缩性.</p>
<p>随着 Web 的不断发展, 因无状态而导致业务处理变得棘手的情况增多了, 例如保存用户的登录状态. 为了实现期望的保持状态功能, 于是引入了 Cookie 技术. 有了 Cookie 后便可以管理状态了.</p>
<h3 id="使用-cookie-的状态管理"><a aria-hidden="true" tabindex="-1" href="#使用-cookie-的状态管理"><span class="icon icon-link"></span></a>使用 Cookie 的状态管理</h3>
<p>Cookie 技术通过在请求和响应报文中写入 Cookie 信息来控制客户端的状态.</p>
<p>Cookie 会根据从服务端发送的响应报文内的一个名为 <code>Set-Cookie</code> 的首部字段信息, 通知客户端保存 Cookie. 当下次客户端再往该服务发送请求时, 客户端会自动在请求报文中加入 Cookie 值后发送出去. 服务端发现客户端发送过来的 Cookie 后, 回去检查究竟是从哪一个客户端发来的连接请求, 然后对比服务器上的记录, 最后得到之前的状态信息.</p>
<p><img src="/assets/%E5%9B%BE%E8%A7%A3http/example-6.png" alt="alt"></p>
<ul>
<li>请求报文(没有 Cookie 信息的状态)</li>
</ul>
<pre><code class="language-code">Get /reader/ HTTP/1.1
Host: localhost:3000
</code></pre>
<ul>
<li>响应报文(服务端生成 Cookie 信息)</li>
</ul>
<pre><code class="language-code">HTTP/1.1 200 OK
Date: Thu, 12 Jul 2022 07:12:20 GMT
Server: Apache
&#x3C;Set-Cookie: sid=18872608917; path=/; expires=Web, =>
10-Oct-12 07:12:20 GMT>
Content-Type: text/plain; charset=UTF-8
</code></pre>
<ul>
<li>请求报文(自动发送保存着的 Cookie 信息)</li>
</ul>
<pre><code class="language-code">Get /image/ HTTP/1.1
Host: localhost:3000
Cookie: sid=18872608917
</code></pre>
<h3 id="http-的持久连接"><a aria-hidden="true" tabindex="-1" href="#http-的持久连接"><span class="icon icon-link"></span></a>HTTP 的持久连接</h3>
<p>HTTP 协议的初始版本中, 每进行一次 HTTP 通信后都需要断开一次 TCP 连接. 当传输的容量很小时, 这样设计也不会有太大的问题. 可随着 HTTP 的普及, 文档中包含大量图片的情况多了起来. 这样每次的请求都会造成无谓的 TCP 连接建立和断开, 增加通信量的开销.</p>
<p><img src="/assets/%E5%9B%BE%E8%A7%A3http/example-7.png" alt="alt"></p>
<p>持久连接的好处在于减少了 TCP 连接的重复建立和断开所造成的额外开销, 减轻了服务端的负载. 另外, 减少开销的那部分时间, 使 HTTP 请求和响应能够更早的结束, 这样 Web 页面的现实速度也就相应的提高了. 在 HTTP/1.1 中, 所有的连接默认都是持久连接.</p>
<p>持久连接使得多数请求以管线化(pipelining)方式发送成为可能. 从前发送请求后需等待并收到响应, 才能发送下一个请求. 管线化技术出现后, 不用等待响应亦可直接发送下一个请求.</p>
<h2 id="http-报文内的-http-信息"><a aria-hidden="true" tabindex="-1" href="#http-报文内的-http-信息"><span class="icon icon-link"></span></a>HTTP 报文内的 HTTP 信息</h2>
<h3 id="http-报文"><a aria-hidden="true" tabindex="-1" href="#http-报文"><span class="icon icon-link"></span></a>HTTP 报文</h3>
<p>用于 HTTP 协议交互的信息被称为 HTTP 报文. 请求端(客户端)的 HTTP 报文叫做请求报文, 响应端(服务端)的叫做响应报文. HTTP 报文本身是由多行数据构成的字符串文本.</p>
<h3 id="请求报文以及响应报文的结构"><a aria-hidden="true" tabindex="-1" href="#请求报文以及响应报文的结构"><span class="icon icon-link"></span></a>请求报文以及响应报文的结构</h3>
<p><img src="/assets/%E5%9B%BE%E8%A7%A3http/example-8.png" alt="alt"></p>
<p><img src="/assets/%E5%9B%BE%E8%A7%A3http/example-9.png" alt="alt"></p>
<p>请求报文和响应报文的首部内容由以下数据组成.</p>
<ul>
<li>请求行:
包含用于请求的方法, 请求 URI 和 HTTP 版本.</li>
<li>状态行:
包含表明响应结果的状态码, 原因短语和 HTTP 版本.</li>
<li>首部字段:
包含表示请求和响应的各种条件和属性的各类首部</li>
</ul>
<h3 id="编码提升传输速率"><a aria-hidden="true" tabindex="-1" href="#编码提升传输速率"><span class="icon icon-link"></span></a>编码提升传输速率</h3>
<p>HTTP 在传输数据时可以按照数据原貌直接传输, 但也可以在传输过程中通过编码提升传输速率. 通过在传输时便吗, 能有效地处理大量的访问请求. 但是, 编码的操作需要计算机来完成, 因此会消耗更多的 CPU 等资源.</p>
<ol>
<li>
<p>压缩传输的内容编码</p>
</li>
<li>
<p>分割发送的分块传输编码</p>
</li>
</ol>
<h3 id="发送多种数据的多部分对象集合"><a aria-hidden="true" tabindex="-1" href="#发送多种数据的多部分对象集合"><span class="icon icon-link"></span></a>发送多种数据的多部分对象集合</h3>
<p>HTTP 协议中采纳了多部分对象集合, 发送的一份报文主体哪颗含有多类型实体. 通常是在图片或文本文件等上传时使用.</p>
<ul>
<li><code>multipart/form-data</code>: 在 Web 表单文件上传时使用</li>
<li><code>multipart/byteranges</code>: 状态码 206(Partial Content, 部分内容)响应报文包含了多个范围的内容时使用</li>
</ul>
<h2 id="返回结果的-http-状态码"><a aria-hidden="true" tabindex="-1" href="#返回结果的-http-状态码"><span class="icon icon-link"></span></a>返回结果的 HTTP 状态码</h2>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status</a></p>
<h2 id="与-http-协作的-web-服务器"><a aria-hidden="true" tabindex="-1" href="#与-http-协作的-web-服务器"><span class="icon icon-link"></span></a>与 HTTP 协作的 Web 服务器</h2>
<p>一台 Web 服务器可搭建多个独立域名的 Web 网站, 也可作为通信路径上的中转服务器提升传输效率.</p>
<h3 id="单台虚拟主机实现多个域名"><a aria-hidden="true" tabindex="-1" href="#单台虚拟主机实现多个域名"><span class="icon icon-link"></span></a>单台虚拟主机实现多个域名</h3>
<p>HTTP/1.1 规范允许一台 HTTP 服务器搭建多个 Web 站点. 即使物理层面只有一台服务器, 但只要使用虚拟主机的功能, 则可以假象已具有多台服务器.</p>
<p>客户端使用 HTTP 协议访问服务器时, 会经常采用类似 <code>www.hackkr.jp</code> 这样的主机名和域名.</p>
<p>在互联网上, 域名通过 DNS 服务映射到 IP 地址(域名解析)之后访问目标网站. 可见, 当请求发送到服务器时, 已经是以 IP 地址形式访问了.</p>
<p>所以, 如果一台服务器内托管了 <code>www.tricorder.jp</code> 和 <code>www.hackr.jp</code> 这两个域名, 当收到请求时就需要弄清楚究竟要访问哪个域名.</p>
<p><img src="/assets/%E5%9B%BE%E8%A7%A3http/example-10.png" alt="alt"></p>
<p>在相同的 IP 地址下, 由于虚拟主机可以寄存多个不同主机名和域名的 Web 网站, 因此在发送 HTTP 请求时, 必须在 Host 首部内完整指定主机名或域名的 URI.</p>
<h3 id="通信数据转发程序-代理网关隧道"><a aria-hidden="true" tabindex="-1" href="#通信数据转发程序-代理网关隧道"><span class="icon icon-link"></span></a>通信数据转发程序: 代理、网关、隧道</h3>
<p>HTTP 通信时, 除客户端和服务器以外, 还有一些用于通信数据转发的应用程序, 例如代理、网关和隧道. 他们可以配合服务器工作.</p>
<h4 id="代理"><a aria-hidden="true" tabindex="-1" href="#代理"><span class="icon icon-link"></span></a>代理</h4>
<p>代理是一种有转发功能的应用程序, 它扮演了位于服务器和客户端 “中间人” 的角色, 接收由客户端发送的请求并转发给服务器, 同时也接收服务器返回的响应并转发给客户端.</p>
<p><img src="/assets/%E5%9B%BE%E8%A7%A3http/example-11.png" alt="alt"></p>
<p>代理服务器的基本行为就是接收客户端发送的请求后转发给其他服务器. 代理不改变请求 URI, 会直接发送给前方持有资源的目标服务器. 持有资源实体的服务器被称为源服务器. 从源服务器返回的响应经过代理服务器后再传给客户端.</p>
<p>使用代理服务器的理由: 利用缓存技术减少网络带宽的流量, 组织内部针对特定网站的访问控制, 以获取访问日志为主要目的等等.</p>
<p>代理有多种使用方法, 按两种基准分类</p>
<ol>
<li>
<p>缓存代理</p>
<p>代理转发响应时, 缓存代理(Catching Proxy)会预先将资源的副本缓存在代理服务器上. 当代理再次接收到对相同资源的请求时, 就可以不从源服务器那里获取资源, 而是将之前缓存的资源作为响应返回.</p>
</li>
<li>
<p>透明代理</p>
<p>转发请求或响应时, 不对报文做任何加工的代理类型被称为透明代理(Transparent Proxy). 反之, 对报文内容进行加工的代理被称为非透明代理.</p>
</li>
</ol>
<h4 id="网关"><a aria-hidden="true" tabindex="-1" href="#网关"><span class="icon icon-link"></span></a>网关</h4>
<p>网关是转发其他服务器通信数据的服务器, 接收从客户端发送来的请求时, 它就像自己拥有资源的源服务器一样对请求进行处理. 有时可能客户端都不会察觉, 自己的通信目标是一个网关.</p>
<p><img src="/assets/%E5%9B%BE%E8%A7%A3http/example-12.png" alt="alt"></p>
<p>网关的工作机制和代理十分相似. 而网关能使通信线路上的服务器提供非 HTTP 协议服务. 利用网关能提高通信的安全性, 因为可以在客户端与网关之间的通信路上加密以确保连接的安全. 比如, 网关可以连接数据库, 使用 SQL 语句查询数据.</p>
<h4 id="隧道"><a aria-hidden="true" tabindex="-1" href="#隧道"><span class="icon icon-link"></span></a>隧道</h4>
<p>隧道实在相隔甚远的客户端和服务器两者之前进行中转, 并保持双方通信连接的应用程序.</p>
<p><img src="/assets/%E5%9B%BE%E8%A7%A3http/example-13.png" alt="alt"></p>
<p>隧道可按要求建立起一条与其他服务器的通信线路, 届时使用 SSL 等加密手段进行通信. 隧道的目的是确保客户端能与服务器进行安全的通信. 隧道本身不会去解析 HTTP 请求. 也就是说, 请求保持原样中转给之后的服务器. 隧道会在通信双方断开连接时结束.</p>
<h3 id="保存资源的缓存"><a aria-hidden="true" tabindex="-1" href="#保存资源的缓存"><span class="icon icon-link"></span></a>保存资源的缓存</h3>
<p>缓存是指代理服务器或客户端本地磁盘内保存的资源副本. 利用缓存可减少对源服务器的访问, 因此也就节省了通信流量和通信时间.</p>
<p>缓存服务器是代理服务器的一种, 并归类在缓存代理类型中. 换句话说, 当代理转发从服务器返回的响应时, 代理服务器将会保存一份资源的副本.</p>
<p><img src="/assets/%E5%9B%BE%E8%A7%A3http/example-14.png" alt="alt"></p>
<p>缓存服务器的优势在于利用缓存可避免多次从源服务器转发资源. 因此客户端可就近从缓存服务器上获取资源, 而源服务器也不必多次处理相同的请求了.</p>
<h4 id="缓存的有效期限"><a aria-hidden="true" tabindex="-1" href="#缓存的有效期限"><span class="icon icon-link"></span></a>缓存的有效期限</h4>
<p>即便缓存服务器内有缓存, 也不能保证每次都会返回对同资源的请求. 因为这关系到被缓存的有效性问题. 当遇上源服务器上的资源更新时, 如果还是使用不便的缓存, 那就会演变成返回更新前的旧的资源. 即使存在缓存, 也会因为客户端的要求、缓存的有效期限等因素, 向源服务器确认资源的有效性. 若判断缓存失效, 缓存服务器将会再次从源服务器上获取新的资源.</p>
<p><img src="/assets/%E5%9B%BE%E8%A7%A3http/example-15.png" alt="alt"></p>
<h4 id="客户端的缓存"><a aria-hidden="true" tabindex="-1" href="#客户端的缓存"><span class="icon icon-link"></span></a>客户端的缓存</h4>
<p>缓存不仅可以存于缓存服务器内, 还可以存在客户端浏览器中. 客户端缓存一般被称为 临时网络文件(Temporary Internet File).</p>
<p>浏览器缓存如果有效, 就不必再向服务器请求相同的资源了, 可以直接从本地磁盘累读取. 另外, 和缓存服务器相同的一点是, 当判定缓存过期后, 会向源服务器确认资源的有效性. 若判断浏览器缓存失效, 浏览器会再次请求新资源.</p>
<p><img src="/assets/%E5%9B%BE%E8%A7%A3http/example-16.png" alt="alt"></p>
<h2 id="http-首部"><a aria-hidden="true" tabindex="-1" href="#http-首部"><span class="icon icon-link"></span></a>HTTP 首部</h2>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers</a></p>
<h2 id="确保-web-安全的-https"><a aria-hidden="true" tabindex="-1" href="#确保-web-安全的-https"><span class="icon icon-link"></span></a>确保 Web 安全的 HTTPS</h2>
<p>在 HTTP 协议中可能存在信息窃听或身份伪装等安全问题. 使用 HTTPS 通信机制可以有效的防止这些问题.</p>
<h3 id="http-的缺点"><a aria-hidden="true" tabindex="-1" href="#http-的缺点"><span class="icon icon-link"></span></a>HTTP 的缺点</h3>
<ul>
<li>通信使用明文(未加密), 内容可能遭到窃听</li>
<li>不验证通信方的身份, 因此可能遭遇伪装</li>
<li>无法证明报文的完整性, 所有有可能已遭篡改</li>
</ul>
<h4 id="通信使用明文可能会被窃听"><a aria-hidden="true" tabindex="-1" href="#通信使用明文可能会被窃听"><span class="icon icon-link"></span></a>通信使用明文可能会被窃听</h4>
<p>由于 HTTP 本身不具备加密的功能, 所以也无法做到对通信整体进行加密. 即 HTTP 报文使用明文的方式发送.</p>
<h5 id="tcpip-是可能被窃听的网络"><a aria-hidden="true" tabindex="-1" href="#tcpip-是可能被窃听的网络"><span class="icon icon-link"></span></a>TCP/IP 是可能被窃听的网络</h5>
<p>为什么通信时不加密是一个缺点? 这是因为按 TPC/IP 协议族的工作机制, 通信内容在所有的通信路线上都有可能遭到窥视.</p>
<p>即使已经过加密处理的通信, 也会被窥视到通信内容, 这点和未加密的通信是相同的. 只是说如果通信经过加密, 就有可能让人无法破解报文信息的含义, 当加密处理后的报文信息本身还是会被看到.</p>
<p><img src="/assets/%E5%9B%BE%E8%A7%A3http/example-17.png" alt="alt"></p>
<p>窃听相同段上的通信并非难事. 只需要收集在互联网上流动的数据包(帧)即可. 对于收集来的数据包的解析工作, 可交给抓包(Packet Capture) 或嗅探器(Sniffer) 工具.</p>
<h5 id="加密处理防止被窃听"><a aria-hidden="true" tabindex="-1" href="#加密处理防止被窃听"><span class="icon icon-link"></span></a>加密处理防止被窃听</h5>
<ol>
<li>
<p>通信加密</p>
<p>HTTP 协议中没有加密机制, 但可以通过 SSL(Secure Socket Layer, 安全套接层)或 TLS(Transport Layer Security, 安全层传输协议)的组合使用, 加密 HTTP 的通信内容. 用 SSL 建立安全通信路线之后, 就可以在这条线路上进行 HTTP 通信了. 与 SSL 组合使用的 HTTP 被称为 HTTPS(HTTP Secure, 超文本传输安全协议) 或 HTTP over SSL.</p>
</li>
<li>
<p>内容加密</p>
<p>对 HTTP 协议传输的内容本身加密, 即将 HTTP 报文里包含的内容进行加密处理(对报文主机进行加密, 报文首部信息未加密处理). 为了做到有效的内容加密, 前提是要求客户端和服务器同时具备加密和解密机制. 主要应用在 Web 服务中. 由于该方式不同于 SSL 或 TLS 将整个通信路线加密处理, 所以内容仍有被篡改的风险.</p>
</li>
</ol>
<h4 id="不验证通信方的身份可能遭遇伪装"><a aria-hidden="true" tabindex="-1" href="#不验证通信方的身份可能遭遇伪装"><span class="icon icon-link"></span></a>不验证通信方的身份可能遭遇伪装</h4>
<p>HTTP 协议中的请求和响应不会对通信方进行确认. 也就是说存在 “服务器是否就是发送请求中 URI 真正指定的主机, 返回的响应是否真的返回到实际提出请求的客户端” 等问题.</p>
<ol>
<li>
<p>任何人都可以发起请求</p>
<p>服务器只要接收到请求, 不管对方是谁都会返回一个响应(但也仅限于发送端的 IP 地址和端口号没有被 Web 服务器设定限制访问的前提下), 因此会存在以下隐患</p>
<ul>
<li>无法确定请求发送至目标的 Web 服务器是否是按真实意图返回响应的那台服务器. 有可能是已伪装 Web 服务器.</li>
<li>无法确定响应返回到的客户端是否是按真实意图接收响应的客户端. 有可能是已伪装的客户端.</li>
<li>无法确定正在通信的对方是否具备访问权限. 因为某些 Web 服务器上保存着重要信息, 只想发给特定用户通信的权限.</li>
<li>无法判定请求时来自何方、出自谁手.</li>
<li>即使是无意义的请求也会照单全手, 无法阻止海量请求下的 Dos 攻击(Denial of Service, 拒绝服务攻击).</li>
</ul>
</li>
<li>
<p>查明对手的证书</p>
<p>虽然使用 HTTP 协议无法确定通信方, 但如果使用 SSL 则可以. SSL 不仅提供加密信息, 而且还使用了一种被称为证书的手段, 可用于确定对方身份. 证书由值的信任的第三方机构颁发, 用以证明服务器和客户端是实际存在的. 另外, 伪造证书从技术角度来说是一场困难的一件事情.</p>
<p><img src="/assets/%E5%9B%BE%E8%A7%A3http/example-18.png" alt="alt"></p>
</li>
</ol>
<h4 id="无法证明报文完整性"><a aria-hidden="true" tabindex="-1" href="#无法证明报文完整性"><span class="icon icon-link"></span></a>无法证明报文完整性</h4>
<p>所谓完整性是指信息的准确度. 若无法证明其完整性, 通常也就意味着无法判断信息是否准确. 仅靠 HTTP 确保完整性是非常苦难的, 因此通过和其他协议组合来实现防止第三方的篡改.</p></div></section></article></main><footer class="bg-neutral-50 border-t border-neutral-200 text-center text-xs opacity-50 py-4">© 2022,<!-- --> <a rel="noopener noreferrer" class="hover:underline hover:bg-indigo" href="https://github.com/LZS911" target="_blank">LZS_911</a>, build with<!-- --> <a rel="noopener noreferrer" class="underline hover:bg-indigo" href="https://nextjs.org/" target="_blank">Next.js</a> <!-- -->and<!-- --> <a rel="noopener noreferrer" class="underline hover:bg-indigo" href="https://pages.github.com/?(null)" target="_blank">GitHub Pages</a></footer></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"《图解Http》 阅读记录","date":"2022-11-21","slug":"图解Http 阅读记录","author":"LZS_911","content":"\u003ch2 id=\"1-tcpip-协议族\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#1-tcpip-协议族\"\u003e\u003cspan class=\"icon icon-link\"\u003e\u003c/span\u003e\u003c/a\u003e1. TCP/IP 协议族\u003c/h2\u003e\n\u003cp\u003e不同的硬件、操作系统之间的通信, 所有的一切都需要一种规则. 而我们就将这种规则称为协议( protocol ). 协议中存在着各种各样的内容, 像这样把互联网相关的协议集合统称为 TCP/IP.\u003c/p\u003e\n\u003ch3 id=\"tcpip-的分层管理\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#tcpip-的分层管理\"\u003e\u003cspan class=\"icon icon-link\"\u003e\u003c/span\u003e\u003c/a\u003eTCP/IP 的分层管理\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e应用层 决定了向用户提供应用服务时的通信的活动. http 协议处于该层.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e传输层 为上层应用层提供了处于网络连接中的两台计算机之前的数据传输. TCP 协议以及 UDP 协议.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e网络层 处理在网络上流动的数据包. 改成规定了通过怎样的路径(传输路线)到达对方计算机, 并将数据包传输给对方.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e链路层  硬件相关, 例如设备驱动、网卡、光纤等.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3 id=\"tcpip-通信传输流\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#tcpip-通信传输流\"\u003e\u003cspan class=\"icon icon-link\"\u003e\u003c/span\u003e\u003c/a\u003eTCP/IP 通信传输流\u003c/h3\u003e\n\u003cp\u003e\u003cimg src=\"/assets/%E5%9B%BE%E8%A7%A3http/example-1.png\" alt=\"alt\"\u003e\u003c/p\u003e\n\u003ch3 id=\"与-http-密切相关的协议-iptcp-以及-dns\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#与-http-密切相关的协议-iptcp-以及-dns\"\u003e\u003cspan class=\"icon icon-link\"\u003e\u003c/span\u003e\u003c/a\u003e与 Http 密切相关的协议: IP、TCP 以及 DNS\u003c/h3\u003e\n\u003cp\u003e\u003cimg src=\"/assets/%E5%9B%BE%E8%A7%A3http/example-2.png\" alt=\"alt\"\u003e\u003c/p\u003e\n\u003ch3 id=\"uri-和-url\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#uri-和-url\"\u003e\u003cspan class=\"icon icon-link\"\u003e\u003c/span\u003e\u003c/a\u003eURI 和 URL\u003c/h3\u003e\n\u003cp\u003eURI 用字符串标识某一互联网资源, URL 表示资源的地点. URL 属于 URI 的子集.\u003c/p\u003e\n\u003cp\u003eURI 格式:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ssh\"\u003eftp://user:pass@127.0.0.1:8181/URI/test.txt\nhttp://www.exapmle.com:80/dir/index.html?uid=1#ch=1\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e具体每项信息如下图:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/%E5%9B%BE%E8%A7%A3http/example-3.png\" alt=\"alt\"\u003e\u003c/p\u003e\n\u003ch2 id=\"2-简单的-http-协议\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#2-简单的-http-协议\"\u003e\u003cspan class=\"icon icon-link\"\u003e\u003c/span\u003e\u003c/a\u003e2. 简单的 Http 协议\u003c/h2\u003e\n\u003ch3 id=\"http-协议用于客户端和服务端之间的通信\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#http-协议用于客户端和服务端之间的通信\"\u003e\u003cspan class=\"icon icon-link\"\u003e\u003c/span\u003e\u003c/a\u003eHTTP 协议用于客户端和服务端之间的通信\u003c/h3\u003e\n\u003cp\u003ehttp 协议规定, 请求从客户端发出, 最后服务端响应该请求并返回. 换句话说, 肯定是先从客户端开始建立通信, 服务端在没有接收到请求之前不会发送响应.\u003c/p\u003e\n\u003cp\u003e举个栗子:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/%E5%9B%BE%E8%A7%A3http/example-4.png\" alt=\"alt\"\u003e\u003c/p\u003e\n\u003cp\u003e下面是从客户端发送给某个 HTTP 服务端的请求报文内容.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-code\"\u003eGet /index.html HTTP/1.1\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e其表示为 请求访问某台 HTTP 服务器上的 /index.html 页面资源. 请求报文是由请求方法(GET), 请求 URI (/index.html) 、协议版本(HTTP/1.1)、可选的请求首部字段和内容实体构成的.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/%E5%9B%BE%E8%A7%A3http/example-5.png\" alt=\"alt\"\u003e\u003c/p\u003e\n\u003ch3 id=\"http-是一种无状态协议\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#http-是一种无状态协议\"\u003e\u003cspan class=\"icon icon-link\"\u003e\u003c/span\u003e\u003c/a\u003eHTTP 是一种无状态协议\u003c/h3\u003e\n\u003cp\u003eHTTP 协议自身不对请求和响应之间的通信状态进行保存. 使用 HTTP 协议时, 每当有新的请求发送时, 就会有对应的新响应产生, 协议本身并不会保留之前一切的请求或响应报文的信息. 这是为了更快的处理大量事务, 确保协议的可伸缩性.\u003c/p\u003e\n\u003cp\u003e随着 Web 的不断发展, 因无状态而导致业务处理变得棘手的情况增多了, 例如保存用户的登录状态. 为了实现期望的保持状态功能, 于是引入了 Cookie 技术. 有了 Cookie 后便可以管理状态了.\u003c/p\u003e\n\u003ch3 id=\"使用-cookie-的状态管理\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#使用-cookie-的状态管理\"\u003e\u003cspan class=\"icon icon-link\"\u003e\u003c/span\u003e\u003c/a\u003e使用 Cookie 的状态管理\u003c/h3\u003e\n\u003cp\u003eCookie 技术通过在请求和响应报文中写入 Cookie 信息来控制客户端的状态.\u003c/p\u003e\n\u003cp\u003eCookie 会根据从服务端发送的响应报文内的一个名为 \u003ccode\u003eSet-Cookie\u003c/code\u003e 的首部字段信息, 通知客户端保存 Cookie. 当下次客户端再往该服务发送请求时, 客户端会自动在请求报文中加入 Cookie 值后发送出去. 服务端发现客户端发送过来的 Cookie 后, 回去检查究竟是从哪一个客户端发来的连接请求, 然后对比服务器上的记录, 最后得到之前的状态信息.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/%E5%9B%BE%E8%A7%A3http/example-6.png\" alt=\"alt\"\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e请求报文(没有 Cookie 信息的状态)\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"language-code\"\u003eGet /reader/ HTTP/1.1\nHost: localhost:3000\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003e响应报文(服务端生成 Cookie 信息)\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"language-code\"\u003eHTTP/1.1 200 OK\nDate: Thu, 12 Jul 2022 07:12:20 GMT\nServer: Apache\n\u0026#x3C;Set-Cookie: sid=18872608917; path=/; expires=Web, =\u003e\n10-Oct-12 07:12:20 GMT\u003e\nContent-Type: text/plain; charset=UTF-8\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003e请求报文(自动发送保存着的 Cookie 信息)\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"language-code\"\u003eGet /image/ HTTP/1.1\nHost: localhost:3000\nCookie: sid=18872608917\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"http-的持久连接\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#http-的持久连接\"\u003e\u003cspan class=\"icon icon-link\"\u003e\u003c/span\u003e\u003c/a\u003eHTTP 的持久连接\u003c/h3\u003e\n\u003cp\u003eHTTP 协议的初始版本中, 每进行一次 HTTP 通信后都需要断开一次 TCP 连接. 当传输的容量很小时, 这样设计也不会有太大的问题. 可随着 HTTP 的普及, 文档中包含大量图片的情况多了起来. 这样每次的请求都会造成无谓的 TCP 连接建立和断开, 增加通信量的开销.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/%E5%9B%BE%E8%A7%A3http/example-7.png\" alt=\"alt\"\u003e\u003c/p\u003e\n\u003cp\u003e持久连接的好处在于减少了 TCP 连接的重复建立和断开所造成的额外开销, 减轻了服务端的负载. 另外, 减少开销的那部分时间, 使 HTTP 请求和响应能够更早的结束, 这样 Web 页面的现实速度也就相应的提高了. 在 HTTP/1.1 中, 所有的连接默认都是持久连接.\u003c/p\u003e\n\u003cp\u003e持久连接使得多数请求以管线化(pipelining)方式发送成为可能. 从前发送请求后需等待并收到响应, 才能发送下一个请求. 管线化技术出现后, 不用等待响应亦可直接发送下一个请求.\u003c/p\u003e\n\u003ch2 id=\"http-报文内的-http-信息\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#http-报文内的-http-信息\"\u003e\u003cspan class=\"icon icon-link\"\u003e\u003c/span\u003e\u003c/a\u003eHTTP 报文内的 HTTP 信息\u003c/h2\u003e\n\u003ch3 id=\"http-报文\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#http-报文\"\u003e\u003cspan class=\"icon icon-link\"\u003e\u003c/span\u003e\u003c/a\u003eHTTP 报文\u003c/h3\u003e\n\u003cp\u003e用于 HTTP 协议交互的信息被称为 HTTP 报文. 请求端(客户端)的 HTTP 报文叫做请求报文, 响应端(服务端)的叫做响应报文. HTTP 报文本身是由多行数据构成的字符串文本.\u003c/p\u003e\n\u003ch3 id=\"请求报文以及响应报文的结构\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#请求报文以及响应报文的结构\"\u003e\u003cspan class=\"icon icon-link\"\u003e\u003c/span\u003e\u003c/a\u003e请求报文以及响应报文的结构\u003c/h3\u003e\n\u003cp\u003e\u003cimg src=\"/assets/%E5%9B%BE%E8%A7%A3http/example-8.png\" alt=\"alt\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/%E5%9B%BE%E8%A7%A3http/example-9.png\" alt=\"alt\"\u003e\u003c/p\u003e\n\u003cp\u003e请求报文和响应报文的首部内容由以下数据组成.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e请求行:\n包含用于请求的方法, 请求 URI 和 HTTP 版本.\u003c/li\u003e\n\u003cli\u003e状态行:\n包含表明响应结果的状态码, 原因短语和 HTTP 版本.\u003c/li\u003e\n\u003cli\u003e首部字段:\n包含表示请求和响应的各种条件和属性的各类首部\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"编码提升传输速率\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#编码提升传输速率\"\u003e\u003cspan class=\"icon icon-link\"\u003e\u003c/span\u003e\u003c/a\u003e编码提升传输速率\u003c/h3\u003e\n\u003cp\u003eHTTP 在传输数据时可以按照数据原貌直接传输, 但也可以在传输过程中通过编码提升传输速率. 通过在传输时便吗, 能有效地处理大量的访问请求. 但是, 编码的操作需要计算机来完成, 因此会消耗更多的 CPU 等资源.\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e压缩传输的内容编码\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e分割发送的分块传输编码\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3 id=\"发送多种数据的多部分对象集合\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#发送多种数据的多部分对象集合\"\u003e\u003cspan class=\"icon icon-link\"\u003e\u003c/span\u003e\u003c/a\u003e发送多种数据的多部分对象集合\u003c/h3\u003e\n\u003cp\u003eHTTP 协议中采纳了多部分对象集合, 发送的一份报文主体哪颗含有多类型实体. 通常是在图片或文本文件等上传时使用.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003emultipart/form-data\u003c/code\u003e: 在 Web 表单文件上传时使用\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003emultipart/byteranges\u003c/code\u003e: 状态码 206(Partial Content, 部分内容)响应报文包含了多个范围的内容时使用\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"返回结果的-http-状态码\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#返回结果的-http-状态码\"\u003e\u003cspan class=\"icon icon-link\"\u003e\u003c/span\u003e\u003c/a\u003e返回结果的 HTTP 状态码\u003c/h2\u003e\n\u003cp\u003e\u003ca href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status\"\u003ehttps://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status\u003c/a\u003e\u003c/p\u003e\n\u003ch2 id=\"与-http-协作的-web-服务器\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#与-http-协作的-web-服务器\"\u003e\u003cspan class=\"icon icon-link\"\u003e\u003c/span\u003e\u003c/a\u003e与 HTTP 协作的 Web 服务器\u003c/h2\u003e\n\u003cp\u003e一台 Web 服务器可搭建多个独立域名的 Web 网站, 也可作为通信路径上的中转服务器提升传输效率.\u003c/p\u003e\n\u003ch3 id=\"单台虚拟主机实现多个域名\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#单台虚拟主机实现多个域名\"\u003e\u003cspan class=\"icon icon-link\"\u003e\u003c/span\u003e\u003c/a\u003e单台虚拟主机实现多个域名\u003c/h3\u003e\n\u003cp\u003eHTTP/1.1 规范允许一台 HTTP 服务器搭建多个 Web 站点. 即使物理层面只有一台服务器, 但只要使用虚拟主机的功能, 则可以假象已具有多台服务器.\u003c/p\u003e\n\u003cp\u003e客户端使用 HTTP 协议访问服务器时, 会经常采用类似 \u003ccode\u003ewww.hackkr.jp\u003c/code\u003e 这样的主机名和域名.\u003c/p\u003e\n\u003cp\u003e在互联网上, 域名通过 DNS 服务映射到 IP 地址(域名解析)之后访问目标网站. 可见, 当请求发送到服务器时, 已经是以 IP 地址形式访问了.\u003c/p\u003e\n\u003cp\u003e所以, 如果一台服务器内托管了 \u003ccode\u003ewww.tricorder.jp\u003c/code\u003e 和 \u003ccode\u003ewww.hackr.jp\u003c/code\u003e 这两个域名, 当收到请求时就需要弄清楚究竟要访问哪个域名.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/%E5%9B%BE%E8%A7%A3http/example-10.png\" alt=\"alt\"\u003e\u003c/p\u003e\n\u003cp\u003e在相同的 IP 地址下, 由于虚拟主机可以寄存多个不同主机名和域名的 Web 网站, 因此在发送 HTTP 请求时, 必须在 Host 首部内完整指定主机名或域名的 URI.\u003c/p\u003e\n\u003ch3 id=\"通信数据转发程序-代理网关隧道\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#通信数据转发程序-代理网关隧道\"\u003e\u003cspan class=\"icon icon-link\"\u003e\u003c/span\u003e\u003c/a\u003e通信数据转发程序: 代理、网关、隧道\u003c/h3\u003e\n\u003cp\u003eHTTP 通信时, 除客户端和服务器以外, 还有一些用于通信数据转发的应用程序, 例如代理、网关和隧道. 他们可以配合服务器工作.\u003c/p\u003e\n\u003ch4 id=\"代理\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#代理\"\u003e\u003cspan class=\"icon icon-link\"\u003e\u003c/span\u003e\u003c/a\u003e代理\u003c/h4\u003e\n\u003cp\u003e代理是一种有转发功能的应用程序, 它扮演了位于服务器和客户端 “中间人” 的角色, 接收由客户端发送的请求并转发给服务器, 同时也接收服务器返回的响应并转发给客户端.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/%E5%9B%BE%E8%A7%A3http/example-11.png\" alt=\"alt\"\u003e\u003c/p\u003e\n\u003cp\u003e代理服务器的基本行为就是接收客户端发送的请求后转发给其他服务器. 代理不改变请求 URI, 会直接发送给前方持有资源的目标服务器. 持有资源实体的服务器被称为源服务器. 从源服务器返回的响应经过代理服务器后再传给客户端.\u003c/p\u003e\n\u003cp\u003e使用代理服务器的理由: 利用缓存技术减少网络带宽的流量, 组织内部针对特定网站的访问控制, 以获取访问日志为主要目的等等.\u003c/p\u003e\n\u003cp\u003e代理有多种使用方法, 按两种基准分类\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e缓存代理\u003c/p\u003e\n\u003cp\u003e代理转发响应时, 缓存代理(Catching Proxy)会预先将资源的副本缓存在代理服务器上. 当代理再次接收到对相同资源的请求时, 就可以不从源服务器那里获取资源, 而是将之前缓存的资源作为响应返回.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e透明代理\u003c/p\u003e\n\u003cp\u003e转发请求或响应时, 不对报文做任何加工的代理类型被称为透明代理(Transparent Proxy). 反之, 对报文内容进行加工的代理被称为非透明代理.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch4 id=\"网关\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#网关\"\u003e\u003cspan class=\"icon icon-link\"\u003e\u003c/span\u003e\u003c/a\u003e网关\u003c/h4\u003e\n\u003cp\u003e网关是转发其他服务器通信数据的服务器, 接收从客户端发送来的请求时, 它就像自己拥有资源的源服务器一样对请求进行处理. 有时可能客户端都不会察觉, 自己的通信目标是一个网关.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/%E5%9B%BE%E8%A7%A3http/example-12.png\" alt=\"alt\"\u003e\u003c/p\u003e\n\u003cp\u003e网关的工作机制和代理十分相似. 而网关能使通信线路上的服务器提供非 HTTP 协议服务. 利用网关能提高通信的安全性, 因为可以在客户端与网关之间的通信路上加密以确保连接的安全. 比如, 网关可以连接数据库, 使用 SQL 语句查询数据.\u003c/p\u003e\n\u003ch4 id=\"隧道\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#隧道\"\u003e\u003cspan class=\"icon icon-link\"\u003e\u003c/span\u003e\u003c/a\u003e隧道\u003c/h4\u003e\n\u003cp\u003e隧道实在相隔甚远的客户端和服务器两者之前进行中转, 并保持双方通信连接的应用程序.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/%E5%9B%BE%E8%A7%A3http/example-13.png\" alt=\"alt\"\u003e\u003c/p\u003e\n\u003cp\u003e隧道可按要求建立起一条与其他服务器的通信线路, 届时使用 SSL 等加密手段进行通信. 隧道的目的是确保客户端能与服务器进行安全的通信. 隧道本身不会去解析 HTTP 请求. 也就是说, 请求保持原样中转给之后的服务器. 隧道会在通信双方断开连接时结束.\u003c/p\u003e\n\u003ch3 id=\"保存资源的缓存\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#保存资源的缓存\"\u003e\u003cspan class=\"icon icon-link\"\u003e\u003c/span\u003e\u003c/a\u003e保存资源的缓存\u003c/h3\u003e\n\u003cp\u003e缓存是指代理服务器或客户端本地磁盘内保存的资源副本. 利用缓存可减少对源服务器的访问, 因此也就节省了通信流量和通信时间.\u003c/p\u003e\n\u003cp\u003e缓存服务器是代理服务器的一种, 并归类在缓存代理类型中. 换句话说, 当代理转发从服务器返回的响应时, 代理服务器将会保存一份资源的副本.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/%E5%9B%BE%E8%A7%A3http/example-14.png\" alt=\"alt\"\u003e\u003c/p\u003e\n\u003cp\u003e缓存服务器的优势在于利用缓存可避免多次从源服务器转发资源. 因此客户端可就近从缓存服务器上获取资源, 而源服务器也不必多次处理相同的请求了.\u003c/p\u003e\n\u003ch4 id=\"缓存的有效期限\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#缓存的有效期限\"\u003e\u003cspan class=\"icon icon-link\"\u003e\u003c/span\u003e\u003c/a\u003e缓存的有效期限\u003c/h4\u003e\n\u003cp\u003e即便缓存服务器内有缓存, 也不能保证每次都会返回对同资源的请求. 因为这关系到被缓存的有效性问题. 当遇上源服务器上的资源更新时, 如果还是使用不便的缓存, 那就会演变成返回更新前的旧的资源. 即使存在缓存, 也会因为客户端的要求、缓存的有效期限等因素, 向源服务器确认资源的有效性. 若判断缓存失效, 缓存服务器将会再次从源服务器上获取新的资源.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/%E5%9B%BE%E8%A7%A3http/example-15.png\" alt=\"alt\"\u003e\u003c/p\u003e\n\u003ch4 id=\"客户端的缓存\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#客户端的缓存\"\u003e\u003cspan class=\"icon icon-link\"\u003e\u003c/span\u003e\u003c/a\u003e客户端的缓存\u003c/h4\u003e\n\u003cp\u003e缓存不仅可以存于缓存服务器内, 还可以存在客户端浏览器中. 客户端缓存一般被称为 临时网络文件(Temporary Internet File).\u003c/p\u003e\n\u003cp\u003e浏览器缓存如果有效, 就不必再向服务器请求相同的资源了, 可以直接从本地磁盘累读取. 另外, 和缓存服务器相同的一点是, 当判定缓存过期后, 会向源服务器确认资源的有效性. 若判断浏览器缓存失效, 浏览器会再次请求新资源.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/%E5%9B%BE%E8%A7%A3http/example-16.png\" alt=\"alt\"\u003e\u003c/p\u003e\n\u003ch2 id=\"http-首部\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#http-首部\"\u003e\u003cspan class=\"icon icon-link\"\u003e\u003c/span\u003e\u003c/a\u003eHTTP 首部\u003c/h2\u003e\n\u003cp\u003e\u003ca href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers\"\u003ehttps://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers\u003c/a\u003e\u003c/p\u003e\n\u003ch2 id=\"确保-web-安全的-https\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#确保-web-安全的-https\"\u003e\u003cspan class=\"icon icon-link\"\u003e\u003c/span\u003e\u003c/a\u003e确保 Web 安全的 HTTPS\u003c/h2\u003e\n\u003cp\u003e在 HTTP 协议中可能存在信息窃听或身份伪装等安全问题. 使用 HTTPS 通信机制可以有效的防止这些问题.\u003c/p\u003e\n\u003ch3 id=\"http-的缺点\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#http-的缺点\"\u003e\u003cspan class=\"icon icon-link\"\u003e\u003c/span\u003e\u003c/a\u003eHTTP 的缺点\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e通信使用明文(未加密), 内容可能遭到窃听\u003c/li\u003e\n\u003cli\u003e不验证通信方的身份, 因此可能遭遇伪装\u003c/li\u003e\n\u003cli\u003e无法证明报文的完整性, 所有有可能已遭篡改\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4 id=\"通信使用明文可能会被窃听\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#通信使用明文可能会被窃听\"\u003e\u003cspan class=\"icon icon-link\"\u003e\u003c/span\u003e\u003c/a\u003e通信使用明文可能会被窃听\u003c/h4\u003e\n\u003cp\u003e由于 HTTP 本身不具备加密的功能, 所以也无法做到对通信整体进行加密. 即 HTTP 报文使用明文的方式发送.\u003c/p\u003e\n\u003ch5 id=\"tcpip-是可能被窃听的网络\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#tcpip-是可能被窃听的网络\"\u003e\u003cspan class=\"icon icon-link\"\u003e\u003c/span\u003e\u003c/a\u003eTCP/IP 是可能被窃听的网络\u003c/h5\u003e\n\u003cp\u003e为什么通信时不加密是一个缺点? 这是因为按 TPC/IP 协议族的工作机制, 通信内容在所有的通信路线上都有可能遭到窥视.\u003c/p\u003e\n\u003cp\u003e即使已经过加密处理的通信, 也会被窥视到通信内容, 这点和未加密的通信是相同的. 只是说如果通信经过加密, 就有可能让人无法破解报文信息的含义, 当加密处理后的报文信息本身还是会被看到.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/%E5%9B%BE%E8%A7%A3http/example-17.png\" alt=\"alt\"\u003e\u003c/p\u003e\n\u003cp\u003e窃听相同段上的通信并非难事. 只需要收集在互联网上流动的数据包(帧)即可. 对于收集来的数据包的解析工作, 可交给抓包(Packet Capture) 或嗅探器(Sniffer) 工具.\u003c/p\u003e\n\u003ch5 id=\"加密处理防止被窃听\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#加密处理防止被窃听\"\u003e\u003cspan class=\"icon icon-link\"\u003e\u003c/span\u003e\u003c/a\u003e加密处理防止被窃听\u003c/h5\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e通信加密\u003c/p\u003e\n\u003cp\u003eHTTP 协议中没有加密机制, 但可以通过 SSL(Secure Socket Layer, 安全套接层)或 TLS(Transport Layer Security, 安全层传输协议)的组合使用, 加密 HTTP 的通信内容. 用 SSL 建立安全通信路线之后, 就可以在这条线路上进行 HTTP 通信了. 与 SSL 组合使用的 HTTP 被称为 HTTPS(HTTP Secure, 超文本传输安全协议) 或 HTTP over SSL.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e内容加密\u003c/p\u003e\n\u003cp\u003e对 HTTP 协议传输的内容本身加密, 即将 HTTP 报文里包含的内容进行加密处理(对报文主机进行加密, 报文首部信息未加密处理). 为了做到有效的内容加密, 前提是要求客户端和服务器同时具备加密和解密机制. 主要应用在 Web 服务中. 由于该方式不同于 SSL 或 TLS 将整个通信路线加密处理, 所以内容仍有被篡改的风险.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch4 id=\"不验证通信方的身份可能遭遇伪装\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#不验证通信方的身份可能遭遇伪装\"\u003e\u003cspan class=\"icon icon-link\"\u003e\u003c/span\u003e\u003c/a\u003e不验证通信方的身份可能遭遇伪装\u003c/h4\u003e\n\u003cp\u003eHTTP 协议中的请求和响应不会对通信方进行确认. 也就是说存在 “服务器是否就是发送请求中 URI 真正指定的主机, 返回的响应是否真的返回到实际提出请求的客户端” 等问题.\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e任何人都可以发起请求\u003c/p\u003e\n\u003cp\u003e服务器只要接收到请求, 不管对方是谁都会返回一个响应(但也仅限于发送端的 IP 地址和端口号没有被 Web 服务器设定限制访问的前提下), 因此会存在以下隐患\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e无法确定请求发送至目标的 Web 服务器是否是按真实意图返回响应的那台服务器. 有可能是已伪装 Web 服务器.\u003c/li\u003e\n\u003cli\u003e无法确定响应返回到的客户端是否是按真实意图接收响应的客户端. 有可能是已伪装的客户端.\u003c/li\u003e\n\u003cli\u003e无法确定正在通信的对方是否具备访问权限. 因为某些 Web 服务器上保存着重要信息, 只想发给特定用户通信的权限.\u003c/li\u003e\n\u003cli\u003e无法判定请求时来自何方、出自谁手.\u003c/li\u003e\n\u003cli\u003e即使是无意义的请求也会照单全手, 无法阻止海量请求下的 Dos 攻击(Denial of Service, 拒绝服务攻击).\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e查明对手的证书\u003c/p\u003e\n\u003cp\u003e虽然使用 HTTP 协议无法确定通信方, 但如果使用 SSL 则可以. SSL 不仅提供加密信息, 而且还使用了一种被称为证书的手段, 可用于确定对方身份. 证书由值的信任的第三方机构颁发, 用以证明服务器和客户端是实际存在的. 另外, 伪造证书从技术角度来说是一场困难的一件事情.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/%E5%9B%BE%E8%A7%A3http/example-18.png\" alt=\"alt\"\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch4 id=\"无法证明报文完整性\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#无法证明报文完整性\"\u003e\u003cspan class=\"icon icon-link\"\u003e\u003c/span\u003e\u003c/a\u003e无法证明报文完整性\u003c/h4\u003e\n\u003cp\u003e所谓完整性是指信息的准确度. 若无法证明其完整性, 通常也就意味着无法判断信息是否准确. 仅靠 HTTP 确保完整性是非常苦难的, 因此通过和其他协议组合来实现防止第三方的篡改.\u003c/p\u003e","tag":["Http"]}},"__N_SSG":true},"page":"/posts/[slug]","query":{"slug":"图解Http 阅读记录"},"buildId":"Rfvy9WK71nLCZ90Ws6Jh7","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>