<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="preload" href="/_next/static/media/569ce4b8f30dc480-s.p.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="preload" href="/_next/static/media/93f479601ee12b01-s.p.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="stylesheet" href="/_next/static/css/2626867bd1decdff.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-6281654836ffc620.js"/><script src="/_next/static/chunks/4bd1b696-498d627ab3bad20f.js" async=""></script><script src="/_next/static/chunks/684-52a97cd138b2ec10.js" async=""></script><script src="/_next/static/chunks/main-app-8a63285bca825cb3.js" async=""></script><script src="/_next/static/chunks/874-16716eedeadde879.js" async=""></script><script src="/_next/static/chunks/app/error-d036ecfd03716e30.js" async=""></script><script src="/_next/static/chunks/app/not-found-2113bbd7a2f55e8f.js" async=""></script><script src="/_next/static/chunks/app/loading-b73dd9bd22c3caa2.js" async=""></script><script src="/_next/static/chunks/766-eeb113df4f56c105.js" async=""></script><script src="/_next/static/chunks/app/(article)/layout-18bcffe355ed9a9b.js" async=""></script><script src="/_next/static/chunks/62-36d7af331e30e687.js" async=""></script><script src="/_next/static/chunks/app/(article)/posts/%5Bslug%5D/page-2ec56518ac6621da.js" async=""></script><meta name="next-size-adjust" content=""/><title>Ai.Haibara codes</title><meta name="description" content="LZS Blog"/><link rel="icon" href="/favicon.ico" type="image/x-icon" sizes="96x96"/><script>document.querySelectorAll('body link[rel="icon"], body link[rel="apple-touch-icon"]').forEach(el => document.head.appendChild(el))</script><script src="/_next/static/chunks/polyfills-42372ed130431b0a.js" noModule=""></script></head><body class="__variable_4d318d __variable_ea5f4b antialiased"><!--$--><html lang="en"><body class="__variable_4d318d __variable_ea5f4b antialiased"><div class="min-h-screen"><header class="text-white bg-black drop-shadow-2xl"><div class="mx-auto my-0 max-w-[960px] py-6 px-4 flex items-center"><div class="flex items-center"><img alt="Ai.Haibara" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class=" rounded-full" style="color:transparent" srcSet="/_next/image?url=%2Fassets%2Fblog%2Fauthors%2Fhaibara_2.jpg&amp;w=128&amp;q=75 1x, /_next/image?url=%2Fassets%2Fblog%2Fauthors%2Fhaibara_2.jpg&amp;w=256&amp;q=75 2x" src="/_next/image?url=%2Fassets%2Fblog%2Fauthors%2Fhaibara_2.jpg&amp;w=256&amp;q=75"/></div><div class="ml-6"><a class=" font-bold text-3xl" href="/">Ai.Haibara codes</a><div class="mt-2"><a class="p-1 rounded-sm text-xl mr-2 hover:border-b-2 border-lime-300" href="/">Home</a><a class="p-1 rounded-sm text-xl mr-2 hover:border-b-2 border-lime-300" href="/projects">Projects</a><a class="p-1 rounded-sm text-xl mr-2 hover:border-b-2 border-lime-300" href="/talks">Talks</a><a class="p-1 rounded-sm text-xl mr-2 hover:border-b-2 border-lime-300" href="/blogs">Blogs</a></div></div></div></header><main class="p-6 flex justify-center"><article><div class="flex justify-center font-[Arial] max-w-[864px] text-center"><h1 class="text-[2.5rem] font-bold bg-lime-300 px-5 py-2 rounded-sm text-shadow-lg leading-[1.1]">React中的受控组件与非受控组件</h1></div><time dateTime="2022-09-14" class="text-center block my-4 text-sm opacity-60">September	14, 2022</time><section class="markdown-body-jzman max-w-3xl"><h2 id="什么是受控组件和非受控组件"><a aria-hidden="true" tabindex="-1" href="#什么是受控组件和非受控组件"><span class="icon icon-link"></span></a>什么是受控组件和非受控组件?</h2>
<ol>
<li>
<p>非受控组件</p>
<pre><code class="hljs language-jsx"><span class="hljs-keyword">const</span> <span class="hljs-title class_">Input</span>: <span class="hljs-variable constant_">FC</span> = <span class="hljs-function">() =></span> {
  <span class="hljs-keyword">const</span> [value, setValue] = <span class="hljs-title function_">useState</span>(<span class="hljs-string">''</span>);

  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">input</span> <span class="hljs-attr">value</span>=<span class="hljs-string">{value}</span> <span class="hljs-attr">onChange</span>=<span class="hljs-string">{(e)</span> =></span> setValue(e.target.value)} /></span>;
};
</code></pre>
<p>首先我们看一段代码, 代码定义了一个自定义 <code>Input</code> 组件, 并且不接收任何 <code>props</code>. 所以该组件的 <code>value</code> 只能通过用户的操作来更改, 而不能通过代码去控制, 所以叫做 <strong>非受控组件</strong>.</p>
</li>
<li>
<p>受控组件</p>
<blockquote>
<p>在 HTML 中, 表单元素 (如&#x3C;input>、 &#x3C;textarea> 和 &#x3C;select>)通常自己维护 state, 并根据用户输入进行更新.而在 React 中, 可变状态 (mutable state)通常保存在组件的 state 属性中, 并且只能通过使用 setState()来更新.
我们可以把两者结合起来, 使 React 的 state 成为“唯一数据源”.渲染表单的 React 组件还控制着用户输入过程中表单发生的操作.被 React 以这种方式控制取值的表单输入元素就叫做“受控组件”.</p>
</blockquote>
<pre><code class="hljs language-tsx"> <span class="hljs-keyword">const</span> <span class="hljs-title class_">Input</span>:<span class="hljs-variable constant_">FC</span> = <span class="hljs-function">(<span class="hljs-params">{value:<span class="hljs-built_in">string</span>,  onChange:(val:<span class="hljs-built_in">string</span>) => <span class="hljs-built_in">void</span>}</span>) =></span> {
   <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">input</span> <span class="hljs-attr">value</span>=<span class="hljs-string">{value}</span> <span class="hljs-attr">onChange</span>=<span class="hljs-string">{e</span> =></span> onChange(e.target.value)}/></span>
 }
</code></pre>
<p>对之前的非受控 <code>Input</code> 组件的代码稍微做一点调整, 将它内部的状态改为 <code>props</code> 传入, 它就变成了受控组件, 因为此时 <code>Input</code> 组件的值取决于外部传递进来的 <code>props</code>.</p>
</li>
</ol>
<p>了解了这两个概念后, 我们思考一个问题, <code>ant-design</code> 中的 <code>Input</code> 组件是受控组件还是非受控组件?</p>
<p>答案是它既可以是受控组件, 也可以是非受控组件, 完全取决于项目中怎么去使用.</p>
<h2 id="如何实现"><a aria-hidden="true" tabindex="-1" href="#如何实现"><span class="icon icon-link"></span></a>如何实现?</h2>
<h3 id="最简单的方案-内外两个状态-手动同步"><a aria-hidden="true" tabindex="-1" href="#最简单的方案-内外两个状态-手动同步"><span class="icon icon-link"></span></a>最简单的方案: 内外两个状态, 手动同步</h3>
<p>考虑到实现成本的复杂度, 我们需要让组件逻辑在两种模式下, 尽可能的保持一致, 减少逻辑分支意味着更好的可维护性和可读性. 所以, 自然而然的, 我们可以很容易想到这个方案:</p>
<p><code>Child</code> 组件内部始终存在一个状态, 不管它处于哪种模式, 它都直接使用自己内部的状态. 而当它处于受控模式时, 我们让它的内部状态和 <code>Parent</code> 组件中的状态手动保持同步.</p>
<p>代码如下:</p>
<pre><code class="hljs language-tsx"><span class="hljs-keyword">const</span> <span class="hljs-title class_">Input</span>: <span class="hljs-title class_">React</span>.<span class="hljs-property">FC</span>&#x3C;{ <span class="hljs-attr">value</span>?: <span class="hljs-built_in">string</span>; <span class="hljs-attr">onChange</span>?: <span class="hljs-function">(<span class="hljs-params"><span class="hljs-attr">val</span>: <span class="hljs-built_in">string</span></span>) =></span> <span class="hljs-built_in">void</span> }> = <span class="hljs-function">(<span class="hljs-params">{
  value,
  onChange,
}</span>) =></span> {
  <span class="hljs-keyword">const</span> isControlled = value !== <span class="hljs-literal">undefined</span>;

  <span class="hljs-keyword">const</span> [innerValue, setInnerValue] = <span class="hljs-title function_">useState</span>(value);

  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =></span> {
    <span class="hljs-keyword">if</span> (isControlled) {
      <span class="hljs-title function_">setInnerValue</span>(value);
    }
  });

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">input</span>
      <span class="hljs-attr">value</span>=<span class="hljs-string">{innerValue}</span>
      <span class="hljs-attr">onChange</span>=<span class="hljs-string">{(e)</span> =></span> {
        if (!isControlled) {
          setInnerValue(e.target.value);
        }
        onChange(e.target.value);
      }}
    /></span>
  );
};
</code></pre>
<p>仔细看上面的代码, 我们会发现在受控模式下存在两个问题:</p>
<p>原子性: <code>Child</code> 内部状态的更新会比 <code>Parent</code> 组件晚一个渲染周期, 存在 <code>tearing</code> 的问题
性能:因为是在 <code>useEffect</code> 中通过 <code>setState</code> 来做的状态同步, 所以会额外的触发一次渲染, 存在性能问题
明确问题之后, 我们来逐个解决:</p>
<h3 id="原子性"><a aria-hidden="true" tabindex="-1" href="#原子性"><span class="icon icon-link"></span></a>原子性</h3>
<p>这个问题其实很好解决, 我们其实并不需要 Child 和 Parent 的状态保持非常严格的每时每刻都一致, 我们只需要判断, 如果组件此时处于受控模式, 那么直接使用来自外部的状态就可以了:</p>
<p>这样, 即便状态的同步是存在延迟的, 但是 Child 组件所真正使用到的值一定是最新的.</p>
<p>代码如下:</p>
<pre><code class="hljs language-tsx"><span class="hljs-keyword">const</span> <span class="hljs-title class_">Input</span>: <span class="hljs-title class_">React</span>.<span class="hljs-property">FC</span>&#x3C;{ <span class="hljs-attr">value</span>?: <span class="hljs-built_in">string</span>; <span class="hljs-attr">onChange</span>?: <span class="hljs-function">(<span class="hljs-params"><span class="hljs-attr">val</span>: <span class="hljs-built_in">string</span></span>) =></span> <span class="hljs-built_in">void</span> }> = <span class="hljs-function">(<span class="hljs-params">{
  value,
  onChange,
}</span>) =></span> {
  <span class="hljs-keyword">const</span> isControlled = value !== <span class="hljs-literal">undefined</span>;

  <span class="hljs-keyword">const</span> [innerValue, setInnerValue] = <span class="hljs-title function_">useState</span>(value);

  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =></span> {
    <span class="hljs-keyword">if</span> (isControlled) {
      <span class="hljs-title function_">setInnerValue</span>(value);
    }
  });

  <span class="hljs-keyword">const</span> finalValue = isControlled ? value : innerValue;

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">input</span>
      <span class="hljs-attr">value</span>=<span class="hljs-string">{finalValue}</span>
      <span class="hljs-attr">onChange</span>=<span class="hljs-string">{(e)</span> =></span> {
        setInnerValue(e.target.value);
        onChange(e.target.value);
      }}
    /></span>
  );
};
</code></pre>
<h3 id="性能"><a aria-hidden="true" tabindex="-1" href="#性能"><span class="icon icon-link"></span></a>性能</h3>
<p>因为我们是在 <code>useEffect</code> 去做状态同步的, 所以自然会额外的多触发一次 <code>Child</code> 组件的重渲染.如果 <code>Child</code> 组件比较简单的话, 那出现的性能影响可以忽略不计.但是对于一些复杂的组件 (例如 <code>Picker</code>), 多渲染一次带来的性能问题是比较严重的.</p>
<p>那有没有办法在 <code>Child</code> 组件的 <code>render</code> 阶段就直接更新 <code>value</code> 状态呢?</p>
<p>我们重新考虑一下这行 <code>useState</code> 的代码:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> [innerValue, setInnerValue] = <span class="hljs-title function_">useState</span>(value);
</code></pre>
<p>当我们创建这个 <code>State</code> 时? 我们的目的是什么? <code>State</code> 的本质是什么?</p>
<p>如果比较简单粗暴的分析, 我们可以把 <code>State</code> 拆成两部分:</p>
<p><code>State</code> 是用来存放数据的, 它让我们在组件的渲染函数之外, 可以“持久化”一些数据
<code>State</code> 的更新可以触发重新渲染, 因为 <code>React</code> 会感知 <code>State</code> 的更新
如果写一个公式的话, 可以写成:</p>
<p><code>State = 存放数据 + 触发重新渲染</code></p>
<p>而但就存放数据来看, 我们可以直接使用 Ref；同样, 如果只是需要触发重新渲染, 我们可以使用类似于 <code>setFlag({})</code> 或者 <code>setCount(v => v + 1)</code> 这样的强制方式 (虽然很蠢, 但想必 90% 的 React 开发者都曾经这么写过).</p>
<p>那我们根据这个推断来调整一下上面的公式:</p>
<p><code>State = Ref + forceUpdate()</code></p>
<p>我们已经非常接近了, 根据这个公式, 我们可以把 <code>Child</code> 组件中的 <code>State</code> 拆成一个 <code>Ref</code> 和一个 <code>forceUpdate</code> 函数:</p>
<p>这样一来, 我们就可以直接在 <code>render</code> 阶段直接更新 <code>ref</code> 的值了:</p>
<pre><code class="hljs language-tsx"><span class="hljs-keyword">const</span> <span class="hljs-title class_">Input</span>: <span class="hljs-title class_">React</span>.<span class="hljs-property">FC</span>&#x3C;{ <span class="hljs-attr">value</span>: <span class="hljs-built_in">string</span>; <span class="hljs-attr">onChange</span>: <span class="hljs-function">(<span class="hljs-params"><span class="hljs-attr">val</span>: <span class="hljs-built_in">string</span></span>) =></span> <span class="hljs-built_in">void</span> }> = <span class="hljs-function">(<span class="hljs-params">{
  value,
  onChange,
}</span>) =></span> {
  <span class="hljs-keyword">const</span> isControlled = value !== <span class="hljs-literal">undefined</span>;

  <span class="hljs-keyword">const</span> stateRef = useRef&#x3C;T | <span class="hljs-literal">undefined</span>>(value);

  <span class="hljs-keyword">const</span> [, setFlag] = <span class="hljs-title function_">useState</span>({});

  <span class="hljs-keyword">const</span> <span class="hljs-title function_">forceUpdate</span> = (<span class="hljs-params"></span>) => {
    <span class="hljs-title function_">setFlag</span>({});
  };

  <span class="hljs-keyword">const</span> finalValue = isControlled ? value : stateRef.<span class="hljs-property">current</span>;

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">input</span>
      <span class="hljs-attr">value</span>=<span class="hljs-string">{finalValue}</span>
      <span class="hljs-attr">onChange</span>=<span class="hljs-string">{(e)</span> =></span> {
        stateRef.current = e.target.value;
        forceUpdate();
        onChange(e.target.value);
      }}
    /></span>
  );
};
</code></pre>
<p>再回头看下代码, 会发现, 为什么还需要判断根据受控和非受控模式来使用不同的值呢? 既然 <code>stateRef.current</code> 一定是最新的值, 那么完全可以简化成 <code>Child</code> 组件永远使用内部存放的数据 (<code>Ref</code>):</p>
<pre><code class="hljs language-tsx"><span class="hljs-keyword">const</span> <span class="hljs-title class_">Input</span>: <span class="hljs-title class_">React</span>.<span class="hljs-property">FC</span>&#x3C;{ <span class="hljs-attr">value</span>: <span class="hljs-built_in">string</span>; <span class="hljs-attr">onChange</span>: <span class="hljs-function">(<span class="hljs-params"><span class="hljs-attr">val</span>: <span class="hljs-built_in">string</span></span>) =></span> <span class="hljs-built_in">void</span> }> = <span class="hljs-function">(<span class="hljs-params">{
  value,
  onChange,
}</span>) =></span> {
  <span class="hljs-keyword">const</span> isControlled = value !== <span class="hljs-literal">undefined</span>;

  <span class="hljs-keyword">const</span> stateRef = useRef&#x3C;T | <span class="hljs-literal">undefined</span>>(value);

  <span class="hljs-keyword">if</span> (isControlled) {
    stateRef.<span class="hljs-property">current</span> = props.<span class="hljs-property">value</span>;
  }
  <span class="hljs-keyword">const</span> [, setFlag] = <span class="hljs-title function_">useState</span>({});

  <span class="hljs-keyword">const</span> <span class="hljs-title function_">forceUpdate</span> = (<span class="hljs-params"></span>) => {
    <span class="hljs-title function_">setFlag</span>({});
  };

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">input</span>
      <span class="hljs-attr">value</span>=<span class="hljs-string">{finalValue}</span>
      <span class="hljs-attr">onChange</span>=<span class="hljs-string">{(e)</span> =></span> {
        stateRef.current = e.target.value;
        forceUpdate();
        onChange(e.target.value);
      }}
    /></span>
  );
};
</code></pre>
<h3 id="抽象与复用-usepropsvalue"><a aria-hidden="true" tabindex="-1" href="#抽象与复用-usepropsvalue"><span class="icon icon-link"></span></a>抽象与复用: usePropsValue</h3>
<p>上述代码仅实现了一个 <code>Input</code> 组件, 当需要定义其他组件时, 仍需要重复上述中的某些代码, 所以我们把核心代码抽离成一个自定义 <code>Hooks</code>, 同时完善一些细节. 代码如下:</p>
<pre><code class="hljs language-ts"><span class="hljs-keyword">import</span> { useUpdate } <span class="hljs-keyword">from</span> <span class="hljs-string">'ahooks'</span>;
<span class="hljs-keyword">import</span> { isFunction } <span class="hljs-keyword">from</span> <span class="hljs-string">'lodash-es'</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">SetStateAction</span>, useRef } <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">type</span> usePropsValueOptions&#x3C;T> = {
  <span class="hljs-attr">value</span>?: T;
  <span class="hljs-attr">defaultValue</span>?: T;
  <span class="hljs-attr">onChange</span>?: <span class="hljs-function">(<span class="hljs-params"><span class="hljs-attr">value</span>?: T</span>) =></span> <span class="hljs-built_in">void</span>;
};

<span class="hljs-keyword">const</span> usePropsValue = &#x3C;T>({
  value,
  defaultValue,
  onChange,
}: usePropsValueOptions&#x3C;T>): [
  T | <span class="hljs-literal">undefined</span>,
  <span class="hljs-function">(<span class="hljs-params"><span class="hljs-attr">v</span>: <span class="hljs-title class_">SetStateAction</span>&#x3C;T | <span class="hljs-literal">undefined</span>></span>) =></span> <span class="hljs-built_in">void</span>
] => {
  <span class="hljs-keyword">const</span> isControlled = value !== <span class="hljs-literal">undefined</span>;
  <span class="hljs-keyword">const</span> update = <span class="hljs-title function_">useUpdate</span>();
  <span class="hljs-keyword">const</span> stateRef = useRef&#x3C;T | <span class="hljs-literal">undefined</span>>(isControlled ? value : defaultValue);

  <span class="hljs-keyword">if</span> (isControlled) {
    stateRef.<span class="hljs-property">current</span> = value;
  }

  <span class="hljs-keyword">const</span> <span class="hljs-title function_">setState</span> = (<span class="hljs-params"><span class="hljs-attr">v</span>: <span class="hljs-title class_">SetStateAction</span>&#x3C;T | <span class="hljs-literal">undefined</span>></span>) => {
    <span class="hljs-keyword">const</span> nextValue = <span class="hljs-title function_">isFunction</span>(v) ? <span class="hljs-title function_">v</span>(stateRef.<span class="hljs-property">current</span>) : v;

    <span class="hljs-keyword">if</span> (nextValue === stateRef.<span class="hljs-property">current</span>) {
      <span class="hljs-keyword">return</span>;
    }

    stateRef.<span class="hljs-property">current</span> = nextValue;
    <span class="hljs-title function_">update</span>();
    onChange?.(nextValue);
  };
  <span class="hljs-keyword">return</span> [stateRef.<span class="hljs-property">current</span>, setState];
};

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> usePropsValue;
</code></pre>
<p>这样, 在各种组件中, 我们可以直接使用 <code>usePropsValue</code>, 用法和 <code>useState</code> 非常接近:</p>
<pre><code class="hljs language-ts"><span class="hljs-keyword">const</span> [internalValue, setInternalValue] = usePropsValue&#x3C;<span class="hljs-built_in">string</span>>({
  defaultValue,
  value,
  onChange,
});

<span class="hljs-keyword">return</span> (
  <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">input</span>
    <span class="hljs-attr">value</span>=<span class="hljs-string">{internalValue}</span>
    <span class="hljs-attr">onChange</span>=<span class="hljs-string">{(e)</span> =></span> {
      setInternalValue(e.target.value);
    }}
  /></span>
);
</code></pre></section></article><!--$--><!--/$--><!--$--><!--/$--></main><footer class="bg-neutral-50 border-t border-neutral-200 text-center text-xs opacity-50 py-4">© 2022 - <!-- -->2025<a rel="noopener noreferrer" class="hover:underline hover:bg-indigo" href="https://github.com/LZS911" target="_blank">, LZS_911</a>, build with<!-- --> <a rel="noopener noreferrer" class="underline hover:bg-indigo" href="https://nextjs.org/" target="_blank">Next.js</a> <!-- -->and<!-- --> <a rel="noopener noreferrer" class="underline hover:bg-indigo" href="https://pages.github.com/?(null)" target="_blank">GitHub Pages</a></footer></div><a class="fixed right-2 top-1/2 transform -translate-y-1/2 z-50 group" href="/practice"><div class="w-10 h-10 bg-black hover:bg-gray-800 text-white rounded-full flex items-center justify-center shadow-[0_0_15px_rgba(0,0,0,0.2)] transition-all duration-300 ease-out hover:scale-110 hover:rotate-[360deg] hover:shadow-[0_0_20px_rgba(0,0,0,0.3)] backdrop-blur-sm bg-opacity-80"><svg class="w-5 h-5 transition-transform duration-300 ease-out group-hover:scale-90" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M14.752 11.168l-3.197-2.132A1 1 0 0010 9.87v4.263a1 1 0 001.555.832l3.197-2.132a1 1 0 000-1.664z"></path><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg></div></a><!--/$--><script src="/_next/static/chunks/webpack-6281654836ffc620.js" async=""></script></body></html><script>(self.__next_f=self.__next_f||[]).push([0])</script><script>self.__next_f.push([1,"1:\"$Sreact.fragment\"\n2:I[7555,[],\"\"]\n3:I[1901,[\"874\",\"static/chunks/874-16716eedeadde879.js\",\"39\",\"static/chunks/app/error-d036ecfd03716e30.js\"],\"default\"]\n4:I[1295,[],\"\"]\n5:I[9543,[\"874\",\"static/chunks/874-16716eedeadde879.js\",\"345\",\"static/chunks/app/not-found-2113bbd7a2f55e8f.js\"],\"default\"]\n8:I[9665,[],\"MetadataBoundary\"]\na:I[9665,[],\"OutletBoundary\"]\nd:I[4911,[],\"AsyncMetadataOutlet\"]\nf:I[8460,[\"209\",\"static/chunks/app/loading-b73dd9bd22c3caa2.js\"],\"default\"]\n10:I[9665,[],\"ViewportBoundary\"]\n12:I[6614,[],\"\"]\n:HL[\"/_next/static/media/569ce4b8f30dc480-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n:HL[\"/_next/static/media/93f479601ee12b01-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n:HL[\"/_next/static/css/2626867bd1decdff.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"0:{\"P\":null,\"b\":\"9kXAH1_uuo8MLlXW_w4TX\",\"p\":\"\",\"c\":[\"\",\"posts\",\"React%E4%B8%AD%E7%9A%84%E5%8F%97%E6%8E%A7%E7%BB%84%E4%BB%B6%E4%B8%8E%E9%9D%9E%E5%8F%97%E6%8E%A7%E7%BB%84%E4%BB%B6\"],\"i\":false,\"f\":[[[\"\",{\"children\":[\"(article)\",{\"children\":[\"posts\",{\"children\":[[\"slug\",\"React%E4%B8%AD%E7%9A%84%E5%8F%97%E6%8E%A7%E7%BB%84%E4%BB%B6%E4%B8%8E%E9%9D%9E%E5%8F%97%E6%8E%A7%E7%BB%84%E4%BB%B6\",\"d\"],{\"children\":[\"__PAGE__\",{}]}]}]}]},\"$undefined\",\"$undefined\",true],[\"\",[\"$\",\"$1\",\"c\",{\"children\":[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/2626867bd1decdff.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}]],[\"$\",\"html\",null,{\"lang\":\"en\",\"children\":[\"$\",\"body\",null,{\"className\":\"__variable_4d318d __variable_ea5f4b antialiased\",\"children\":[\"$\",\"$L2\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$3\",\"errorStyles\":[],\"errorScripts\":[],\"template\":[\"$\",\"$L4\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[[\"$\",\"$L5\",null,{}],[]],\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]}]}]]}],{\"children\":[\"(article)\",[\"$\",\"$1\",\"c\",{\"children\":[null,\"$L6\"]}],{\"children\":[\"posts\",[\"$\",\"$1\",\"c\",{\"children\":[null,[\"$\",\"$L2\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L4\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]]}],{\"children\":[[\"slug\",\"React%E4%B8%AD%E7%9A%84%E5%8F%97%E6%8E%A7%E7%BB%84%E4%BB%B6%E4%B8%8E%E9%9D%9E%E5%8F%97%E6%8E%A7%E7%BB%84%E4%BB%B6\",\"d\"],[\"$\",\"$1\",\"c\",{\"children\":[null,[\"$\",\"$L2\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L4\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]]}],{\"children\":[\"__PAGE__\",[\"$\",\"$1\",\"c\",{\"children\":[\"$L7\",[\"$\",\"$L8\",null,{\"children\":\"$L9\"}],null,[\"$\",\"$La\",null,{\"children\":[\"$Lb\",\"$Lc\",[\"$\",\"$Ld\",null,{\"promise\":\"$@e\"}]]}]]}],{},null,false]},null,false]},null,false]},null,false]},[[\"$\",\"$Lf\",\"l\",{}],[],[]],false],[\"$\",\"$1\",\"h\",{\"children\":[null,[\"$\",\"$1\",\"hYd2SVUfx8vhJfg_JwAba\",{\"children\":[[\"$\",\"$L10\",null,{\"children\":\"$L11\"}],[\"$\",\"meta\",null,{\"name\":\"next-size-adjust\",\"content\":\"\"}]]}],null]}],false]],\"m\":\"$undefined\",\"G\":[\"$12\",\"$undefined\"],\"s\":false,\"S\":true}\n"])</script><script>self.__next_f.push([1,"13:I[8565,[\"874\",\"static/chunks/874-16716eedeadde879.js\",\"766\",\"static/chunks/766-eeb113df4f56c105.js\",\"651\",\"static/chunks/app/(article)/layout-18bcffe355ed9a9b.js\"],\"default\"]\n14:I[7832,[\"874\",\"static/chunks/874-16716eedeadde879.js\",\"766\",\"static/chunks/766-eeb113df4f56c105.js\",\"651\",\"static/chunks/app/(article)/layout-18bcffe355ed9a9b.js\"],\"default\"]\n15:\"$Sreact.suspense\"\n16:I[4911,[],\"AsyncMetadata\"]\n6:[\"$\",\"html\",null,{\"lang\":\"en\",\"children\":[\"$\",\"body\",null,{\"className\":\"__variable_4d318d __variable_ea5f4b antialiased\",\"children\":[[\"$\",\"div\",null,{\"className\":\"min-h-screen\",\"children\":[[\"$\",\"$L13\",null,{}],[\"$\",\"main\",null,{\"className\":\"p-6 flex justify-center\",\"children\":[\"$\",\"$L2\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L4\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]}],[\"$\",\"footer\",null,{\"className\":\"bg-neutral-50 border-t border-neutral-200 text-center text-xs opacity-50 py-4\",\"children\":[\"© 2022 - \",2025,[\"$\",\"a\",null,{\"rel\":\"noopener noreferrer\",\"className\":\"hover:underline hover:bg-indigo\",\"href\":\"https://github.com/LZS911\",\"target\":\"_blank\",\"children\":\", LZS_911\"}],\", build with\",\" \",[\"$\",\"a\",null,{\"rel\":\"noopener noreferrer\",\"className\":\"underline hover:bg-indigo\",\"href\":\"https://nextjs.org/\",\"target\":\"_blank\",\"children\":\"Next.js\"}],\" \",\"and\",\" \",[\"$\",\"a\",null,{\"rel\":\"noopener noreferrer\",\"className\":\"underline hover:bg-indigo\",\"href\":\"https://pages.github.com/?(null)\",\"target\":\"_blank\",\"children\":\"GitHub Pages\"}]]}]]}],[\"$\",\"$L14\",null,{\"href\":\"/practice\"}]]}]}]\n9:[\"$\",\"$15\",null,{\"fallback\":null,\"children\":[\"$\",\"$L16\",null,{\"promise\":\"$@17\"}]}]\n"])</script><script>self.__next_f.push([1,"c:null\n"])</script><script>self.__next_f.push([1,"18:I[5099,[\"766\",\"static/chunks/766-eeb113df4f56c105.js\",\"62\",\"static/chunks/62-36d7af331e30e687.js\",\"520\",\"static/chunks/app/(article)/posts/%5Bslug%5D/page-2ec56518ac6621da.js\"],\"ThemeLoader\"]\n19:T47b8,"])</script><script>self.__next_f.push([1,"\u003ch2 id=\"什么是受控组件和非受控组件\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#什么是受控组件和非受控组件\"\u003e\u003cspan class=\"icon icon-link\"\u003e\u003c/span\u003e\u003c/a\u003e什么是受控组件和非受控组件?\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e非受控组件\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-jsx\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eInput\u003c/span\u003e: \u003cspan class=\"hljs-variable constant_\"\u003eFC\u003c/span\u003e = \u003cspan class=\"hljs-function\"\u003e() =\u003e\u003c/span\u003e {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e [value, setValue] = \u003cspan class=\"hljs-title function_\"\u003euseState\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e''\u003c/span\u003e);\n\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003einput\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003evalue\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{value}\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eonChange\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{(e)\u003c/span\u003e =\u003e\u003c/span\u003e setValue(e.target.value)} /\u003e\u003c/span\u003e;\n};\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e首先我们看一段代码, 代码定义了一个自定义 \u003ccode\u003eInput\u003c/code\u003e 组件, 并且不接收任何 \u003ccode\u003eprops\u003c/code\u003e. 所以该组件的 \u003ccode\u003evalue\u003c/code\u003e 只能通过用户的操作来更改, 而不能通过代码去控制, 所以叫做 \u003cstrong\u003e非受控组件\u003c/strong\u003e.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e受控组件\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e在 HTML 中, 表单元素 (如\u0026#x3C;input\u003e、 \u0026#x3C;textarea\u003e 和 \u0026#x3C;select\u003e)通常自己维护 state, 并根据用户输入进行更新.而在 React 中, 可变状态 (mutable state)通常保存在组件的 state 属性中, 并且只能通过使用 setState()来更新.\n我们可以把两者结合起来, 使 React 的 state 成为“唯一数据源”.渲染表单的 React 组件还控制着用户输入过程中表单发生的操作.被 React 以这种方式控制取值的表单输入元素就叫做“受控组件”.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-tsx\"\u003e \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eInput\u003c/span\u003e:\u003cspan class=\"hljs-variable constant_\"\u003eFC\u003c/span\u003e = \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003e{value:\u003cspan class=\"hljs-built_in\"\u003estring\u003c/span\u003e,  onChange:(val:\u003cspan class=\"hljs-built_in\"\u003estring\u003c/span\u003e) =\u003e \u003cspan class=\"hljs-built_in\"\u003evoid\u003c/span\u003e}\u003c/span\u003e) =\u003e\u003c/span\u003e {\n   \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003einput\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003evalue\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{value}\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eonChange\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{e\u003c/span\u003e =\u003e\u003c/span\u003e onChange(e.target.value)}/\u003e\u003c/span\u003e\n }\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e对之前的非受控 \u003ccode\u003eInput\u003c/code\u003e 组件的代码稍微做一点调整, 将它内部的状态改为 \u003ccode\u003eprops\u003c/code\u003e 传入, 它就变成了受控组件, 因为此时 \u003ccode\u003eInput\u003c/code\u003e 组件的值取决于外部传递进来的 \u003ccode\u003eprops\u003c/code\u003e.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e了解了这两个概念后, 我们思考一个问题, \u003ccode\u003eant-design\u003c/code\u003e 中的 \u003ccode\u003eInput\u003c/code\u003e 组件是受控组件还是非受控组件?\u003c/p\u003e\n\u003cp\u003e答案是它既可以是受控组件, 也可以是非受控组件, 完全取决于项目中怎么去使用.\u003c/p\u003e\n\u003ch2 id=\"如何实现\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#如何实现\"\u003e\u003cspan class=\"icon icon-link\"\u003e\u003c/span\u003e\u003c/a\u003e如何实现?\u003c/h2\u003e\n\u003ch3 id=\"最简单的方案-内外两个状态-手动同步\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#最简单的方案-内外两个状态-手动同步\"\u003e\u003cspan class=\"icon icon-link\"\u003e\u003c/span\u003e\u003c/a\u003e最简单的方案: 内外两个状态, 手动同步\u003c/h3\u003e\n\u003cp\u003e考虑到实现成本的复杂度, 我们需要让组件逻辑在两种模式下, 尽可能的保持一致, 减少逻辑分支意味着更好的可维护性和可读性. 所以, 自然而然的, 我们可以很容易想到这个方案:\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eChild\u003c/code\u003e 组件内部始终存在一个状态, 不管它处于哪种模式, 它都直接使用自己内部的状态. 而当它处于受控模式时, 我们让它的内部状态和 \u003ccode\u003eParent\u003c/code\u003e 组件中的状态手动保持同步.\u003c/p\u003e\n\u003cp\u003e代码如下:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-tsx\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eInput\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eReact\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eFC\u003c/span\u003e\u0026#x3C;{ \u003cspan class=\"hljs-attr\"\u003evalue\u003c/span\u003e?: \u003cspan class=\"hljs-built_in\"\u003estring\u003c/span\u003e; \u003cspan class=\"hljs-attr\"\u003eonChange\u003c/span\u003e?: \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003e\u003cspan class=\"hljs-attr\"\u003eval\u003c/span\u003e: \u003cspan class=\"hljs-built_in\"\u003estring\u003c/span\u003e\u003c/span\u003e) =\u003e\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003evoid\u003c/span\u003e }\u003e = \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003e{\n  value,\n  onChange,\n}\u003c/span\u003e) =\u003e\u003c/span\u003e {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e isControlled = value !== \u003cspan class=\"hljs-literal\"\u003eundefined\u003c/span\u003e;\n\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e [innerValue, setInnerValue] = \u003cspan class=\"hljs-title function_\"\u003euseState\u003c/span\u003e(value);\n\n  \u003cspan class=\"hljs-title function_\"\u003euseEffect\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e() =\u003e\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (isControlled) {\n      \u003cspan class=\"hljs-title function_\"\u003esetInnerValue\u003c/span\u003e(value);\n    }\n  });\n\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e (\n    \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003einput\u003c/span\u003e\n      \u003cspan class=\"hljs-attr\"\u003evalue\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{innerValue}\u003c/span\u003e\n      \u003cspan class=\"hljs-attr\"\u003eonChange\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{(e)\u003c/span\u003e =\u003e\u003c/span\u003e {\n        if (!isControlled) {\n          setInnerValue(e.target.value);\n        }\n        onChange(e.target.value);\n      }}\n    /\u003e\u003c/span\u003e\n  );\n};\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e仔细看上面的代码, 我们会发现在受控模式下存在两个问题:\u003c/p\u003e\n\u003cp\u003e原子性: \u003ccode\u003eChild\u003c/code\u003e 内部状态的更新会比 \u003ccode\u003eParent\u003c/code\u003e 组件晚一个渲染周期, 存在 \u003ccode\u003etearing\u003c/code\u003e 的问题\n性能:因为是在 \u003ccode\u003euseEffect\u003c/code\u003e 中通过 \u003ccode\u003esetState\u003c/code\u003e 来做的状态同步, 所以会额外的触发一次渲染, 存在性能问题\n明确问题之后, 我们来逐个解决:\u003c/p\u003e\n\u003ch3 id=\"原子性\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#原子性\"\u003e\u003cspan class=\"icon icon-link\"\u003e\u003c/span\u003e\u003c/a\u003e原子性\u003c/h3\u003e\n\u003cp\u003e这个问题其实很好解决, 我们其实并不需要 Child 和 Parent 的状态保持非常严格的每时每刻都一致, 我们只需要判断, 如果组件此时处于受控模式, 那么直接使用来自外部的状态就可以了:\u003c/p\u003e\n\u003cp\u003e这样, 即便状态的同步是存在延迟的, 但是 Child 组件所真正使用到的值一定是最新的.\u003c/p\u003e\n\u003cp\u003e代码如下:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-tsx\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eInput\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eReact\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eFC\u003c/span\u003e\u0026#x3C;{ \u003cspan class=\"hljs-attr\"\u003evalue\u003c/span\u003e?: \u003cspan class=\"hljs-built_in\"\u003estring\u003c/span\u003e; \u003cspan class=\"hljs-attr\"\u003eonChange\u003c/span\u003e?: \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003e\u003cspan class=\"hljs-attr\"\u003eval\u003c/span\u003e: \u003cspan class=\"hljs-built_in\"\u003estring\u003c/span\u003e\u003c/span\u003e) =\u003e\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003evoid\u003c/span\u003e }\u003e = \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003e{\n  value,\n  onChange,\n}\u003c/span\u003e) =\u003e\u003c/span\u003e {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e isControlled = value !== \u003cspan class=\"hljs-literal\"\u003eundefined\u003c/span\u003e;\n\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e [innerValue, setInnerValue] = \u003cspan class=\"hljs-title function_\"\u003euseState\u003c/span\u003e(value);\n\n  \u003cspan class=\"hljs-title function_\"\u003euseEffect\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e() =\u003e\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (isControlled) {\n      \u003cspan class=\"hljs-title function_\"\u003esetInnerValue\u003c/span\u003e(value);\n    }\n  });\n\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e finalValue = isControlled ? value : innerValue;\n\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e (\n    \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003einput\u003c/span\u003e\n      \u003cspan class=\"hljs-attr\"\u003evalue\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{finalValue}\u003c/span\u003e\n      \u003cspan class=\"hljs-attr\"\u003eonChange\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{(e)\u003c/span\u003e =\u003e\u003c/span\u003e {\n        setInnerValue(e.target.value);\n        onChange(e.target.value);\n      }}\n    /\u003e\u003c/span\u003e\n  );\n};\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"性能\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#性能\"\u003e\u003cspan class=\"icon icon-link\"\u003e\u003c/span\u003e\u003c/a\u003e性能\u003c/h3\u003e\n\u003cp\u003e因为我们是在 \u003ccode\u003euseEffect\u003c/code\u003e 去做状态同步的, 所以自然会额外的多触发一次 \u003ccode\u003eChild\u003c/code\u003e 组件的重渲染.如果 \u003ccode\u003eChild\u003c/code\u003e 组件比较简单的话, 那出现的性能影响可以忽略不计.但是对于一些复杂的组件 (例如 \u003ccode\u003ePicker\u003c/code\u003e), 多渲染一次带来的性能问题是比较严重的.\u003c/p\u003e\n\u003cp\u003e那有没有办法在 \u003ccode\u003eChild\u003c/code\u003e 组件的 \u003ccode\u003erender\u003c/code\u003e 阶段就直接更新 \u003ccode\u003evalue\u003c/code\u003e 状态呢?\u003c/p\u003e\n\u003cp\u003e我们重新考虑一下这行 \u003ccode\u003euseState\u003c/code\u003e 的代码:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e [innerValue, setInnerValue] = \u003cspan class=\"hljs-title function_\"\u003euseState\u003c/span\u003e(value);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e当我们创建这个 \u003ccode\u003eState\u003c/code\u003e 时? 我们的目的是什么? \u003ccode\u003eState\u003c/code\u003e 的本质是什么?\u003c/p\u003e\n\u003cp\u003e如果比较简单粗暴的分析, 我们可以把 \u003ccode\u003eState\u003c/code\u003e 拆成两部分:\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eState\u003c/code\u003e 是用来存放数据的, 它让我们在组件的渲染函数之外, 可以“持久化”一些数据\n\u003ccode\u003eState\u003c/code\u003e 的更新可以触发重新渲染, 因为 \u003ccode\u003eReact\u003c/code\u003e 会感知 \u003ccode\u003eState\u003c/code\u003e 的更新\n如果写一个公式的话, 可以写成:\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eState = 存放数据 + 触发重新渲染\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e而但就存放数据来看, 我们可以直接使用 Ref；同样, 如果只是需要触发重新渲染, 我们可以使用类似于 \u003ccode\u003esetFlag({})\u003c/code\u003e 或者 \u003ccode\u003esetCount(v =\u003e v + 1)\u003c/code\u003e 这样的强制方式 (虽然很蠢, 但想必 90% 的 React 开发者都曾经这么写过).\u003c/p\u003e\n\u003cp\u003e那我们根据这个推断来调整一下上面的公式:\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eState = Ref + forceUpdate()\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e我们已经非常接近了, 根据这个公式, 我们可以把 \u003ccode\u003eChild\u003c/code\u003e 组件中的 \u003ccode\u003eState\u003c/code\u003e 拆成一个 \u003ccode\u003eRef\u003c/code\u003e 和一个 \u003ccode\u003eforceUpdate\u003c/code\u003e 函数:\u003c/p\u003e\n\u003cp\u003e这样一来, 我们就可以直接在 \u003ccode\u003erender\u003c/code\u003e 阶段直接更新 \u003ccode\u003eref\u003c/code\u003e 的值了:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-tsx\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eInput\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eReact\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eFC\u003c/span\u003e\u0026#x3C;{ \u003cspan class=\"hljs-attr\"\u003evalue\u003c/span\u003e: \u003cspan class=\"hljs-built_in\"\u003estring\u003c/span\u003e; \u003cspan class=\"hljs-attr\"\u003eonChange\u003c/span\u003e: \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003e\u003cspan class=\"hljs-attr\"\u003eval\u003c/span\u003e: \u003cspan class=\"hljs-built_in\"\u003estring\u003c/span\u003e\u003c/span\u003e) =\u003e\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003evoid\u003c/span\u003e }\u003e = \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003e{\n  value,\n  onChange,\n}\u003c/span\u003e) =\u003e\u003c/span\u003e {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e isControlled = value !== \u003cspan class=\"hljs-literal\"\u003eundefined\u003c/span\u003e;\n\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e stateRef = useRef\u0026#x3C;T | \u003cspan class=\"hljs-literal\"\u003eundefined\u003c/span\u003e\u003e(value);\n\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e [, setFlag] = \u003cspan class=\"hljs-title function_\"\u003euseState\u003c/span\u003e({});\n\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eforceUpdate\u003c/span\u003e = (\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) =\u003e {\n    \u003cspan class=\"hljs-title function_\"\u003esetFlag\u003c/span\u003e({});\n  };\n\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e finalValue = isControlled ? value : stateRef.\u003cspan class=\"hljs-property\"\u003ecurrent\u003c/span\u003e;\n\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e (\n    \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003einput\u003c/span\u003e\n      \u003cspan class=\"hljs-attr\"\u003evalue\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{finalValue}\u003c/span\u003e\n      \u003cspan class=\"hljs-attr\"\u003eonChange\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{(e)\u003c/span\u003e =\u003e\u003c/span\u003e {\n        stateRef.current = e.target.value;\n        forceUpdate();\n        onChange(e.target.value);\n      }}\n    /\u003e\u003c/span\u003e\n  );\n};\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e再回头看下代码, 会发现, 为什么还需要判断根据受控和非受控模式来使用不同的值呢? 既然 \u003ccode\u003estateRef.current\u003c/code\u003e 一定是最新的值, 那么完全可以简化成 \u003ccode\u003eChild\u003c/code\u003e 组件永远使用内部存放的数据 (\u003ccode\u003eRef\u003c/code\u003e):\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-tsx\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eInput\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eReact\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eFC\u003c/span\u003e\u0026#x3C;{ \u003cspan class=\"hljs-attr\"\u003evalue\u003c/span\u003e: \u003cspan class=\"hljs-built_in\"\u003estring\u003c/span\u003e; \u003cspan class=\"hljs-attr\"\u003eonChange\u003c/span\u003e: \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003e\u003cspan class=\"hljs-attr\"\u003eval\u003c/span\u003e: \u003cspan class=\"hljs-built_in\"\u003estring\u003c/span\u003e\u003c/span\u003e) =\u003e\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003evoid\u003c/span\u003e }\u003e = \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003e{\n  value,\n  onChange,\n}\u003c/span\u003e) =\u003e\u003c/span\u003e {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e isControlled = value !== \u003cspan class=\"hljs-literal\"\u003eundefined\u003c/span\u003e;\n\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e stateRef = useRef\u0026#x3C;T | \u003cspan class=\"hljs-literal\"\u003eundefined\u003c/span\u003e\u003e(value);\n\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (isControlled) {\n    stateRef.\u003cspan class=\"hljs-property\"\u003ecurrent\u003c/span\u003e = props.\u003cspan class=\"hljs-property\"\u003evalue\u003c/span\u003e;\n  }\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e [, setFlag] = \u003cspan class=\"hljs-title function_\"\u003euseState\u003c/span\u003e({});\n\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eforceUpdate\u003c/span\u003e = (\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) =\u003e {\n    \u003cspan class=\"hljs-title function_\"\u003esetFlag\u003c/span\u003e({});\n  };\n\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e (\n    \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003einput\u003c/span\u003e\n      \u003cspan class=\"hljs-attr\"\u003evalue\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{finalValue}\u003c/span\u003e\n      \u003cspan class=\"hljs-attr\"\u003eonChange\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{(e)\u003c/span\u003e =\u003e\u003c/span\u003e {\n        stateRef.current = e.target.value;\n        forceUpdate();\n        onChange(e.target.value);\n      }}\n    /\u003e\u003c/span\u003e\n  );\n};\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"抽象与复用-usepropsvalue\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#抽象与复用-usepropsvalue\"\u003e\u003cspan class=\"icon icon-link\"\u003e\u003c/span\u003e\u003c/a\u003e抽象与复用: usePropsValue\u003c/h3\u003e\n\u003cp\u003e上述代码仅实现了一个 \u003ccode\u003eInput\u003c/code\u003e 组件, 当需要定义其他组件时, 仍需要重复上述中的某些代码, 所以我们把核心代码抽离成一个自定义 \u003ccode\u003eHooks\u003c/code\u003e, 同时完善一些细节. 代码如下:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-ts\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { useUpdate } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'ahooks'\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { isFunction } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'lodash-es'\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { \u003cspan class=\"hljs-title class_\"\u003eSetStateAction\u003c/span\u003e, useRef } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'react'\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003etype\u003c/span\u003e usePropsValueOptions\u0026#x3C;T\u003e = {\n  \u003cspan class=\"hljs-attr\"\u003evalue\u003c/span\u003e?: T;\n  \u003cspan class=\"hljs-attr\"\u003edefaultValue\u003c/span\u003e?: T;\n  \u003cspan class=\"hljs-attr\"\u003eonChange\u003c/span\u003e?: \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003e\u003cspan class=\"hljs-attr\"\u003evalue\u003c/span\u003e?: T\u003c/span\u003e) =\u003e\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003evoid\u003c/span\u003e;\n};\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e usePropsValue = \u0026#x3C;T\u003e({\n  value,\n  defaultValue,\n  onChange,\n}: usePropsValueOptions\u0026#x3C;T\u003e): [\n  T | \u003cspan class=\"hljs-literal\"\u003eundefined\u003c/span\u003e,\n  \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003e\u003cspan class=\"hljs-attr\"\u003ev\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eSetStateAction\u003c/span\u003e\u0026#x3C;T | \u003cspan class=\"hljs-literal\"\u003eundefined\u003c/span\u003e\u003e\u003c/span\u003e) =\u003e\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003evoid\u003c/span\u003e\n] =\u003e {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e isControlled = value !== \u003cspan class=\"hljs-literal\"\u003eundefined\u003c/span\u003e;\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e update = \u003cspan class=\"hljs-title function_\"\u003euseUpdate\u003c/span\u003e();\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e stateRef = useRef\u0026#x3C;T | \u003cspan class=\"hljs-literal\"\u003eundefined\u003c/span\u003e\u003e(isControlled ? value : defaultValue);\n\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (isControlled) {\n    stateRef.\u003cspan class=\"hljs-property\"\u003ecurrent\u003c/span\u003e = value;\n  }\n\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003esetState\u003c/span\u003e = (\u003cspan class=\"hljs-params\"\u003e\u003cspan class=\"hljs-attr\"\u003ev\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eSetStateAction\u003c/span\u003e\u0026#x3C;T | \u003cspan class=\"hljs-literal\"\u003eundefined\u003c/span\u003e\u003e\u003c/span\u003e) =\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e nextValue = \u003cspan class=\"hljs-title function_\"\u003eisFunction\u003c/span\u003e(v) ? \u003cspan class=\"hljs-title function_\"\u003ev\u003c/span\u003e(stateRef.\u003cspan class=\"hljs-property\"\u003ecurrent\u003c/span\u003e) : v;\n\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (nextValue === stateRef.\u003cspan class=\"hljs-property\"\u003ecurrent\u003c/span\u003e) {\n      \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e;\n    }\n\n    stateRef.\u003cspan class=\"hljs-property\"\u003ecurrent\u003c/span\u003e = nextValue;\n    \u003cspan class=\"hljs-title function_\"\u003eupdate\u003c/span\u003e();\n    onChange?.(nextValue);\n  };\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e [stateRef.\u003cspan class=\"hljs-property\"\u003ecurrent\u003c/span\u003e, setState];\n};\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e usePropsValue;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e这样, 在各种组件中, 我们可以直接使用 \u003ccode\u003eusePropsValue\u003c/code\u003e, 用法和 \u003ccode\u003euseState\u003c/code\u003e 非常接近:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-ts\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e [internalValue, setInternalValue] = usePropsValue\u0026#x3C;\u003cspan class=\"hljs-built_in\"\u003estring\u003c/span\u003e\u003e({\n  defaultValue,\n  value,\n  onChange,\n});\n\n\u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e (\n  \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003einput\u003c/span\u003e\n    \u003cspan class=\"hljs-attr\"\u003evalue\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{internalValue}\u003c/span\u003e\n    \u003cspan class=\"hljs-attr\"\u003eonChange\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{(e)\u003c/span\u003e =\u003e\u003c/span\u003e {\n      setInternalValue(e.target.value);\n    }}\n  /\u003e\u003c/span\u003e\n);\n\u003c/code\u003e\u003c/pre\u003e"])</script><script>self.__next_f.push([1,"7:[\"$\",\"article\",null,{\"children\":[[\"$\",\"div\",null,{\"className\":\"flex justify-center font-[Arial] max-w-[864px] text-center\",\"children\":[\"$\",\"h1\",null,{\"className\":\"text-[2.5rem] font-bold bg-lime-300 px-5 py-2 rounded-sm text-shadow-lg leading-[1.1]\",\"children\":\"React中的受控组件与非受控组件\"}]}],[\"$\",\"time\",null,{\"dateTime\":\"2022-09-14\",\"className\":\"text-center block my-4 text-sm opacity-60\",\"children\":\"September\\t14, 2022\"}],[null,[\"$\",\"$L18\",null,{\"theme\":\"jzman\"}],[\"$\",\"section\",null,{\"className\":\"markdown-body-jzman max-w-3xl\",\"dangerouslySetInnerHTML\":{\"__html\":\"$19\"}}]],null]}]\n"])</script><script>self.__next_f.push([1,"11:[[\"$\",\"meta\",\"0\",{\"charSet\":\"utf-8\"}],[\"$\",\"meta\",\"1\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}]]\nb:null\n"])</script><script>self.__next_f.push([1,"17:{\"metadata\":[[\"$\",\"title\",\"0\",{\"children\":\"Ai.Haibara codes\"}],[\"$\",\"meta\",\"1\",{\"name\":\"description\",\"content\":\"LZS Blog\"}],[\"$\",\"link\",\"2\",{\"rel\":\"icon\",\"href\":\"/favicon.ico\",\"type\":\"image/x-icon\",\"sizes\":\"96x96\"}]],\"error\":null,\"digest\":\"$undefined\"}\ne:{\"metadata\":\"$17:metadata\",\"error\":null,\"digest\":\"$undefined\"}\n"])</script></body></html>