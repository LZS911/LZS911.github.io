<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><link rel="apple-touch-icon" sizes="180x180" href="/favicon/apple-touch-icon.png"/><link rel="icon" type="image/png" sizes="32x32" href="/favicon/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="16x16" href="/favicon/favicon-16x16.png"/><link rel="manifest" href="/favicon/site.webmanifest"/><link rel="mask-icon" href="/favicon/safari-pinned-tab.svg" color="#000000"/><link rel="shortcut icon" href="/favicon/favicon.ico"/><meta name="msapplication-TileColor" content="#000000"/><meta name="msapplication-config" content="/favicon/browserconfig.xml"/><meta name="theme-color" content="#000"/><link rel="alternate" type="application/rss+xml" href="/feed.xml"/><meta property="og:image" content="https://og-image.vercel.app/Next.js%20Blog%20Starter%20Example.png?theme=light&amp;md=1&amp;fontSize=100px&amp;images=https%3A%2F%2Fassets.vercel.com%2Fimage%2Fupload%2Ffront%2Fassets%2Fdesign%2Fnextjs-black-logo.svg"/><title>React中的受控组件与非受控组件 | Ai.Haibara codes</title><meta name="next-head-count" content="14"/><link rel="preload" href="/_next/static/css/4d9faa1c82c5289e.css" as="style"/><link rel="stylesheet" href="/_next/static/css/4d9faa1c82c5289e.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-8fa1640cc84ba8fe.js" defer=""></script><script src="/_next/static/chunks/framework-3b5a00d5d7e8d93b.js" defer=""></script><script src="/_next/static/chunks/main-59a90320855f5cf5.js" defer=""></script><script src="/_next/static/chunks/pages/_app-a2603426f792f9a7.js" defer=""></script><script src="/_next/static/chunks/799-575b46febca3af7d.js" defer=""></script><script src="/_next/static/chunks/399-cac0cd8ed02bf02a.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bslug%5D-ca05212d4081d62f.js" defer=""></script><script src="/_next/static/VnknnfSJtfZQLZ3OGiCHi/_buildManifest.js" defer=""></script><script src="/_next/static/VnknnfSJtfZQLZ3OGiCHi/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="min-h-screen"><header class="text-white bg-black drop-shadow-2xl"><div class="mx-auto my-0 max-w-[960px] py-6 px-4 flex items-center"><div class="flex items-center"><img alt="Ai.Haibara" src="/assets/blog/authors/haibara_2.jpg" width="100" height="100" decoding="async" data-nimg="1" class=" rounded-full" loading="lazy" style="color:transparent"/></div><div class="ml-6"><a class=" font-bold text-3xl" href="/">Ai.Haibara codes</a><div class="mt-2"><a class="p-1 rounded-sm text-xl mr-2 hover:border-b-2 border-indigo" href="/">Home</a><a class="p-1 rounded-sm text-xl mr-2 hover:border-b-2 border-indigo" href="/projects">Projects</a><a class="p-1 rounded-sm text-xl mr-2 hover:border-b-2 border-indigo" href="/talks">Talks</a><a class="p-1 rounded-sm text-xl mr-2 hover:border-b-2 border-indigo" href="/blogs">Blogs</a></div></div></div></header><main class="p-6 flex justify-center"><article><div class="flex justify-center font-[Arial]"><h1 class="text-5xl font-bold bg-indigo px-5 py-2 rounded-sm text-shadow-lg leading-[1.1]">React中的受控组件与非受控组件</h1></div><time dateTime="2022-09-14" class="text-center block my-4 text-sm opacity-60">September	14, 2022</time><section><div class="markdown-body-jzman max-w-3xl"><h2 id="什么是受控组件和非受控组件"><a aria-hidden="true" tabindex="-1" href="#什么是受控组件和非受控组件"><span class="icon icon-link"></span></a>什么是受控组件和非受控组件?</h2>
<ol>
<li>
<p>非受控组件</p>
<pre><code class="language-jsx">const Input: FC = () => {
  const [value, setValue] = useState('');

  return &#x3C;input value={value} onChange={(e) => setValue(e.target.value)} />;
};
</code></pre>
<p>首先我们看一段代码, 代码定义了一个自定义 <code>Input</code> 组件, 并且不接收任何 <code>props</code>. 所以该组件的 <code>value</code> 只能通过用户的操作来更改, 而不能通过代码去控制, 所以叫做 <strong>非受控组件</strong>.</p>
</li>
<li>
<p>受控组件</p>
<blockquote>
<p>在 HTML 中, 表单元素 (如&#x3C;input>、 &#x3C;textarea> 和 &#x3C;select>)通常自己维护 state, 并根据用户输入进行更新.而在 React 中, 可变状态 (mutable state)通常保存在组件的 state 属性中, 并且只能通过使用 setState()来更新.
我们可以把两者结合起来, 使 React 的 state 成为“唯一数据源”.渲染表单的 React 组件还控制着用户输入过程中表单发生的操作.被 React 以这种方式控制取值的表单输入元素就叫做“受控组件”.</p>
</blockquote>
<pre><code class="language-tsx"> const Input:FC = ({value:string,  onChange:(val:string) => void}) => {
   return &#x3C;input value={value} onChange={e => onChange(e.target.value)}/>
 }
</code></pre>
<p>对之前的非受控 <code>Input</code> 组件的代码稍微做一点调整, 将它内部的状态改为 <code>props</code> 传入, 它就变成了受控组件, 因为此时 <code>Input</code> 组件的值取决于外部传递进来的 <code>props</code>.</p>
</li>
</ol>
<p>了解了这两个概念后, 我们思考一个问题, <code>ant-design</code> 中的 <code>Input</code> 组件是受控组件还是非受控组件?</p>
<p>答案是它既可以是受控组件, 也可以是非受控组件, 完全取决于项目中怎么去使用.</p>
<h2 id="如何实现"><a aria-hidden="true" tabindex="-1" href="#如何实现"><span class="icon icon-link"></span></a>如何实现?</h2>
<h3 id="最简单的方案-内外两个状态-手动同步"><a aria-hidden="true" tabindex="-1" href="#最简单的方案-内外两个状态-手动同步"><span class="icon icon-link"></span></a>最简单的方案: 内外两个状态, 手动同步</h3>
<p>考虑到实现成本的复杂度, 我们需要让组件逻辑在两种模式下, 尽可能的保持一致, 减少逻辑分支意味着更好的可维护性和可读性. 所以, 自然而然的, 我们可以很容易想到这个方案:</p>
<p><code>Child</code> 组件内部始终存在一个状态, 不管它处于哪种模式, 它都直接使用自己内部的状态. 而当它处于受控模式时, 我们让它的内部状态和 <code>Parent</code> 组件中的状态手动保持同步.</p>
<p>代码如下:</p>
<pre><code class="language-tsx">const Input: React.FC&#x3C;{ value?: string; onChange?: (val: string) => void }> = ({
  value,
  onChange,
}) => {
  const isControlled = value !== undefined;

  const [innerValue, setInnerValue] = useState(value);

  useEffect(() => {
    if (isControlled) {
      setInnerValue(value);
    }
  });

  return (
    &#x3C;input
      value={innerValue}
      onChange={(e) => {
        if (!isControlled) {
          setInnerValue(e.target.value);
        }
        onChange(e.target.value);
      }}
    />
  );
};
</code></pre>
<p>仔细看上面的代码, 我们会发现在受控模式下存在两个问题:</p>
<p>原子性: <code>Child</code> 内部状态的更新会比 <code>Parent</code> 组件晚一个渲染周期, 存在 <code>tearing</code> 的问题
性能:因为是在 <code>useEffect</code> 中通过 <code>setState</code> 来做的状态同步, 所以会额外的触发一次渲染, 存在性能问题
明确问题之后, 我们来逐个解决:</p>
<h3 id="原子性"><a aria-hidden="true" tabindex="-1" href="#原子性"><span class="icon icon-link"></span></a>原子性</h3>
<p>这个问题其实很好解决, 我们其实并不需要 Child 和 Parent 的状态保持非常严格的每时每刻都一致, 我们只需要判断, 如果组件此时处于受控模式, 那么直接使用来自外部的状态就可以了:</p>
<p>这样, 即便状态的同步是存在延迟的, 但是 Child 组件所真正使用到的值一定是最新的.</p>
<p>代码如下:</p>
<pre><code class="language-tsx">const Input: React.FC&#x3C;{ value?: string; onChange?: (val: string) => void }> = ({
  value,
  onChange,
}) => {
  const isControlled = value !== undefined;

  const [innerValue, setInnerValue] = useState(value);

  useEffect(() => {
    if (isControlled) {
      setInnerValue(value);
    }
  });

  const finalValue = isControlled ? value : innerValue;

  return (
    &#x3C;input
      value={finalValue}
      onChange={(e) => {
        setInnerValue(e.target.value);
        onChange(e.target.value);
      }}
    />
  );
};
</code></pre>
<h3 id="性能"><a aria-hidden="true" tabindex="-1" href="#性能"><span class="icon icon-link"></span></a>性能</h3>
<p>因为我们是在 <code>useEffect</code> 去做状态同步的, 所以自然会额外的多触发一次 <code>Child</code> 组件的重渲染.如果 <code>Child</code> 组件比较简单的话, 那出现的性能影响可以忽略不计.但是对于一些复杂的组件 (例如 <code>Picker</code>), 多渲染一次带来的性能问题是比较严重的.</p>
<p>那有没有办法在 <code>Child</code> 组件的 <code>render</code> 阶段就直接更新 <code>value</code> 状态呢?</p>
<p>我们重新考虑一下这行 <code>useState</code> 的代码:</p>
<pre><code class="language-js">const [innerValue, setInnerValue] = useState(value);
</code></pre>
<p>当我们创建这个 <code>State</code> 时? 我们的目的是什么? <code>State</code> 的本质是什么?</p>
<p>如果比较简单粗暴的分析, 我们可以把 <code>State</code> 拆成两部分:</p>
<p><code>State</code> 是用来存放数据的, 它让我们在组件的渲染函数之外, 可以“持久化”一些数据
<code>State</code> 的更新可以触发重新渲染, 因为 <code>React</code> 会感知 <code>State</code> 的更新
如果写一个公式的话, 可以写成:</p>
<p><code>State = 存放数据 + 触发重新渲染</code></p>
<p>而但就存放数据来看, 我们可以直接使用 Ref；同样, 如果只是需要触发重新渲染, 我们可以使用类似于 <code>setFlag({})</code> 或者 <code>setCount(v => v + 1)</code> 这样的强制方式 (虽然很蠢, 但想必 90% 的 React 开发者都曾经这么写过).</p>
<p>那我们根据这个推断来调整一下上面的公式:</p>
<p><code>State = Ref + forceUpdate()</code></p>
<p>我们已经非常接近了, 根据这个公式, 我们可以把 <code>Child</code> 组件中的 <code>State</code> 拆成一个 <code>Ref</code> 和一个 <code>forceUpdate</code> 函数:</p>
<p>这样一来, 我们就可以直接在 <code>render</code> 阶段直接更新 <code>ref</code> 的值了:</p>
<pre><code class="language-tsx">const Input: React.FC&#x3C;{ value: string; onChange: (val: string) => void }> = ({
  value,
  onChange,
}) => {
  const isControlled = value !== undefined;

  const stateRef = useRef&#x3C;T | undefined>(value);

  const [, setFlag] = useState({});

  const forceUpdate = () => {
    setFlag({});
  };

  const finalValue = isControlled ? value : stateRef.current;

  return (
    &#x3C;input
      value={finalValue}
      onChange={(e) => {
        stateRef.current = e.target.value;
        forceUpdate();
        onChange(e.target.value);
      }}
    />
  );
};
</code></pre>
<p>再回头看下代码, 会发现, 为什么还需要判断根据受控和非受控模式来使用不同的值呢? 既然 <code>stateRef.current</code> 一定是最新的值, 那么完全可以简化成 <code>Child</code> 组件永远使用内部存放的数据 (<code>Ref</code>):</p>
<pre><code class="language-tsx">const Input: React.FC&#x3C;{ value: string; onChange: (val: string) => void }> = ({
  value,
  onChange,
}) => {
  const isControlled = value !== undefined;

  const stateRef = useRef&#x3C;T | undefined>(value);

  if (isControlled) {
    stateRef.current = props.value;
  }
  const [, setFlag] = useState({});

  const forceUpdate = () => {
    setFlag({});
  };

  return (
    &#x3C;input
      value={finalValue}
      onChange={(e) => {
        stateRef.current = e.target.value;
        forceUpdate();
        onChange(e.target.value);
      }}
    />
  );
};
</code></pre>
<h3 id="抽象与复用-usepropsvalue"><a aria-hidden="true" tabindex="-1" href="#抽象与复用-usepropsvalue"><span class="icon icon-link"></span></a>抽象与复用: usePropsValue</h3>
<p>上述代码仅实现了一个 <code>Input</code> 组件, 当需要定义其他组件时, 仍需要重复上述中的某些代码, 所以我们把核心代码抽离成一个自定义 <code>Hooks</code>, 同时完善一些细节. 代码如下:</p>
<pre><code class="language-ts">import { useUpdate } from 'ahooks';
import { isFunction } from 'lodash-es';
import { SetStateAction, useRef } from 'react';
export type usePropsValueOptions&#x3C;T> = {
  value?: T;
  defaultValue?: T;
  onChange?: (value?: T) => void;
};

const usePropsValue = &#x3C;T>({
  value,
  defaultValue,
  onChange,
}: usePropsValueOptions&#x3C;T>): [
  T | undefined,
  (v: SetStateAction&#x3C;T | undefined>) => void
] => {
  const isControlled = value !== undefined;
  const update = useUpdate();
  const stateRef = useRef&#x3C;T | undefined>(isControlled ? value : defaultValue);

  if (isControlled) {
    stateRef.current = value;
  }

  const setState = (v: SetStateAction&#x3C;T | undefined>) => {
    const nextValue = isFunction(v) ? v(stateRef.current) : v;

    if (nextValue === stateRef.current) {
      return;
    }

    stateRef.current = nextValue;
    update();
    onChange?.(nextValue);
  };
  return [stateRef.current, setState];
};

export default usePropsValue;
</code></pre>
<p>这样, 在各种组件中, 我们可以直接使用 <code>usePropsValue</code>, 用法和 <code>useState</code> 非常接近:</p>
<pre><code class="language-ts">const [internalValue, setInternalValue] = usePropsValue&#x3C;string>({
  defaultValue,
  value,
  onChange,
});

return (
  &#x3C;input
    value={internalValue}
    onChange={(e) => {
      setInternalValue(e.target.value);
    }}
  />
);
</code></pre></div></section></article></main><footer class="bg-neutral-50 border-t border-neutral-200 text-center text-xs opacity-50 py-4">© 2022,<!-- --> <a rel="noopener noreferrer" class="hover:underline hover:bg-indigo" href="https://github.com/LZS911" target="_blank">LZS_911</a>, build with<!-- --> <a rel="noopener noreferrer" class="underline hover:bg-indigo" href="https://nextjs.org/" target="_blank">Next.js</a> <!-- -->and<!-- --> <a rel="noopener noreferrer" class="underline hover:bg-indigo" href="https://pages.github.com/?(null)" target="_blank">GitHub Pages</a></footer></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"React中的受控组件与非受控组件","date":"2022-09-14","slug":"React中的受控组件与非受控组件","author":"LZS_911","content":"\u003ch2 id=\"什么是受控组件和非受控组件\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#什么是受控组件和非受控组件\"\u003e\u003cspan class=\"icon icon-link\"\u003e\u003c/span\u003e\u003c/a\u003e什么是受控组件和非受控组件?\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e非受控组件\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-jsx\"\u003econst Input: FC = () =\u003e {\n  const [value, setValue] = useState('');\n\n  return \u0026#x3C;input value={value} onChange={(e) =\u003e setValue(e.target.value)} /\u003e;\n};\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e首先我们看一段代码, 代码定义了一个自定义 \u003ccode\u003eInput\u003c/code\u003e 组件, 并且不接收任何 \u003ccode\u003eprops\u003c/code\u003e. 所以该组件的 \u003ccode\u003evalue\u003c/code\u003e 只能通过用户的操作来更改, 而不能通过代码去控制, 所以叫做 \u003cstrong\u003e非受控组件\u003c/strong\u003e.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e受控组件\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e在 HTML 中, 表单元素 (如\u0026#x3C;input\u003e、 \u0026#x3C;textarea\u003e 和 \u0026#x3C;select\u003e)通常自己维护 state, 并根据用户输入进行更新.而在 React 中, 可变状态 (mutable state)通常保存在组件的 state 属性中, 并且只能通过使用 setState()来更新.\n我们可以把两者结合起来, 使 React 的 state 成为“唯一数据源”.渲染表单的 React 组件还控制着用户输入过程中表单发生的操作.被 React 以这种方式控制取值的表单输入元素就叫做“受控组件”.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cpre\u003e\u003ccode class=\"language-tsx\"\u003e const Input:FC = ({value:string,  onChange:(val:string) =\u003e void}) =\u003e {\n   return \u0026#x3C;input value={value} onChange={e =\u003e onChange(e.target.value)}/\u003e\n }\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e对之前的非受控 \u003ccode\u003eInput\u003c/code\u003e 组件的代码稍微做一点调整, 将它内部的状态改为 \u003ccode\u003eprops\u003c/code\u003e 传入, 它就变成了受控组件, 因为此时 \u003ccode\u003eInput\u003c/code\u003e 组件的值取决于外部传递进来的 \u003ccode\u003eprops\u003c/code\u003e.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e了解了这两个概念后, 我们思考一个问题, \u003ccode\u003eant-design\u003c/code\u003e 中的 \u003ccode\u003eInput\u003c/code\u003e 组件是受控组件还是非受控组件?\u003c/p\u003e\n\u003cp\u003e答案是它既可以是受控组件, 也可以是非受控组件, 完全取决于项目中怎么去使用.\u003c/p\u003e\n\u003ch2 id=\"如何实现\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#如何实现\"\u003e\u003cspan class=\"icon icon-link\"\u003e\u003c/span\u003e\u003c/a\u003e如何实现?\u003c/h2\u003e\n\u003ch3 id=\"最简单的方案-内外两个状态-手动同步\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#最简单的方案-内外两个状态-手动同步\"\u003e\u003cspan class=\"icon icon-link\"\u003e\u003c/span\u003e\u003c/a\u003e最简单的方案: 内外两个状态, 手动同步\u003c/h3\u003e\n\u003cp\u003e考虑到实现成本的复杂度, 我们需要让组件逻辑在两种模式下, 尽可能的保持一致, 减少逻辑分支意味着更好的可维护性和可读性. 所以, 自然而然的, 我们可以很容易想到这个方案:\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eChild\u003c/code\u003e 组件内部始终存在一个状态, 不管它处于哪种模式, 它都直接使用自己内部的状态. 而当它处于受控模式时, 我们让它的内部状态和 \u003ccode\u003eParent\u003c/code\u003e 组件中的状态手动保持同步.\u003c/p\u003e\n\u003cp\u003e代码如下:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-tsx\"\u003econst Input: React.FC\u0026#x3C;{ value?: string; onChange?: (val: string) =\u003e void }\u003e = ({\n  value,\n  onChange,\n}) =\u003e {\n  const isControlled = value !== undefined;\n\n  const [innerValue, setInnerValue] = useState(value);\n\n  useEffect(() =\u003e {\n    if (isControlled) {\n      setInnerValue(value);\n    }\n  });\n\n  return (\n    \u0026#x3C;input\n      value={innerValue}\n      onChange={(e) =\u003e {\n        if (!isControlled) {\n          setInnerValue(e.target.value);\n        }\n        onChange(e.target.value);\n      }}\n    /\u003e\n  );\n};\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e仔细看上面的代码, 我们会发现在受控模式下存在两个问题:\u003c/p\u003e\n\u003cp\u003e原子性: \u003ccode\u003eChild\u003c/code\u003e 内部状态的更新会比 \u003ccode\u003eParent\u003c/code\u003e 组件晚一个渲染周期, 存在 \u003ccode\u003etearing\u003c/code\u003e 的问题\n性能:因为是在 \u003ccode\u003euseEffect\u003c/code\u003e 中通过 \u003ccode\u003esetState\u003c/code\u003e 来做的状态同步, 所以会额外的触发一次渲染, 存在性能问题\n明确问题之后, 我们来逐个解决:\u003c/p\u003e\n\u003ch3 id=\"原子性\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#原子性\"\u003e\u003cspan class=\"icon icon-link\"\u003e\u003c/span\u003e\u003c/a\u003e原子性\u003c/h3\u003e\n\u003cp\u003e这个问题其实很好解决, 我们其实并不需要 Child 和 Parent 的状态保持非常严格的每时每刻都一致, 我们只需要判断, 如果组件此时处于受控模式, 那么直接使用来自外部的状态就可以了:\u003c/p\u003e\n\u003cp\u003e这样, 即便状态的同步是存在延迟的, 但是 Child 组件所真正使用到的值一定是最新的.\u003c/p\u003e\n\u003cp\u003e代码如下:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-tsx\"\u003econst Input: React.FC\u0026#x3C;{ value?: string; onChange?: (val: string) =\u003e void }\u003e = ({\n  value,\n  onChange,\n}) =\u003e {\n  const isControlled = value !== undefined;\n\n  const [innerValue, setInnerValue] = useState(value);\n\n  useEffect(() =\u003e {\n    if (isControlled) {\n      setInnerValue(value);\n    }\n  });\n\n  const finalValue = isControlled ? value : innerValue;\n\n  return (\n    \u0026#x3C;input\n      value={finalValue}\n      onChange={(e) =\u003e {\n        setInnerValue(e.target.value);\n        onChange(e.target.value);\n      }}\n    /\u003e\n  );\n};\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"性能\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#性能\"\u003e\u003cspan class=\"icon icon-link\"\u003e\u003c/span\u003e\u003c/a\u003e性能\u003c/h3\u003e\n\u003cp\u003e因为我们是在 \u003ccode\u003euseEffect\u003c/code\u003e 去做状态同步的, 所以自然会额外的多触发一次 \u003ccode\u003eChild\u003c/code\u003e 组件的重渲染.如果 \u003ccode\u003eChild\u003c/code\u003e 组件比较简单的话, 那出现的性能影响可以忽略不计.但是对于一些复杂的组件 (例如 \u003ccode\u003ePicker\u003c/code\u003e), 多渲染一次带来的性能问题是比较严重的.\u003c/p\u003e\n\u003cp\u003e那有没有办法在 \u003ccode\u003eChild\u003c/code\u003e 组件的 \u003ccode\u003erender\u003c/code\u003e 阶段就直接更新 \u003ccode\u003evalue\u003c/code\u003e 状态呢?\u003c/p\u003e\n\u003cp\u003e我们重新考虑一下这行 \u003ccode\u003euseState\u003c/code\u003e 的代码:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-js\"\u003econst [innerValue, setInnerValue] = useState(value);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e当我们创建这个 \u003ccode\u003eState\u003c/code\u003e 时? 我们的目的是什么? \u003ccode\u003eState\u003c/code\u003e 的本质是什么?\u003c/p\u003e\n\u003cp\u003e如果比较简单粗暴的分析, 我们可以把 \u003ccode\u003eState\u003c/code\u003e 拆成两部分:\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eState\u003c/code\u003e 是用来存放数据的, 它让我们在组件的渲染函数之外, 可以“持久化”一些数据\n\u003ccode\u003eState\u003c/code\u003e 的更新可以触发重新渲染, 因为 \u003ccode\u003eReact\u003c/code\u003e 会感知 \u003ccode\u003eState\u003c/code\u003e 的更新\n如果写一个公式的话, 可以写成:\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eState = 存放数据 + 触发重新渲染\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e而但就存放数据来看, 我们可以直接使用 Ref；同样, 如果只是需要触发重新渲染, 我们可以使用类似于 \u003ccode\u003esetFlag({})\u003c/code\u003e 或者 \u003ccode\u003esetCount(v =\u003e v + 1)\u003c/code\u003e 这样的强制方式 (虽然很蠢, 但想必 90% 的 React 开发者都曾经这么写过).\u003c/p\u003e\n\u003cp\u003e那我们根据这个推断来调整一下上面的公式:\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eState = Ref + forceUpdate()\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e我们已经非常接近了, 根据这个公式, 我们可以把 \u003ccode\u003eChild\u003c/code\u003e 组件中的 \u003ccode\u003eState\u003c/code\u003e 拆成一个 \u003ccode\u003eRef\u003c/code\u003e 和一个 \u003ccode\u003eforceUpdate\u003c/code\u003e 函数:\u003c/p\u003e\n\u003cp\u003e这样一来, 我们就可以直接在 \u003ccode\u003erender\u003c/code\u003e 阶段直接更新 \u003ccode\u003eref\u003c/code\u003e 的值了:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-tsx\"\u003econst Input: React.FC\u0026#x3C;{ value: string; onChange: (val: string) =\u003e void }\u003e = ({\n  value,\n  onChange,\n}) =\u003e {\n  const isControlled = value !== undefined;\n\n  const stateRef = useRef\u0026#x3C;T | undefined\u003e(value);\n\n  const [, setFlag] = useState({});\n\n  const forceUpdate = () =\u003e {\n    setFlag({});\n  };\n\n  const finalValue = isControlled ? value : stateRef.current;\n\n  return (\n    \u0026#x3C;input\n      value={finalValue}\n      onChange={(e) =\u003e {\n        stateRef.current = e.target.value;\n        forceUpdate();\n        onChange(e.target.value);\n      }}\n    /\u003e\n  );\n};\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e再回头看下代码, 会发现, 为什么还需要判断根据受控和非受控模式来使用不同的值呢? 既然 \u003ccode\u003estateRef.current\u003c/code\u003e 一定是最新的值, 那么完全可以简化成 \u003ccode\u003eChild\u003c/code\u003e 组件永远使用内部存放的数据 (\u003ccode\u003eRef\u003c/code\u003e):\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-tsx\"\u003econst Input: React.FC\u0026#x3C;{ value: string; onChange: (val: string) =\u003e void }\u003e = ({\n  value,\n  onChange,\n}) =\u003e {\n  const isControlled = value !== undefined;\n\n  const stateRef = useRef\u0026#x3C;T | undefined\u003e(value);\n\n  if (isControlled) {\n    stateRef.current = props.value;\n  }\n  const [, setFlag] = useState({});\n\n  const forceUpdate = () =\u003e {\n    setFlag({});\n  };\n\n  return (\n    \u0026#x3C;input\n      value={finalValue}\n      onChange={(e) =\u003e {\n        stateRef.current = e.target.value;\n        forceUpdate();\n        onChange(e.target.value);\n      }}\n    /\u003e\n  );\n};\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"抽象与复用-usepropsvalue\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#抽象与复用-usepropsvalue\"\u003e\u003cspan class=\"icon icon-link\"\u003e\u003c/span\u003e\u003c/a\u003e抽象与复用: usePropsValue\u003c/h3\u003e\n\u003cp\u003e上述代码仅实现了一个 \u003ccode\u003eInput\u003c/code\u003e 组件, 当需要定义其他组件时, 仍需要重复上述中的某些代码, 所以我们把核心代码抽离成一个自定义 \u003ccode\u003eHooks\u003c/code\u003e, 同时完善一些细节. 代码如下:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ts\"\u003eimport { useUpdate } from 'ahooks';\nimport { isFunction } from 'lodash-es';\nimport { SetStateAction, useRef } from 'react';\nexport type usePropsValueOptions\u0026#x3C;T\u003e = {\n  value?: T;\n  defaultValue?: T;\n  onChange?: (value?: T) =\u003e void;\n};\n\nconst usePropsValue = \u0026#x3C;T\u003e({\n  value,\n  defaultValue,\n  onChange,\n}: usePropsValueOptions\u0026#x3C;T\u003e): [\n  T | undefined,\n  (v: SetStateAction\u0026#x3C;T | undefined\u003e) =\u003e void\n] =\u003e {\n  const isControlled = value !== undefined;\n  const update = useUpdate();\n  const stateRef = useRef\u0026#x3C;T | undefined\u003e(isControlled ? value : defaultValue);\n\n  if (isControlled) {\n    stateRef.current = value;\n  }\n\n  const setState = (v: SetStateAction\u0026#x3C;T | undefined\u003e) =\u003e {\n    const nextValue = isFunction(v) ? v(stateRef.current) : v;\n\n    if (nextValue === stateRef.current) {\n      return;\n    }\n\n    stateRef.current = nextValue;\n    update();\n    onChange?.(nextValue);\n  };\n  return [stateRef.current, setState];\n};\n\nexport default usePropsValue;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e这样, 在各种组件中, 我们可以直接使用 \u003ccode\u003eusePropsValue\u003c/code\u003e, 用法和 \u003ccode\u003euseState\u003c/code\u003e 非常接近:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ts\"\u003econst [internalValue, setInternalValue] = usePropsValue\u0026#x3C;string\u003e({\n  defaultValue,\n  value,\n  onChange,\n});\n\nreturn (\n  \u0026#x3C;input\n    value={internalValue}\n    onChange={(e) =\u003e {\n      setInternalValue(e.target.value);\n    }}\n  /\u003e\n);\n\u003c/code\u003e\u003c/pre\u003e","ogImage":{"url":"/assets/blog/image/cover.jpg"},"coverImage":"/assets/blog/image/cover.jpg","theme":"jzman","tag":["React"]}},"__N_SSG":true},"page":"/posts/[slug]","query":{"slug":"React中的受控组件与非受控组件"},"buildId":"VnknnfSJtfZQLZ3OGiCHi","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>