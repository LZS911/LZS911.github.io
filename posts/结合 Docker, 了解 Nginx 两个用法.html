<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="preload" href="/_next/static/media/569ce4b8f30dc480-s.p.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="preload" href="/_next/static/media/93f479601ee12b01-s.p.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="stylesheet" href="/_next/static/css/2626867bd1decdff.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-6281654836ffc620.js"/><script src="/_next/static/chunks/4bd1b696-498d627ab3bad20f.js" async=""></script><script src="/_next/static/chunks/684-52a97cd138b2ec10.js" async=""></script><script src="/_next/static/chunks/main-app-8a63285bca825cb3.js" async=""></script><script src="/_next/static/chunks/874-16716eedeadde879.js" async=""></script><script src="/_next/static/chunks/app/error-d036ecfd03716e30.js" async=""></script><script src="/_next/static/chunks/app/not-found-2113bbd7a2f55e8f.js" async=""></script><script src="/_next/static/chunks/app/loading-b73dd9bd22c3caa2.js" async=""></script><script src="/_next/static/chunks/766-eeb113df4f56c105.js" async=""></script><script src="/_next/static/chunks/app/(article)/layout-18bcffe355ed9a9b.js" async=""></script><script src="/_next/static/chunks/62-36d7af331e30e687.js" async=""></script><script src="/_next/static/chunks/app/(article)/posts/%5Bslug%5D/page-2ec56518ac6621da.js" async=""></script><meta name="next-size-adjust" content=""/><title>Ai.Haibara codes</title><meta name="description" content="LZS Blog"/><link rel="icon" href="/favicon.ico" type="image/x-icon" sizes="96x96"/><script>document.querySelectorAll('body link[rel="icon"], body link[rel="apple-touch-icon"]').forEach(el => document.head.appendChild(el))</script><script src="/_next/static/chunks/polyfills-42372ed130431b0a.js" noModule=""></script></head><body class="__variable_4d318d __variable_ea5f4b antialiased"><!--$--><html lang="en"><body class="__variable_4d318d __variable_ea5f4b antialiased"><div class="min-h-screen"><header class="text-white bg-black drop-shadow-2xl"><div class="mx-auto my-0 max-w-[960px] py-6 px-4 flex items-center"><div class="flex items-center"><img alt="Ai.Haibara" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class=" rounded-full" style="color:transparent" srcSet="/_next/image?url=%2Fassets%2Fblog%2Fauthors%2Fhaibara_2.jpg&amp;w=128&amp;q=75 1x, /_next/image?url=%2Fassets%2Fblog%2Fauthors%2Fhaibara_2.jpg&amp;w=256&amp;q=75 2x" src="/_next/image?url=%2Fassets%2Fblog%2Fauthors%2Fhaibara_2.jpg&amp;w=256&amp;q=75"/></div><div class="ml-6"><a class=" font-bold text-3xl" href="/">Ai.Haibara codes</a><div class="mt-2"><a class="p-1 rounded-sm text-xl mr-2 hover:border-b-2 border-lime-300" href="/">Home</a><a class="p-1 rounded-sm text-xl mr-2 hover:border-b-2 border-lime-300" href="/projects">Projects</a><a class="p-1 rounded-sm text-xl mr-2 hover:border-b-2 border-lime-300" href="/talks">Talks</a><a class="p-1 rounded-sm text-xl mr-2 hover:border-b-2 border-lime-300" href="/blogs">Blogs</a></div></div></div></header><main class="p-6 flex justify-center"><article><div class="flex justify-center font-[Arial] max-w-[864px] text-center"><h1 class="text-[2.5rem] font-bold bg-lime-300 px-5 py-2 rounded-sm text-shadow-lg leading-[1.1]">结合 Docker, 了解 Nginx 的两个用法</h1></div><time dateTime="2023-08-20" class="text-center block my-4 text-sm opacity-60">August	20, 2023</time><section class="markdown-body-fancy max-w-3xl"><h2 id="前置准备"><a aria-hidden="true" tabindex="-1" href="#前置准备"><span class="icon icon-link"></span></a>前置准备</h2>
<p>首先需要安装  <a href="https://www.docker.com/products/docker-desktop/">Docker Desktop</a></p>
<p>它是一个可以在桌面端管理docker镜像和容器的应用程序</p>
<p><img src="/assets/docker_nginx/example-1.png" alt="alt"></p>
<p>同时, 也可以在终端里面执行 docker 相关的命令了</p>
<p><img src="/assets/docker_nginx/example-2.png" alt="alt"></p>
<p>接下来, 我们来跑一个 nginx 的镜像</p>
<p><img src="/assets/docker_nginx/example-3.png" alt="alt"></p>
<p>输入容器名以及映射的端口号</p>
<p><img src="/assets/docker_nginx/example-4.png" alt="alt"></p>
<p>这里我们将宿主的 8001 端口映射到容器的 80 端口, 点击 Run 后, 就可以看到 docker 容器成功的运行起来了, 并且可以看到日志信息:</p>
<p><img src="/assets/docker_nginx/example-5.png" alt="alt"></p>
<p>浏览器访问下 <a href="http://localhost:8001">http://localhost:8001</a> 可以看到 nginx 欢迎页面：</p>
<p><img src="/assets/docker_nginx/example-6.png" alt="alt"></p>
<p>但是现在的页面是默认的，我想用 nginx 来托管我的一些静态 html 页面怎么做呢？</p>
<p>首先我们要知道现在的配置文件和页面都存在哪里.</p>
<p>在 files 面板可以看到容器内的文件, 里面的 /usr/share/nginx/html/ 目录下面就是所有的静态文件.</p>
<p>双击点开 index.html 后可以看到：</p>
<p><img src="/assets/docker_nginx/example-7.png" alt="alt"></p>
<p>这个 html 内容和默认内容完全一致</p>
<p>也就是说，这个目录就是保存静态文件的目录, 所以我们只需要将自己的 html 文件存放在这里就行了.</p>
<p>我们先将这个文件从容器中复制出来:</p>
<p><code>docker cp nginx1:/usr/share/nginx/html ~/code/nginx/nginx-html</code></p>
<p>同样的, 我们在 files 中找到 /etc/nginx 目录, 这里面存放着关于 nginx 的主配置文件以及一些其他配置信息, 我们同样的将其从容器中复制出来</p>
<p><code>docker cp nginx1:/etc/nginx ~/code/nginx</code></p>
<p>现在我们删除容器, 并重新 Run nginx 镜像, 这次我们添加上 volumes, 也就是添加了宿主目录与容器目录的映射.</p>
<p><img src="/assets/docker_nginx/example-8.png" alt="alt"></p>
<p>此时, 我们在 <a href="http://localhost:8001">http://localhost:8001</a> 上仍然能看到 nginx 默认页.
当我们修改本地 nginx-html/html/index.html 的内容后, 刷新浏览器, 能看到默认页发生对应的改变, 这就是我们添加的目录映射的功劳.</p>
<p><img src="/assets/docker_nginx/example-9.png" alt="alt"></p>
<p><img src="/assets/docker_nginx/example-10.png" alt="alt"></p>
<p>同样, 我们在本地的 nginx-html/html/ 下新增 test.html, 然后访问 localhost:8081/test.html, 同样也能访问到 test.html 的内容.</p>
<p>到目前为止, 我们正常的配置了一个使用 docker 的 nginx 容器, 接下来我们看下 nginx 的两个核心用法.</p>
<h2 id="nginx-配置文件"><a aria-hidden="true" tabindex="-1" href="#nginx-配置文件"><span class="icon icon-link"></span></a>nginx 配置文件</h2>
<p>首先, 我们先找到从容器中复制出来的 nginx 目录, 打开 nginx.conf 文件, 这是 nginx 的主配置文件:</p>
<pre><code class="hljs language-conf">
user  nginx; #指定Nginx worker进程的运行用户为nginx
worker_processes  auto; #设置worker进程的数量，使用auto表示根据系统的CPU核心数自动设置

error_log  /var/log/nginx/error.log notice; # 指定错误日志文件的路径和级别，此处为/var/log/nginx/error.log，并设置级别为notice.
pid        /var/run/nginx.pid; #指定Nginx主进程的PID文件路径.


events {
    worker_connections  1024;
}


http # 定义Nginx的HTTP模块，包括HTTP服务器的全局配置和默认行为. {
    include       /etc/nginx/mime.types; #引入MIME类型配置文件，该文件定义了文件扩展名与MIME类型的映射关系.
    default_type  application/octet-stream; #设置默认的Content-Type，即当无法从文件扩展名中确定MIME类型时使用的默认类型.

    log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '
                      '$status $body_bytes_sent "$http_referer" '
                      '"$http_user_agent" "$http_x_forwarded_for"'; #配置日志格式，定义了日志中的字段和格式化方式.

    access_log  /var/log/nginx/access.log  main; #指定访问日志文件的路径和使用的日志格式.

    sendfile        on; #开启sendfile机制，用于优化发送静态文件的性能.
    #tcp_nopush     on;

    keepalive_timeout  65; #设置长连接的超时时间，即空闲连接保持的时间.

    #gzip  on;

    include /etc/nginx/conf.d/*.conf; #引入/conf.d/目录下的所有.conf文件，用于包含额外的配置文件.
}
</code></pre>
<p>这里面一般做一些全局的配置，比如错误日志的目录等等.</p>
<p>可以看到 http 下面有个 include 引入了 /etc/nginx/conf.d/*.conf 的配置.</p>
<p>一般具体的路由配置都是在这些子配置文件里.</p>
<p>接下来我们看下 conf.d 下的 default.conf 文件:</p>
<p><img src="/assets/docker_nginx/example-11.png" alt="alt"></p>
<p>这里面就配置了 localhost:80 的虚拟主机下的所有路由, 也就是宿主主机下的 localhost:8081</p>
<p>虚拟主机是什么呢？</p>
<p>就是可以用一台 nginx 服务器来为多个域名和端口的提供服务.</p>
<p>只要多加几个 server 配置就可以.</p>
<p>这里我们就配置 localhost:80 这一个虚拟主机.</p>
<p>下面的 location 就是路由配置.</p>
<p>比如这个配置：</p>
<p><img src="/assets/docker_nginx/example-12.png" alt="alt"></p>
<p>它就配置了 / 下的所有路由，都是在 root 指定的目录查找.</p>
<p>所以 <a href="http://localhost/aaa.html">http://localhost/aaa.html</a> 就是从 /usr/share/nginx/html/aaa.html 找的.</p>
<p>location 支持的语法有好几个，我们分别试一下：</p>
<p><img src="/assets/docker_nginx/example-13.png" alt="alt"></p>
<p>把之前的 location / 注释掉，添加这样几个路由配置, 然后在容器内的 terminal 执行以下命令:</p>
<p><code>nginx -s reload</code></p>
<p>重新加载配置文件(⚠️: 每次修改配置文件后都需要重新加载下配置文件)</p>
<p>然后来看第一条路由</p>
<pre><code class="hljs language-code">  location = /111/ {
    default_type text/plain;
    return 200 "111 success";
    }
</code></pre>
<p>location 和路径之间加了个 =，代表精准匹配，也就是只有完全相同的 url 才会匹配这个路由.</p>
<p><img src="/assets/docker_nginx/example-14.png" alt="alt"></p>
<p>不带 = 代表根据前缀匹配，后面可以是任意路径, 这里的 $uri 是取当前路径.</p>
<pre><code class="hljs language-code">    location /222 {
        default_type text/plain;
        return 200 $uri;
    }

</code></pre>
<p><img src="/assets/docker_nginx/example-15.png" alt="alt"></p>
<p>如果想支持正则，就可以加个 ~</p>
<pre><code class="hljs language-conf">    location ~ ^/333/bbb.*\.html$ {
        default_type text/plain;
        return 200 $uri;
    }
</code></pre>
<p><img src="/assets/docker_nginx/example-16.png" alt="alt"></p>
<p>这里的正则语法不难看懂，就是 /333/bbb 开头，然后中间是任意字符，最后 .html 结尾的 url.</p>
<p>当然, 这样是会区分大小写的, 例如这样的路径就不支持了</p>
<p><img src="/assets/docker_nginx/example-17.png" alt="alt"></p>
<p>如果想让正则不区分大小写，可以再加个 *</p>
<pre><code class="hljs language-conf">    
    location ~* ^/444/AAA.*\.html$ {
        default_type text/plain;
        return 200 $uri;
    }
</code></pre>
<p><img src="/assets/docker_nginx/example-18.png" alt="alt"></p>
<p>此外，还有一种语法：</p>
<p>在配置文件加上这个配置：</p>
<pre><code class="hljs language-conf">location /444 {
    default_type text/plain;
    return 200 'xxxx';
}
</code></pre>
<p>这时候就有两个 /444 的路由了, 这时候浏览器访问，还是匹配上面的那个路由：</p>
<p><img src="/assets/docker_nginx/example-19.png" alt="alt"></p>
<p>如果想提高优先级，可以使用 ^~</p>
<p>改成这样：</p>
<pre><code class="hljs language-conf">location ^~ /444 {
    default_type text/plain;
    return 200 'xxxx';
}
</code></pre>
<p>这时候同一个 url，匹配的就是下面的路由了：</p>
<p><img src="/assets/docker_nginx/example-20.png" alt="alt"></p>
<p>也就是说 ^~ 能够提高前缀匹配的优先级.</p>
<p>总结一下，一共 4 个 location 语法：</p>
<p>location = /aaa 是精确匹配 /aaa 的路由.</p>
<p>location /bbb 是前缀匹配 /bbb 的路由.</p>
<p>location ~ /ccc.<em>.html 是正则匹配.可以再加个</em> 表示不区分大小写 location ~<em>/ccc.</em>.html</p>
<p>location ^~ /ddd 是前缀匹配，但是优先级更高.</p>
<p>这 4 种语法的优先级是这样的：</p>
<p><strong>精确匹配（=） > 高优先级前缀匹配（^~） > 正则匹配（～ ~*） > 普通前缀匹配</strong></p>
<p>我们现在是直接用 return 返回的内容，其实应该返回 html 文件.</p>
<p>可以这样改：</p>
<pre><code class="hljs language-conf">location /222 {
    alias /usr/share/nginx/html;
}

location ~ ^/333/bbb.*\.html$ {
    alias /usr/share/nginx/html/test.html;
}
</code></pre>
<p><img src="/assets/docker_nginx/example-21.png" alt="alt"></p>
<p><img src="/assets/docker_nginx/example-22.png" alt="alt"></p>
<p>前面用过 root：</p>
<pre><code class="hljs language-conf"> location / {
      root   /usr/share/nginx/html;
      index  index.html index.htm;
  }
</code></pre>
<p>root 和 alias 有什么区别呢？</p>
<p>比如这样的两个配置：</p>
<pre><code class="hljs language-conf">location /222 {
    alias /dddd;
}

location /222 {
    root /dddd;
}
</code></pre>
<p>同样是 /222/xxx/yyy.html，如果是用 root 的配置，会把整个 uri 作为路径拼接在后面.</p>
<p>也就是会查找 /dddd/222/xxx/yyy.html 文件.</p>
<p>如果是 alias 配置，它会把去掉 /222 之后的部分路径拼接在后面.</p>
<p>也就是会查找 /dddd/xxx/yyy.html 文件.</p>
<p>也就是 我们 <strong>root 和 alias 的区别就是拼接路径时是否包含匹配条件的路径</strong></p>
<p>这就是 nginx 的第一个功能：静态文件托管.</p>
<p>主配置文件在 /etc/nginx/nginx.conf，而子配置文件在 /etc/nginx/conf.d 目录下.</p>
<p>默认的 html 路径是 /usr/share/nginx/html.</p>
<p>然后来看下 nginx 的第二大功能：动态资源的反向代理.</p>
<p>关于 <a href="https://cloud.tencent.com/developer/article/1418457">正向代理以及反向代理</a></p>
<p>测试 nginx 做反向代理服务器之前，我们先创建个 nest 服务.</p>
<p><code>npx nest new nest-app -p npm</code></p>
<p>浏览器就访问 <a href="http://localhost:3000">http://localhost:3000</a> 看到 hello world 就代表 nest 服务跑成功了：</p>
<p><img src="/assets/docker_nginx/example-23.png" alt="alt"></p>
<p>添加一个全局的前缀 /v1</p>
<p><img src="/assets/docker_nginx/example-24.png" alt="alt"></p>
<p>改下 nginx 配置，添加个路由：</p>
<pre><code class="hljs language-code">    location ^~ /v1 {
        proxy_pass http://192.168.21.242:3000;
    }    
</code></pre>
<p>这个路由是根据前缀匹配 /v1 开头的 url， ^~ 是提高优先级用的.</p>
<p>然后你访问 <a href="http://localhost:8001/v1">http://localhost:8001/v1</a> 就可以看到 nest 服务返回的响应了：</p>
<p><img src="/assets/docker_nginx/example-25.png" alt="alt"></p>
<p>为什么要多 nginx 这一层代理呢？</p>
<p>自然是可以在这一层做很多事情的.</p>
<p>比如修改 header：</p>
<pre><code class="hljs language-code">    location ^~ /v1 {
        proxy_set_header name liyu; #新增
        proxy_pass http://192.168.21.242:3000;
    }    

</code></pre>
<p>在 nest 服务的 handler 里注入 headers，打印一下：</p>
<p><img src="/assets/docker_nginx/example-26.png" alt="alt"></p>
<p>然后浏览器访问下.</p>
<p>直接访问 nest 服务的话，是没有这个 header 的：</p>
<p><img src="/assets/docker_nginx/example-27.png" alt="alt"></p>
<p>访问 nginx 的反向代理服务器，做一次中转：</p>
<p><img src="/assets/docker_nginx/example-28.png" alt="alt"></p>
<p>这就是反向代理服务器的作用，可以透明的修改请求、响应.</p>
<p>而且，还可以用它实现负载均衡.</p>
<p>在 controlller 里打印下访问日志, 并修改端口 3001, 新开端口重新使用 <code>yarn start</code> 启动服务</p>
<p><img src="/assets/docker_nginx/example-29.png" alt="alt"></p>
<p>这个时候, 我们就有 3000 和 3001 两个服务了, 浏览器访问下, 都是正常的
<img src="/assets/docker_nginx/example-30.png" alt="alt"></p>
<p><img src="/assets/docker_nginx/example-31.png" alt="alt"></p>
<p>问题来了，现在有一个 nginx 服务器，两个 nest 服务器了，nginx 该如何应对呢？</p>
<p>nginx 的解决方式就是负载均衡，把请求按照一定的规则分到不同的服务器.</p>
<p>改下 nginx 配置文件：</p>
<p><img src="/assets/docker_nginx/example-32.png" alt="alt"></p>
<p>在 upstream 里配置它代理的目标服务器的所有实例.</p>
<p>下面 proxy_pass 通过 upstream 的名字来指定.</p>
<p>这时候我访问 <a href="http://localhost:8001/v1">http://localhost:8001/v1</a> 刷新 5 次页面：</p>
<p><img src="/assets/docker_nginx/example-33.png" alt="alt"></p>
<p>可以看到两个 nest 服务，一个 3 次，一个 2 次.</p>
<p>因为默认是轮询的方式.</p>
<p>一共有 4 种负载均衡策略：</p>
<p>轮询：默认方式.
weight：在轮询基础上增加权重，也就是轮询到的几率不同.
ip_hash：按照 ip 的 hash 分配，保证每个访客的请求固定访问一个服务器，解决 session 问题.
fair：按照响应时间来分配，这个需要安装 nginx-upstream-fair 插件.
我们测试下 weight 和 ip_hash 的方式.</p>
<p>添加一个 weight=2，默认是 1，这样两个服务器轮询到的几率是 2 比 1.</p>
<p><img src="/assets/docker_nginx/example-34.png" alt="alt"></p>
<p>然后我访问了 8 次 <a href="http://localhost:8001/v1">http://localhost:8001/v1</a></p>
<p>看打印的日志来看，差不多就是 2:1 的轮询几率.</p>
<p><img src="/assets/docker_nginx/example-35.png" alt="alt"></p>
<p>这就是带权重的轮询.</p>
<p>我们再试下 ip_hash 的方式；</p>
<p><img src="/assets/docker_nginx/example-36.png" alt="alt"></p>
<p>再次访问了 <a href="http://localhost:8001/v1">http://localhost:8001/v1</a>
可以看到一直请求到了一台服务器：
<img src="/assets/docker_nginx/example-37.png" alt="alt"></p>
<p>这就是 Nginx 的负载均衡的策略.</p>
<p>这就是 Nginx 的负载均衡的策略.</p>
<h2 id="总结"><a aria-hidden="true" tabindex="-1" href="#总结"><span class="icon icon-link"></span></a>总结</h2>
<p>我们通过 docker 跑了 nginx 服务器，并使用了它的静态资源托管功能，还有动态资源的反向代理功能.</p>
<p>nginx 的配置文件在 /etc/nginx/nginx.conf 里，它默认还引入了 /etc/nginx/conf.d 下的子配置文件.</p>
<p>默认 html 都放在 /usr/share/nginx/html 下.</p>
<p>我们可以通过 docker cp 来把容器内文件复制到宿主机, 然后进行文件映射, 最后通过修改宿主上的配置文件来修改容器中的配置文件.</p>
<p>修改 nginx 配置，在 server 里配置路由，根据不同的 url 返回不同的静态文件.</p>
<p>有 4 种 location 语法：</p>
<ol>
<li>location /aaa 根据前缀匹配</li>
<li>location ^~ /aaa 根据前缀匹配，优先级更高</li>
<li>location = /aaa 精准匹配</li>
<li>location ~ /aaa/.*html 正则匹配
<code>location ~* /aaa/.*html</code>正则匹配，而且不区分大小写</li>
</ol>
<p>优先级是 精确匹配（=） > 高优先级前缀匹配（^~） > 正则匹配（～ ~*） > 普通前缀匹配</p>
<p>除了静态资源托管外，nginx 还可以对动态资源做反向代理.</p>
<p>也就是请求发给 nginx，由它转发给应用服务器，这一层也可以叫做网关.</p>
<p>nginx 反向代理可以修改请求、响应信息，比如设置 header.</p>
<p>当有多台应用服务器的时候，可以通过 upstream 配置负载均衡，有 4 种策略：轮询、带权重的轮询、ip_hash、fair.</p>
<p>掌握了静态资源托管、动态资源的反向代理+负载均衡.</p></section></article><!--$--><!--/$--><!--$--><!--/$--></main><footer class="bg-neutral-50 border-t border-neutral-200 text-center text-xs opacity-50 py-4">© 2022 - <!-- -->2025<a rel="noopener noreferrer" class="hover:underline hover:bg-indigo" href="https://github.com/LZS911" target="_blank">, LZS_911</a>, build with<!-- --> <a rel="noopener noreferrer" class="underline hover:bg-indigo" href="https://nextjs.org/" target="_blank">Next.js</a> <!-- -->and<!-- --> <a rel="noopener noreferrer" class="underline hover:bg-indigo" href="https://pages.github.com/?(null)" target="_blank">GitHub Pages</a></footer></div><a class="fixed right-2 top-1/2 transform -translate-y-1/2 z-50 group" href="/practice"><div class="w-10 h-10 bg-black hover:bg-gray-800 text-white rounded-full flex items-center justify-center shadow-[0_0_15px_rgba(0,0,0,0.2)] transition-all duration-300 ease-out hover:scale-110 hover:rotate-[360deg] hover:shadow-[0_0_20px_rgba(0,0,0,0.3)] backdrop-blur-sm bg-opacity-80"><svg class="w-5 h-5 transition-transform duration-300 ease-out group-hover:scale-90" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M14.752 11.168l-3.197-2.132A1 1 0 0010 9.87v4.263a1 1 0 001.555.832l3.197-2.132a1 1 0 000-1.664z"></path><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg></div></a><!--/$--><script src="/_next/static/chunks/webpack-6281654836ffc620.js" async=""></script></body></html><script>(self.__next_f=self.__next_f||[]).push([0])</script><script>self.__next_f.push([1,"1:\"$Sreact.fragment\"\n2:I[7555,[],\"\"]\n3:I[1901,[\"874\",\"static/chunks/874-16716eedeadde879.js\",\"39\",\"static/chunks/app/error-d036ecfd03716e30.js\"],\"default\"]\n4:I[1295,[],\"\"]\n5:I[9543,[\"874\",\"static/chunks/874-16716eedeadde879.js\",\"345\",\"static/chunks/app/not-found-2113bbd7a2f55e8f.js\"],\"default\"]\n8:I[9665,[],\"MetadataBoundary\"]\na:I[9665,[],\"OutletBoundary\"]\nd:I[4911,[],\"AsyncMetadataOutlet\"]\nf:I[8460,[\"209\",\"static/chunks/app/loading-b73dd9bd22c3caa2.js\"],\"default\"]\n10:I[9665,[],\"ViewportBoundary\"]\n12:I[6614,[],\"\"]\n:HL[\"/_next/static/media/569ce4b8f30dc480-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n:HL[\"/_next/static/media/93f479601ee12b01-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n:HL[\"/_next/static/css/2626867bd1decdff.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"0:{\"P\":null,\"b\":\"-Iu8KnLDp0bD3kZkGuE9H\",\"p\":\"\",\"c\":[\"\",\"posts\",\"%E7%BB%93%E5%90%88%20Docker%2C%20%E4%BA%86%E8%A7%A3%20Nginx%20%E4%B8%A4%E4%B8%AA%E7%94%A8%E6%B3%95\"],\"i\":false,\"f\":[[[\"\",{\"children\":[\"(article)\",{\"children\":[\"posts\",{\"children\":[[\"slug\",\"%E7%BB%93%E5%90%88%20Docker%2C%20%E4%BA%86%E8%A7%A3%20Nginx%20%E4%B8%A4%E4%B8%AA%E7%94%A8%E6%B3%95\",\"d\"],{\"children\":[\"__PAGE__\",{}]}]}]}]},\"$undefined\",\"$undefined\",true],[\"\",[\"$\",\"$1\",\"c\",{\"children\":[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/2626867bd1decdff.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}]],[\"$\",\"html\",null,{\"lang\":\"en\",\"children\":[\"$\",\"body\",null,{\"className\":\"__variable_4d318d __variable_ea5f4b antialiased\",\"children\":[\"$\",\"$L2\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$3\",\"errorStyles\":[],\"errorScripts\":[],\"template\":[\"$\",\"$L4\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[[\"$\",\"$L5\",null,{}],[]],\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]}]}]]}],{\"children\":[\"(article)\",[\"$\",\"$1\",\"c\",{\"children\":[null,\"$L6\"]}],{\"children\":[\"posts\",[\"$\",\"$1\",\"c\",{\"children\":[null,[\"$\",\"$L2\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L4\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]]}],{\"children\":[[\"slug\",\"%E7%BB%93%E5%90%88%20Docker%2C%20%E4%BA%86%E8%A7%A3%20Nginx%20%E4%B8%A4%E4%B8%AA%E7%94%A8%E6%B3%95\",\"d\"],[\"$\",\"$1\",\"c\",{\"children\":[null,[\"$\",\"$L2\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L4\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]]}],{\"children\":[\"__PAGE__\",[\"$\",\"$1\",\"c\",{\"children\":[\"$L7\",[\"$\",\"$L8\",null,{\"children\":\"$L9\"}],null,[\"$\",\"$La\",null,{\"children\":[\"$Lb\",\"$Lc\",[\"$\",\"$Ld\",null,{\"promise\":\"$@e\"}]]}]]}],{},null,false]},null,false]},null,false]},null,false]},[[\"$\",\"$Lf\",\"l\",{}],[],[]],false],[\"$\",\"$1\",\"h\",{\"children\":[null,[\"$\",\"$1\",\"U8QIbN2sy6U76wrosVrda\",{\"children\":[[\"$\",\"$L10\",null,{\"children\":\"$L11\"}],[\"$\",\"meta\",null,{\"name\":\"next-size-adjust\",\"content\":\"\"}]]}],null]}],false]],\"m\":\"$undefined\",\"G\":[\"$12\",\"$undefined\"],\"s\":false,\"S\":true}\n"])</script><script>self.__next_f.push([1,"13:I[8565,[\"874\",\"static/chunks/874-16716eedeadde879.js\",\"766\",\"static/chunks/766-eeb113df4f56c105.js\",\"651\",\"static/chunks/app/(article)/layout-18bcffe355ed9a9b.js\"],\"default\"]\n14:I[7832,[\"874\",\"static/chunks/874-16716eedeadde879.js\",\"766\",\"static/chunks/766-eeb113df4f56c105.js\",\"651\",\"static/chunks/app/(article)/layout-18bcffe355ed9a9b.js\"],\"default\"]\n15:\"$Sreact.suspense\"\n16:I[4911,[],\"AsyncMetadata\"]\n6:[\"$\",\"html\",null,{\"lang\":\"en\",\"children\":[\"$\",\"body\",null,{\"className\":\"__variable_4d318d __variable_ea5f4b antialiased\",\"children\":[[\"$\",\"div\",null,{\"className\":\"min-h-screen\",\"children\":[[\"$\",\"$L13\",null,{}],[\"$\",\"main\",null,{\"className\":\"p-6 flex justify-center\",\"children\":[\"$\",\"$L2\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L4\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]}],[\"$\",\"footer\",null,{\"className\":\"bg-neutral-50 border-t border-neutral-200 text-center text-xs opacity-50 py-4\",\"children\":[\"© 2022 - \",2025,[\"$\",\"a\",null,{\"rel\":\"noopener noreferrer\",\"className\":\"hover:underline hover:bg-indigo\",\"href\":\"https://github.com/LZS911\",\"target\":\"_blank\",\"children\":\", LZS_911\"}],\", build with\",\" \",[\"$\",\"a\",null,{\"rel\":\"noopener noreferrer\",\"className\":\"underline hover:bg-indigo\",\"href\":\"https://nextjs.org/\",\"target\":\"_blank\",\"children\":\"Next.js\"}],\" \",\"and\",\" \",[\"$\",\"a\",null,{\"rel\":\"noopener noreferrer\",\"className\":\"underline hover:bg-indigo\",\"href\":\"https://pages.github.com/?(null)\",\"target\":\"_blank\",\"children\":\"GitHub Pages\"}]]}]]}],[\"$\",\"$L14\",null,{\"href\":\"/practice\"}]]}]}]\n9:[\"$\",\"$15\",null,{\"fallback\":null,\"children\":[\"$\",\"$L16\",null,{\"promise\":\"$@17\"}]}]\n"])</script><script>self.__next_f.push([1,"c:null\n"])</script><script>self.__next_f.push([1,"18:I[5099,[\"766\",\"static/chunks/766-eeb113df4f56c105.js\",\"62\",\"static/chunks/62-36d7af331e30e687.js\",\"520\",\"static/chunks/app/(article)/posts/%5Bslug%5D/page-2ec56518ac6621da.js\"],\"ThemeLoader\"]\n19:T418b,"])</script><script>self.__next_f.push([1,"\u003ch2 id=\"前置准备\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#前置准备\"\u003e\u003cspan class=\"icon icon-link\"\u003e\u003c/span\u003e\u003c/a\u003e前置准备\u003c/h2\u003e\n\u003cp\u003e首先需要安装  \u003ca href=\"https://www.docker.com/products/docker-desktop/\"\u003eDocker Desktop\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e它是一个可以在桌面端管理docker镜像和容器的应用程序\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/docker_nginx/example-1.png\" alt=\"alt\"\u003e\u003c/p\u003e\n\u003cp\u003e同时, 也可以在终端里面执行 docker 相关的命令了\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/docker_nginx/example-2.png\" alt=\"alt\"\u003e\u003c/p\u003e\n\u003cp\u003e接下来, 我们来跑一个 nginx 的镜像\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/docker_nginx/example-3.png\" alt=\"alt\"\u003e\u003c/p\u003e\n\u003cp\u003e输入容器名以及映射的端口号\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/docker_nginx/example-4.png\" alt=\"alt\"\u003e\u003c/p\u003e\n\u003cp\u003e这里我们将宿主的 8001 端口映射到容器的 80 端口, 点击 Run 后, 就可以看到 docker 容器成功的运行起来了, 并且可以看到日志信息:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/docker_nginx/example-5.png\" alt=\"alt\"\u003e\u003c/p\u003e\n\u003cp\u003e浏览器访问下 \u003ca href=\"http://localhost:8001\"\u003ehttp://localhost:8001\u003c/a\u003e 可以看到 nginx 欢迎页面：\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/docker_nginx/example-6.png\" alt=\"alt\"\u003e\u003c/p\u003e\n\u003cp\u003e但是现在的页面是默认的，我想用 nginx 来托管我的一些静态 html 页面怎么做呢？\u003c/p\u003e\n\u003cp\u003e首先我们要知道现在的配置文件和页面都存在哪里.\u003c/p\u003e\n\u003cp\u003e在 files 面板可以看到容器内的文件, 里面的 /usr/share/nginx/html/ 目录下面就是所有的静态文件.\u003c/p\u003e\n\u003cp\u003e双击点开 index.html 后可以看到：\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/docker_nginx/example-7.png\" alt=\"alt\"\u003e\u003c/p\u003e\n\u003cp\u003e这个 html 内容和默认内容完全一致\u003c/p\u003e\n\u003cp\u003e也就是说，这个目录就是保存静态文件的目录, 所以我们只需要将自己的 html 文件存放在这里就行了.\u003c/p\u003e\n\u003cp\u003e我们先将这个文件从容器中复制出来:\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003edocker cp nginx1:/usr/share/nginx/html ~/code/nginx/nginx-html\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e同样的, 我们在 files 中找到 /etc/nginx 目录, 这里面存放着关于 nginx 的主配置文件以及一些其他配置信息, 我们同样的将其从容器中复制出来\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003edocker cp nginx1:/etc/nginx ~/code/nginx\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e现在我们删除容器, 并重新 Run nginx 镜像, 这次我们添加上 volumes, 也就是添加了宿主目录与容器目录的映射.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/docker_nginx/example-8.png\" alt=\"alt\"\u003e\u003c/p\u003e\n\u003cp\u003e此时, 我们在 \u003ca href=\"http://localhost:8001\"\u003ehttp://localhost:8001\u003c/a\u003e 上仍然能看到 nginx 默认页.\n当我们修改本地 nginx-html/html/index.html 的内容后, 刷新浏览器, 能看到默认页发生对应的改变, 这就是我们添加的目录映射的功劳.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/docker_nginx/example-9.png\" alt=\"alt\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/docker_nginx/example-10.png\" alt=\"alt\"\u003e\u003c/p\u003e\n\u003cp\u003e同样, 我们在本地的 nginx-html/html/ 下新增 test.html, 然后访问 localhost:8081/test.html, 同样也能访问到 test.html 的内容.\u003c/p\u003e\n\u003cp\u003e到目前为止, 我们正常的配置了一个使用 docker 的 nginx 容器, 接下来我们看下 nginx 的两个核心用法.\u003c/p\u003e\n\u003ch2 id=\"nginx-配置文件\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#nginx-配置文件\"\u003e\u003cspan class=\"icon icon-link\"\u003e\u003c/span\u003e\u003c/a\u003enginx 配置文件\u003c/h2\u003e\n\u003cp\u003e首先, 我们先找到从容器中复制出来的 nginx 目录, 打开 nginx.conf 文件, 这是 nginx 的主配置文件:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-conf\"\u003e\nuser  nginx; #指定Nginx worker进程的运行用户为nginx\nworker_processes  auto; #设置worker进程的数量，使用auto表示根据系统的CPU核心数自动设置\n\nerror_log  /var/log/nginx/error.log notice; # 指定错误日志文件的路径和级别，此处为/var/log/nginx/error.log，并设置级别为notice.\npid        /var/run/nginx.pid; #指定Nginx主进程的PID文件路径.\n\n\nevents {\n    worker_connections  1024;\n}\n\n\nhttp # 定义Nginx的HTTP模块，包括HTTP服务器的全局配置和默认行为. {\n    include       /etc/nginx/mime.types; #引入MIME类型配置文件，该文件定义了文件扩展名与MIME类型的映射关系.\n    default_type  application/octet-stream; #设置默认的Content-Type，即当无法从文件扩展名中确定MIME类型时使用的默认类型.\n\n    log_format  main  '$remote_addr - $remote_user [$time_local] \"$request\" '\n                      '$status $body_bytes_sent \"$http_referer\" '\n                      '\"$http_user_agent\" \"$http_x_forwarded_for\"'; #配置日志格式，定义了日志中的字段和格式化方式.\n\n    access_log  /var/log/nginx/access.log  main; #指定访问日志文件的路径和使用的日志格式.\n\n    sendfile        on; #开启sendfile机制，用于优化发送静态文件的性能.\n    #tcp_nopush     on;\n\n    keepalive_timeout  65; #设置长连接的超时时间，即空闲连接保持的时间.\n\n    #gzip  on;\n\n    include /etc/nginx/conf.d/*.conf; #引入/conf.d/目录下的所有.conf文件，用于包含额外的配置文件.\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e这里面一般做一些全局的配置，比如错误日志的目录等等.\u003c/p\u003e\n\u003cp\u003e可以看到 http 下面有个 include 引入了 /etc/nginx/conf.d/*.conf 的配置.\u003c/p\u003e\n\u003cp\u003e一般具体的路由配置都是在这些子配置文件里.\u003c/p\u003e\n\u003cp\u003e接下来我们看下 conf.d 下的 default.conf 文件:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/docker_nginx/example-11.png\" alt=\"alt\"\u003e\u003c/p\u003e\n\u003cp\u003e这里面就配置了 localhost:80 的虚拟主机下的所有路由, 也就是宿主主机下的 localhost:8081\u003c/p\u003e\n\u003cp\u003e虚拟主机是什么呢？\u003c/p\u003e\n\u003cp\u003e就是可以用一台 nginx 服务器来为多个域名和端口的提供服务.\u003c/p\u003e\n\u003cp\u003e只要多加几个 server 配置就可以.\u003c/p\u003e\n\u003cp\u003e这里我们就配置 localhost:80 这一个虚拟主机.\u003c/p\u003e\n\u003cp\u003e下面的 location 就是路由配置.\u003c/p\u003e\n\u003cp\u003e比如这个配置：\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/docker_nginx/example-12.png\" alt=\"alt\"\u003e\u003c/p\u003e\n\u003cp\u003e它就配置了 / 下的所有路由，都是在 root 指定的目录查找.\u003c/p\u003e\n\u003cp\u003e所以 \u003ca href=\"http://localhost/aaa.html\"\u003ehttp://localhost/aaa.html\u003c/a\u003e 就是从 /usr/share/nginx/html/aaa.html 找的.\u003c/p\u003e\n\u003cp\u003elocation 支持的语法有好几个，我们分别试一下：\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/docker_nginx/example-13.png\" alt=\"alt\"\u003e\u003c/p\u003e\n\u003cp\u003e把之前的 location / 注释掉，添加这样几个路由配置, 然后在容器内的 terminal 执行以下命令:\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003enginx -s reload\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e重新加载配置文件(⚠️: 每次修改配置文件后都需要重新加载下配置文件)\u003c/p\u003e\n\u003cp\u003e然后来看第一条路由\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-code\"\u003e  location = /111/ {\n    default_type text/plain;\n    return 200 \"111 success\";\n    }\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003elocation 和路径之间加了个 =，代表精准匹配，也就是只有完全相同的 url 才会匹配这个路由.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/docker_nginx/example-14.png\" alt=\"alt\"\u003e\u003c/p\u003e\n\u003cp\u003e不带 = 代表根据前缀匹配，后面可以是任意路径, 这里的 $uri 是取当前路径.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-code\"\u003e    location /222 {\n        default_type text/plain;\n        return 200 $uri;\n    }\n\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cimg src=\"/assets/docker_nginx/example-15.png\" alt=\"alt\"\u003e\u003c/p\u003e\n\u003cp\u003e如果想支持正则，就可以加个 ~\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-conf\"\u003e    location ~ ^/333/bbb.*\\.html$ {\n        default_type text/plain;\n        return 200 $uri;\n    }\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cimg src=\"/assets/docker_nginx/example-16.png\" alt=\"alt\"\u003e\u003c/p\u003e\n\u003cp\u003e这里的正则语法不难看懂，就是 /333/bbb 开头，然后中间是任意字符，最后 .html 结尾的 url.\u003c/p\u003e\n\u003cp\u003e当然, 这样是会区分大小写的, 例如这样的路径就不支持了\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/docker_nginx/example-17.png\" alt=\"alt\"\u003e\u003c/p\u003e\n\u003cp\u003e如果想让正则不区分大小写，可以再加个 *\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-conf\"\u003e    \n    location ~* ^/444/AAA.*\\.html$ {\n        default_type text/plain;\n        return 200 $uri;\n    }\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cimg src=\"/assets/docker_nginx/example-18.png\" alt=\"alt\"\u003e\u003c/p\u003e\n\u003cp\u003e此外，还有一种语法：\u003c/p\u003e\n\u003cp\u003e在配置文件加上这个配置：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-conf\"\u003elocation /444 {\n    default_type text/plain;\n    return 200 'xxxx';\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e这时候就有两个 /444 的路由了, 这时候浏览器访问，还是匹配上面的那个路由：\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/docker_nginx/example-19.png\" alt=\"alt\"\u003e\u003c/p\u003e\n\u003cp\u003e如果想提高优先级，可以使用 ^~\u003c/p\u003e\n\u003cp\u003e改成这样：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-conf\"\u003elocation ^~ /444 {\n    default_type text/plain;\n    return 200 'xxxx';\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e这时候同一个 url，匹配的就是下面的路由了：\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/docker_nginx/example-20.png\" alt=\"alt\"\u003e\u003c/p\u003e\n\u003cp\u003e也就是说 ^~ 能够提高前缀匹配的优先级.\u003c/p\u003e\n\u003cp\u003e总结一下，一共 4 个 location 语法：\u003c/p\u003e\n\u003cp\u003elocation = /aaa 是精确匹配 /aaa 的路由.\u003c/p\u003e\n\u003cp\u003elocation /bbb 是前缀匹配 /bbb 的路由.\u003c/p\u003e\n\u003cp\u003elocation ~ /ccc.\u003cem\u003e.html 是正则匹配.可以再加个\u003c/em\u003e 表示不区分大小写 location ~\u003cem\u003e/ccc.\u003c/em\u003e.html\u003c/p\u003e\n\u003cp\u003elocation ^~ /ddd 是前缀匹配，但是优先级更高.\u003c/p\u003e\n\u003cp\u003e这 4 种语法的优先级是这样的：\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e精确匹配（=） \u003e 高优先级前缀匹配（^~） \u003e 正则匹配（～ ~*） \u003e 普通前缀匹配\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e我们现在是直接用 return 返回的内容，其实应该返回 html 文件.\u003c/p\u003e\n\u003cp\u003e可以这样改：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-conf\"\u003elocation /222 {\n    alias /usr/share/nginx/html;\n}\n\nlocation ~ ^/333/bbb.*\\.html$ {\n    alias /usr/share/nginx/html/test.html;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cimg src=\"/assets/docker_nginx/example-21.png\" alt=\"alt\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/docker_nginx/example-22.png\" alt=\"alt\"\u003e\u003c/p\u003e\n\u003cp\u003e前面用过 root：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-conf\"\u003e location / {\n      root   /usr/share/nginx/html;\n      index  index.html index.htm;\n  }\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eroot 和 alias 有什么区别呢？\u003c/p\u003e\n\u003cp\u003e比如这样的两个配置：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-conf\"\u003elocation /222 {\n    alias /dddd;\n}\n\nlocation /222 {\n    root /dddd;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e同样是 /222/xxx/yyy.html，如果是用 root 的配置，会把整个 uri 作为路径拼接在后面.\u003c/p\u003e\n\u003cp\u003e也就是会查找 /dddd/222/xxx/yyy.html 文件.\u003c/p\u003e\n\u003cp\u003e如果是 alias 配置，它会把去掉 /222 之后的部分路径拼接在后面.\u003c/p\u003e\n\u003cp\u003e也就是会查找 /dddd/xxx/yyy.html 文件.\u003c/p\u003e\n\u003cp\u003e也就是 我们 \u003cstrong\u003eroot 和 alias 的区别就是拼接路径时是否包含匹配条件的路径\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e这就是 nginx 的第一个功能：静态文件托管.\u003c/p\u003e\n\u003cp\u003e主配置文件在 /etc/nginx/nginx.conf，而子配置文件在 /etc/nginx/conf.d 目录下.\u003c/p\u003e\n\u003cp\u003e默认的 html 路径是 /usr/share/nginx/html.\u003c/p\u003e\n\u003cp\u003e然后来看下 nginx 的第二大功能：动态资源的反向代理.\u003c/p\u003e\n\u003cp\u003e关于 \u003ca href=\"https://cloud.tencent.com/developer/article/1418457\"\u003e正向代理以及反向代理\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e测试 nginx 做反向代理服务器之前，我们先创建个 nest 服务.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003enpx nest new nest-app -p npm\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e浏览器就访问 \u003ca href=\"http://localhost:3000\"\u003ehttp://localhost:3000\u003c/a\u003e 看到 hello world 就代表 nest 服务跑成功了：\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/docker_nginx/example-23.png\" alt=\"alt\"\u003e\u003c/p\u003e\n\u003cp\u003e添加一个全局的前缀 /v1\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/docker_nginx/example-24.png\" alt=\"alt\"\u003e\u003c/p\u003e\n\u003cp\u003e改下 nginx 配置，添加个路由：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-code\"\u003e    location ^~ /v1 {\n        proxy_pass http://192.168.21.242:3000;\n    }    \n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e这个路由是根据前缀匹配 /v1 开头的 url， ^~ 是提高优先级用的.\u003c/p\u003e\n\u003cp\u003e然后你访问 \u003ca href=\"http://localhost:8001/v1\"\u003ehttp://localhost:8001/v1\u003c/a\u003e 就可以看到 nest 服务返回的响应了：\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/docker_nginx/example-25.png\" alt=\"alt\"\u003e\u003c/p\u003e\n\u003cp\u003e为什么要多 nginx 这一层代理呢？\u003c/p\u003e\n\u003cp\u003e自然是可以在这一层做很多事情的.\u003c/p\u003e\n\u003cp\u003e比如修改 header：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-code\"\u003e    location ^~ /v1 {\n        proxy_set_header name liyu; #新增\n        proxy_pass http://192.168.21.242:3000;\n    }    \n\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e在 nest 服务的 handler 里注入 headers，打印一下：\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/docker_nginx/example-26.png\" alt=\"alt\"\u003e\u003c/p\u003e\n\u003cp\u003e然后浏览器访问下.\u003c/p\u003e\n\u003cp\u003e直接访问 nest 服务的话，是没有这个 header 的：\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/docker_nginx/example-27.png\" alt=\"alt\"\u003e\u003c/p\u003e\n\u003cp\u003e访问 nginx 的反向代理服务器，做一次中转：\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/docker_nginx/example-28.png\" alt=\"alt\"\u003e\u003c/p\u003e\n\u003cp\u003e这就是反向代理服务器的作用，可以透明的修改请求、响应.\u003c/p\u003e\n\u003cp\u003e而且，还可以用它实现负载均衡.\u003c/p\u003e\n\u003cp\u003e在 controlller 里打印下访问日志, 并修改端口 3001, 新开端口重新使用 \u003ccode\u003eyarn start\u003c/code\u003e 启动服务\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/docker_nginx/example-29.png\" alt=\"alt\"\u003e\u003c/p\u003e\n\u003cp\u003e这个时候, 我们就有 3000 和 3001 两个服务了, 浏览器访问下, 都是正常的\n\u003cimg src=\"/assets/docker_nginx/example-30.png\" alt=\"alt\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/docker_nginx/example-31.png\" alt=\"alt\"\u003e\u003c/p\u003e\n\u003cp\u003e问题来了，现在有一个 nginx 服务器，两个 nest 服务器了，nginx 该如何应对呢？\u003c/p\u003e\n\u003cp\u003enginx 的解决方式就是负载均衡，把请求按照一定的规则分到不同的服务器.\u003c/p\u003e\n\u003cp\u003e改下 nginx 配置文件：\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/docker_nginx/example-32.png\" alt=\"alt\"\u003e\u003c/p\u003e\n\u003cp\u003e在 upstream 里配置它代理的目标服务器的所有实例.\u003c/p\u003e\n\u003cp\u003e下面 proxy_pass 通过 upstream 的名字来指定.\u003c/p\u003e\n\u003cp\u003e这时候我访问 \u003ca href=\"http://localhost:8001/v1\"\u003ehttp://localhost:8001/v1\u003c/a\u003e 刷新 5 次页面：\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/docker_nginx/example-33.png\" alt=\"alt\"\u003e\u003c/p\u003e\n\u003cp\u003e可以看到两个 nest 服务，一个 3 次，一个 2 次.\u003c/p\u003e\n\u003cp\u003e因为默认是轮询的方式.\u003c/p\u003e\n\u003cp\u003e一共有 4 种负载均衡策略：\u003c/p\u003e\n\u003cp\u003e轮询：默认方式.\nweight：在轮询基础上增加权重，也就是轮询到的几率不同.\nip_hash：按照 ip 的 hash 分配，保证每个访客的请求固定访问一个服务器，解决 session 问题.\nfair：按照响应时间来分配，这个需要安装 nginx-upstream-fair 插件.\n我们测试下 weight 和 ip_hash 的方式.\u003c/p\u003e\n\u003cp\u003e添加一个 weight=2，默认是 1，这样两个服务器轮询到的几率是 2 比 1.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/docker_nginx/example-34.png\" alt=\"alt\"\u003e\u003c/p\u003e\n\u003cp\u003e然后我访问了 8 次 \u003ca href=\"http://localhost:8001/v1\"\u003ehttp://localhost:8001/v1\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e看打印的日志来看，差不多就是 2:1 的轮询几率.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/docker_nginx/example-35.png\" alt=\"alt\"\u003e\u003c/p\u003e\n\u003cp\u003e这就是带权重的轮询.\u003c/p\u003e\n\u003cp\u003e我们再试下 ip_hash 的方式；\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/docker_nginx/example-36.png\" alt=\"alt\"\u003e\u003c/p\u003e\n\u003cp\u003e再次访问了 \u003ca href=\"http://localhost:8001/v1\"\u003ehttp://localhost:8001/v1\u003c/a\u003e\n可以看到一直请求到了一台服务器：\n\u003cimg src=\"/assets/docker_nginx/example-37.png\" alt=\"alt\"\u003e\u003c/p\u003e\n\u003cp\u003e这就是 Nginx 的负载均衡的策略.\u003c/p\u003e\n\u003cp\u003e这就是 Nginx 的负载均衡的策略.\u003c/p\u003e\n\u003ch2 id=\"总结\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#总结\"\u003e\u003cspan class=\"icon icon-link\"\u003e\u003c/span\u003e\u003c/a\u003e总结\u003c/h2\u003e\n\u003cp\u003e我们通过 docker 跑了 nginx 服务器，并使用了它的静态资源托管功能，还有动态资源的反向代理功能.\u003c/p\u003e\n\u003cp\u003enginx 的配置文件在 /etc/nginx/nginx.conf 里，它默认还引入了 /etc/nginx/conf.d 下的子配置文件.\u003c/p\u003e\n\u003cp\u003e默认 html 都放在 /usr/share/nginx/html 下.\u003c/p\u003e\n\u003cp\u003e我们可以通过 docker cp 来把容器内文件复制到宿主机, 然后进行文件映射, 最后通过修改宿主上的配置文件来修改容器中的配置文件.\u003c/p\u003e\n\u003cp\u003e修改 nginx 配置，在 server 里配置路由，根据不同的 url 返回不同的静态文件.\u003c/p\u003e\n\u003cp\u003e有 4 种 location 语法：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003elocation /aaa 根据前缀匹配\u003c/li\u003e\n\u003cli\u003elocation ^~ /aaa 根据前缀匹配，优先级更高\u003c/li\u003e\n\u003cli\u003elocation = /aaa 精准匹配\u003c/li\u003e\n\u003cli\u003elocation ~ /aaa/.*html 正则匹配\n\u003ccode\u003elocation ~* /aaa/.*html\u003c/code\u003e正则匹配，而且不区分大小写\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e优先级是 精确匹配（=） \u003e 高优先级前缀匹配（^~） \u003e 正则匹配（～ ~*） \u003e 普通前缀匹配\u003c/p\u003e\n\u003cp\u003e除了静态资源托管外，nginx 还可以对动态资源做反向代理.\u003c/p\u003e\n\u003cp\u003e也就是请求发给 nginx，由它转发给应用服务器，这一层也可以叫做网关.\u003c/p\u003e\n\u003cp\u003enginx 反向代理可以修改请求、响应信息，比如设置 header.\u003c/p\u003e\n\u003cp\u003e当有多台应用服务器的时候，可以通过 upstream 配置负载均衡，有 4 种策略：轮询、带权重的轮询、ip_hash、fair.\u003c/p\u003e\n\u003cp\u003e掌握了静态资源托管、动态资源的反向代理+负载均衡.\u003c/p\u003e"])</script><script>self.__next_f.push([1,"7:[\"$\",\"article\",null,{\"children\":[[\"$\",\"div\",null,{\"className\":\"flex justify-center font-[Arial] max-w-[864px] text-center\",\"children\":[\"$\",\"h1\",null,{\"className\":\"text-[2.5rem] font-bold bg-lime-300 px-5 py-2 rounded-sm text-shadow-lg leading-[1.1]\",\"children\":\"结合 Docker, 了解 Nginx 的两个用法\"}]}],[\"$\",\"time\",null,{\"dateTime\":\"2023-08-20\",\"className\":\"text-center block my-4 text-sm opacity-60\",\"children\":\"August\\t20, 2023\"}],[null,[\"$\",\"$L18\",null,{\"theme\":\"fancy\"}],[\"$\",\"section\",null,{\"className\":\"markdown-body-fancy max-w-3xl\",\"dangerouslySetInnerHTML\":{\"__html\":\"$19\"}}]],null]}]\n"])</script><script>self.__next_f.push([1,"11:[[\"$\",\"meta\",\"0\",{\"charSet\":\"utf-8\"}],[\"$\",\"meta\",\"1\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}]]\nb:null\n"])</script><script>self.__next_f.push([1,"17:{\"metadata\":[[\"$\",\"title\",\"0\",{\"children\":\"Ai.Haibara codes\"}],[\"$\",\"meta\",\"1\",{\"name\":\"description\",\"content\":\"LZS Blog\"}],[\"$\",\"link\",\"2\",{\"rel\":\"icon\",\"href\":\"/favicon.ico\",\"type\":\"image/x-icon\",\"sizes\":\"96x96\"}]],\"error\":null,\"digest\":\"$undefined\"}\ne:{\"metadata\":\"$17:metadata\",\"error\":null,\"digest\":\"$undefined\"}\n"])</script></body></html>