<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><link rel="apple-touch-icon" sizes="180x180" href="/favicon/apple-touch-icon.png"/><link rel="icon" type="image/png" sizes="32x32" href="/favicon/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="16x16" href="/favicon/favicon-16x16.png"/><link rel="manifest" href="/favicon/site.webmanifest"/><link rel="mask-icon" href="/favicon/safari-pinned-tab.svg" color="#000000"/><link rel="shortcut icon" href="/favicon/favicon.ico"/><meta name="msapplication-TileColor" content="#000000"/><meta name="msapplication-config" content="/favicon/browserconfig.xml"/><meta name="theme-color" content="#000"/><link rel="alternate" type="application/rss+xml" href="/feed.xml"/><meta property="og:image" content="https://og-image.vercel.app/Next.js%20Blog%20Starter%20Example.png?theme=light&amp;md=1&amp;fontSize=100px&amp;images=https%3A%2F%2Fassets.vercel.com%2Fimage%2Fupload%2Ffront%2Fassets%2Fdesign%2Fnextjs-black-logo.svg"/><title>Next.js 学习记录 | Ai.Haibara codes</title><meta name="next-head-count" content="14"/><link rel="preload" href="/_next/static/css/8681f744d5932be6.css" as="style"/><link rel="stylesheet" href="/_next/static/css/8681f744d5932be6.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-8fa1640cc84ba8fe.js" defer=""></script><script src="/_next/static/chunks/framework-3b5a00d5d7e8d93b.js" defer=""></script><script src="/_next/static/chunks/main-59a90320855f5cf5.js" defer=""></script><script src="/_next/static/chunks/pages/_app-f46e289d7ac5e197.js" defer=""></script><script src="/_next/static/chunks/799-575b46febca3af7d.js" defer=""></script><script src="/_next/static/chunks/399-cac0cd8ed02bf02a.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bslug%5D-e2afa3a98c674f72.js" defer=""></script><script src="/_next/static/ZAPbhu4b3AldmiEw_k7-s/_buildManifest.js" defer=""></script><script src="/_next/static/ZAPbhu4b3AldmiEw_k7-s/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="min-h-screen"><header class="text-white bg-black drop-shadow-2xl"><div class="mx-auto my-0 max-w-[960px] py-6 px-4 flex items-center"><div class="flex items-center"><img alt="Ai.Haibara" src="/assets/blog/authors/haibara_2.jpg" width="100" height="100" decoding="async" data-nimg="1" class=" rounded-full" loading="lazy" style="color:transparent"/></div><div class="ml-6"><a class=" font-bold text-3xl" href="/">Ai.Haibara codes</a><div class="mt-2"><a class="p-1 rounded-sm text-xl mr-2 hover:border-b-2 border-indigo" href="/">Home</a><a class="p-1 rounded-sm text-xl mr-2 hover:border-b-2 border-indigo" href="/projects">Projects</a><a class="p-1 rounded-sm text-xl mr-2 hover:border-b-2 border-indigo" href="/talks">Talks</a><a class="p-1 rounded-sm text-xl mr-2 hover:border-b-2 border-indigo" href="/blogs">Blogs</a></div></div></div></header><main class="p-6 flex justify-center"><article><div class="flex justify-center font-[Arial] max-w-[864px] text-center"><h1 class="text-5xl font-bold bg-indigo px-5 py-2 rounded-sm text-shadow-lg leading-[1.1]">Next.js 学习记录</h1></div><time dateTime="2022-09-28" class="text-center block my-4 text-sm opacity-60">September	28, 2022</time><section><div class="markdown-body-condensed-night-purple max-w-3xl"><p><code>Next.js</code> 是一个 <code>React</code> 应用框架, 使用它可以快速上手开发 <code>React</code> 应用. <code>React</code> 作为一个用来构建 <code>UI</code> 的库, 对于开发一个完整的 <code>React</code> 应用是远远不够的.我们还需要构建、打包和运行等开发工具, 比如使用 <code>Babel</code> 转换使用了新特性的 <code>JavaScript</code> 代码、处理 <code>SASS</code> 和 <code>LESS</code> 样式文件等.开发功能时, 除了构建界面, 还需要处理页面路由、获取服务端数据、管理应用状态等.为了让应用对搜索引擎友好, 最好支持服务端渲染.如果自己从零去安装配置各种开发工具, 需要花费许多时间和精力, 因此 <code>React</code> 官方提供了 <code>Create React App</code>（简称 <code>CRA</code> ）工具来降低上手开发 <code>React</code> 应用的门槛. <code>Next.js</code> 可以看作是 <code>CRA</code> 的升级版.</p>
<h3 id="初始化-nextjs-app"><a aria-hidden="true" tabindex="-1" href="#初始化-nextjs-app"><span class="icon icon-link"></span></a>初始化 Next.js APP</h3>
<p>进入项目文件夹后执行:</p>
<p><code>npx create-next-app Next.js-blog --use-npm --example "https://github.com/vercel/next-learn/tree/master/basics/learn-starter"</code></p>
<p>关于 <code>npx</code>: <a href="https://medium.com/itsems-frontend/whats-npx-e83400efe7f8">https://medium.com/itsems-frontend/whats-npx-e83400efe7f8</a></p>
<p><code>--example "https://github.com/vercel/next-learn/tree/master/basics/learn-starter"</code> 指定链接地址作为初始化项目的模板</p>
<h3 id="项目目录结构"><a aria-hidden="true" tabindex="-1" href="#项目目录结构"><span class="icon icon-link"></span></a>项目目录结构</h3>
<ol>
<li><code>pages</code>(必需):<code>pages</code> 目录是 <code>Next.js</code> 中最重要的一个目录, 这个目录的每一个文件都会对应到每一个页面, 可以根据地址栏的路由进行跳转.若 <code>pages</code> 下的 <code>js</code> 文件在一个目录下, 那么 <code>Next.js</code> 默认会将这个目录也当作路由的路径.</li>
<li><code>components</code>(非必需): <code>components</code> 目录存放的是一些公用的组件, 这些代码不能放在 <code>pages</code> 下, 不然的话就会以页面的形式进行导出.</li>
<li><code>lib</code>(非必需):<code>lib</code> 目录存放一些工具方法, 比如 <code>util</code> 等等.</li>
<li><code>static</code>(非必需):<code>static</code> 目录存放一些静态资源文件.</li>
</ol>
<h3 id="默认文件"><a aria-hidden="true" tabindex="-1" href="#默认文件"><span class="icon icon-link"></span></a>默认文件</h3>
<p><code>index.js</code>: <code>Next.js</code> 的 <code>pages</code> 下默认入口文件, 这个文件会对应浏览器地址栏为根路径的那个页面.</p>
<h3 id="内置组件"><a aria-hidden="true" tabindex="-1" href="#内置组件"><span class="icon icon-link"></span></a>内置组件</h3>
<ol>
<li>
<p><code>Link</code>: 网页中两个页面之间的跳转一般使用 <code>a</code> 标签. 在 <code>Next.js</code> 中, 可以使用 <code>Link</code> 组件 <code>next/link</code> 在应用程序中的页面之间进行链接. <code>Link</code> 允许进行客户端导航并接受一些属性.</p>
<pre><code class="language-JavaScript">//index.js
import Link from 'next/link';


// href="/posts/first-post" : 跳转至 pages 目录下的 posts/first-post.js
&#x3C;h1 className="title">
  Read &#x3C;Link href="/posts/first-post">this page!&#x3C;/Link>
&#x3C;/h1>
</code></pre>
<p>在 pages 目录下新建 posts/first-post.js</p>
<pre><code class="language-JavaScript">//posts/first-post.js
import Link from 'next/link';

export default function FirstPost() {
  return (
    &#x3C;>
      &#x3C;h1>First Post&#x3C;/h1>
      &#x3C;h2>
        &#x3C;Link href="/">Back to home&#x3C;/Link>
      &#x3C;/h2>
    &#x3C;/>
  );
}
</code></pre>
</li>
<li>
<p><code>Image</code>: 提供对图片资源自动进行优化的功能.</p>
<p>使用常规 HTML 添加个人资料图片如下所示:</p>
<pre><code class="language-HTML">  &#x3C;img src="/images/profile.jpg" alt="Your Name" />
</code></pre>
<p>这种情况下必须手动处理:</p>
<ul>
<li>确保您的图像在不同的屏幕尺寸上响应</li>
<li>使用第三方工具或库优化您的图像</li>
<li>仅在图像进入视口时加载图像</li>
</ul>
<p>使用图像组件</p>
<pre><code class="language-JavaScript">import Image from 'next/image';

const YourComponent = () => (
  &#x3C;Image
    src="/images/profile.jpg" // Route of the image file
    height={144} // Desired size with correct aspect ratio
    width={144} // Desired size with correct aspect ratio
    alt="Your Name"
  />
);
</code></pre>
<p><code>Next.js</code> 不是在构建时优化图像, 而是在用户请求时按需优化图像.与静态站点生成器和纯静态解决方案不同, 构建时间不会增加, 无论是发送 10 个图像还是 1000 万个图像.</p>
<p>默认情况下, 图像是延迟加载的.这意味着您的页面速度不会因视口之外的图像而受到惩罚.图像在滚动到视口时加载.</p>
</li>
<li>
<p><code>Head</code>: 代替 <code>Html5</code> 中的 <code>&#x3C;head></code> 标签</p>
<pre><code class="language-Html"> &#x3C;Head>
   &#x3C;title>Create Next App&#x3C;/title>
   &#x3C;link rel="icon" href="/favicon.ico" />
 &#x3C;/Head>
</code></pre>
</li>
</ol>
<h3 id="关于-css"><a aria-hidden="true" tabindex="-1" href="#关于-css"><span class="icon icon-link"></span></a>关于 CSS</h3>
<ol>
<li>
<p><code>css</code> 模块. <code>css</code> 模块允许通过自动创建唯一的类名来在组件级别本地限定 <code>css</code>. 这允许您在不同的文件中使用相同的 <code>css</code> 类名, 而不必担心类名冲突</p>
<p><code>utils.module.cs</code></p>
<pre><code class="language-css">.maxW100{
  max-width:100rem;
}
``
pages/index.j
```jsx
import utilStyles from "../styles/utils.module.css";

&#x3C;div className={utilStyles.maxW100}>test style&#x3C;/div>
``

</code></pre>
</li>
<li>
<p>通过其他方式来设置 <code>Next.js</code> 应用程序的样式</p>
<ul>
<li><code>SASS</code></li>
<li><code>PostCss</code> 库, 例如 <a href="https://tailwindcss.com/docs/installation">TailwindCss</a></li>
<li><code>CSS-in-JS</code> 库, 例如 <a href="https://nextjs.org/blog/styling-next-with-styled-jsx">styled-jsx</a>、<a href="https://styled-components.com/">styled-components</a> 和 [Emotion](<a href="https://github.com/emotion-js/emotion">https://github.com/emotion-js/emotion</a></li>
</ul>
</li>
<li>
<p>添加全局样式时, 需要创建一个名为 <code>pages/_app.js</code> 的文件, 其内容如下</p>
<pre><code class="language-jsx">import '../styles/global.css';
export default function App({ Component, pageProps }) {
  return &#x3C;Component {...pageProps} />;
}
</code></pre>
<p>该 <code>App</code> 组件是所有不同页面通用的顶级组件.</p>
</li>
</ol>
<h3 id="预渲染与数据获取"><a aria-hidden="true" tabindex="-1" href="#预渲染与数据获取"><span class="icon icon-link"></span></a>预渲染与数据获取</h3>
<ol>
<li>
<p><code>Next.js</code> 的预渲染功能</p>
<ul>
<li>
<p>什么是预渲染</p>
<p>默认情况下, <code>Next.js</code> 预渲染每个页面.这意味着 <code>Next.js</code> 会提前为每个页面生成 <code>HTML</code>, 而不是全部由客户端 <code>JavaScript</code> 完成.预渲染可以带来更好的性能和 <a href="https://zh.wikipedia.org/wiki/%E6%90%9C%E5%B0%8B%E5%BC%95%E6%93%8E%E6%9C%80%E4%BD%B3%E5%8C%96">SEO</a>.</p>
<p>每个生成的 HTML 都与该页面所需的最少 <code>JavaScript</code> 代码相关联.当浏览器加载页面时, 其 <code>JavaScript</code> 代码将运行并使页面完全交互.(这个过程称为水合作用.)</p>
</li>
<li>
<p>两种形式的预渲染</p>
<ol>
<li><code>SSR</code>: 服务器端渲染是在每个请求上生成 <code>HTML</code> 的预渲染方法.</li>
<li><code>SSG</code>: 静态生成是在构建时生成 <code>HTML</code> 的预渲染方法.然后在每个请求上重用预呈现的 HTML</li>
</ol>
</li>
<li>
<p><code>SSG</code>: 静态生成
<code>Next.js</code> 提供了 <code>getStaticProps</code> 这样一个方法, 将其定义在需要获取数据的页面组件中, 并将其导出.
两个注意点:</p>
<ol>
<li><code>dev</code> 环境中, <code>getStaticProps</code> 会在每一个请求上运行, <code>product</code> 环境会在构建时运行</li>
<li>在函数内部可以获取外部的数据并将其以 <code>props</code> 的形式传递至组件中</li>
</ol>
<pre><code class="language-jsx">const Home = (props) => { ... }
export const getStaticProps = async () => {
  const data = [];

  return {
    props: data
  }
}
export default Home
</code></pre>
</li>
<li>
<p><code>SSR</code>: 服务端渲染
如果需要在请求时而不是构建时获取数据, 可以使用服务端渲染. <code>Next.js</code> 同样提供了一个名为 <code>getServerSideProps</code> 的函数.</p>
<pre><code class="language-JavaScript">export const getServerSideProps = (context) => {
  return {
    props:{}
  }
}
</code></pre>
<p>因为 <code>getServerSideProps</code> 是在请求时调用的, 所以它的参数 <code>context</code> 包含了请求特定的参数.</p>
</li>
</ul>
</li>
</ol></div></section></article></main><footer class="bg-neutral-50 border-t border-neutral-200 text-center text-xs opacity-50 py-4">© 2022,<!-- --> <a rel="noopener noreferrer" class="hover:underline hover:bg-indigo" href="https://github.com/LZS911" target="_blank">LZS_911</a>, build with<!-- --> <a rel="noopener noreferrer" class="underline hover:bg-indigo" href="https://nextjs.org/" target="_blank">Next.js</a> <!-- -->and<!-- --> <a rel="noopener noreferrer" class="underline hover:bg-indigo" href="https://pages.github.com/?(null)" target="_blank">GitHub Pages</a></footer></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"Next.js 学习记录","date":"2022-09-28","slug":"Next.js 学习记录","author":"LZS_911","content":"\u003cp\u003e\u003ccode\u003eNext.js\u003c/code\u003e 是一个 \u003ccode\u003eReact\u003c/code\u003e 应用框架, 使用它可以快速上手开发 \u003ccode\u003eReact\u003c/code\u003e 应用. \u003ccode\u003eReact\u003c/code\u003e 作为一个用来构建 \u003ccode\u003eUI\u003c/code\u003e 的库, 对于开发一个完整的 \u003ccode\u003eReact\u003c/code\u003e 应用是远远不够的.我们还需要构建、打包和运行等开发工具, 比如使用 \u003ccode\u003eBabel\u003c/code\u003e 转换使用了新特性的 \u003ccode\u003eJavaScript\u003c/code\u003e 代码、处理 \u003ccode\u003eSASS\u003c/code\u003e 和 \u003ccode\u003eLESS\u003c/code\u003e 样式文件等.开发功能时, 除了构建界面, 还需要处理页面路由、获取服务端数据、管理应用状态等.为了让应用对搜索引擎友好, 最好支持服务端渲染.如果自己从零去安装配置各种开发工具, 需要花费许多时间和精力, 因此 \u003ccode\u003eReact\u003c/code\u003e 官方提供了 \u003ccode\u003eCreate React App\u003c/code\u003e（简称 \u003ccode\u003eCRA\u003c/code\u003e ）工具来降低上手开发 \u003ccode\u003eReact\u003c/code\u003e 应用的门槛. \u003ccode\u003eNext.js\u003c/code\u003e 可以看作是 \u003ccode\u003eCRA\u003c/code\u003e 的升级版.\u003c/p\u003e\n\u003ch3 id=\"初始化-nextjs-app\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#初始化-nextjs-app\"\u003e\u003cspan class=\"icon icon-link\"\u003e\u003c/span\u003e\u003c/a\u003e初始化 Next.js APP\u003c/h3\u003e\n\u003cp\u003e进入项目文件夹后执行:\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003enpx create-next-app Next.js-blog --use-npm --example \"https://github.com/vercel/next-learn/tree/master/basics/learn-starter\"\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e关于 \u003ccode\u003enpx\u003c/code\u003e: \u003ca href=\"https://medium.com/itsems-frontend/whats-npx-e83400efe7f8\"\u003ehttps://medium.com/itsems-frontend/whats-npx-e83400efe7f8\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003e--example \"https://github.com/vercel/next-learn/tree/master/basics/learn-starter\"\u003c/code\u003e 指定链接地址作为初始化项目的模板\u003c/p\u003e\n\u003ch3 id=\"项目目录结构\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#项目目录结构\"\u003e\u003cspan class=\"icon icon-link\"\u003e\u003c/span\u003e\u003c/a\u003e项目目录结构\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003e\u003ccode\u003epages\u003c/code\u003e(必需):\u003ccode\u003epages\u003c/code\u003e 目录是 \u003ccode\u003eNext.js\u003c/code\u003e 中最重要的一个目录, 这个目录的每一个文件都会对应到每一个页面, 可以根据地址栏的路由进行跳转.若 \u003ccode\u003epages\u003c/code\u003e 下的 \u003ccode\u003ejs\u003c/code\u003e 文件在一个目录下, 那么 \u003ccode\u003eNext.js\u003c/code\u003e 默认会将这个目录也当作路由的路径.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ecomponents\u003c/code\u003e(非必需): \u003ccode\u003ecomponents\u003c/code\u003e 目录存放的是一些公用的组件, 这些代码不能放在 \u003ccode\u003epages\u003c/code\u003e 下, 不然的话就会以页面的形式进行导出.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003elib\u003c/code\u003e(非必需):\u003ccode\u003elib\u003c/code\u003e 目录存放一些工具方法, 比如 \u003ccode\u003eutil\u003c/code\u003e 等等.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003estatic\u003c/code\u003e(非必需):\u003ccode\u003estatic\u003c/code\u003e 目录存放一些静态资源文件.\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3 id=\"默认文件\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#默认文件\"\u003e\u003cspan class=\"icon icon-link\"\u003e\u003c/span\u003e\u003c/a\u003e默认文件\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003eindex.js\u003c/code\u003e: \u003ccode\u003eNext.js\u003c/code\u003e 的 \u003ccode\u003epages\u003c/code\u003e 下默认入口文件, 这个文件会对应浏览器地址栏为根路径的那个页面.\u003c/p\u003e\n\u003ch3 id=\"内置组件\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#内置组件\"\u003e\u003cspan class=\"icon icon-link\"\u003e\u003c/span\u003e\u003c/a\u003e内置组件\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003eLink\u003c/code\u003e: 网页中两个页面之间的跳转一般使用 \u003ccode\u003ea\u003c/code\u003e 标签. 在 \u003ccode\u003eNext.js\u003c/code\u003e 中, 可以使用 \u003ccode\u003eLink\u003c/code\u003e 组件 \u003ccode\u003enext/link\u003c/code\u003e 在应用程序中的页面之间进行链接. \u003ccode\u003eLink\u003c/code\u003e 允许进行客户端导航并接受一些属性.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-JavaScript\"\u003e//index.js\nimport Link from 'next/link';\n\n\n// href=\"/posts/first-post\" : 跳转至 pages 目录下的 posts/first-post.js\n\u0026#x3C;h1 className=\"title\"\u003e\n  Read \u0026#x3C;Link href=\"/posts/first-post\"\u003ethis page!\u0026#x3C;/Link\u003e\n\u0026#x3C;/h1\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e在 pages 目录下新建 posts/first-post.js\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-JavaScript\"\u003e//posts/first-post.js\nimport Link from 'next/link';\n\nexport default function FirstPost() {\n  return (\n    \u0026#x3C;\u003e\n      \u0026#x3C;h1\u003eFirst Post\u0026#x3C;/h1\u003e\n      \u0026#x3C;h2\u003e\n        \u0026#x3C;Link href=\"/\"\u003eBack to home\u0026#x3C;/Link\u003e\n      \u0026#x3C;/h2\u003e\n    \u0026#x3C;/\u003e\n  );\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003eImage\u003c/code\u003e: 提供对图片资源自动进行优化的功能.\u003c/p\u003e\n\u003cp\u003e使用常规 HTML 添加个人资料图片如下所示:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-HTML\"\u003e  \u0026#x3C;img src=\"/images/profile.jpg\" alt=\"Your Name\" /\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e这种情况下必须手动处理:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e确保您的图像在不同的屏幕尺寸上响应\u003c/li\u003e\n\u003cli\u003e使用第三方工具或库优化您的图像\u003c/li\u003e\n\u003cli\u003e仅在图像进入视口时加载图像\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e使用图像组件\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-JavaScript\"\u003eimport Image from 'next/image';\n\nconst YourComponent = () =\u003e (\n  \u0026#x3C;Image\n    src=\"/images/profile.jpg\" // Route of the image file\n    height={144} // Desired size with correct aspect ratio\n    width={144} // Desired size with correct aspect ratio\n    alt=\"Your Name\"\n  /\u003e\n);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003eNext.js\u003c/code\u003e 不是在构建时优化图像, 而是在用户请求时按需优化图像.与静态站点生成器和纯静态解决方案不同, 构建时间不会增加, 无论是发送 10 个图像还是 1000 万个图像.\u003c/p\u003e\n\u003cp\u003e默认情况下, 图像是延迟加载的.这意味着您的页面速度不会因视口之外的图像而受到惩罚.图像在滚动到视口时加载.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003eHead\u003c/code\u003e: 代替 \u003ccode\u003eHtml5\u003c/code\u003e 中的 \u003ccode\u003e\u0026#x3C;head\u003e\u003c/code\u003e 标签\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-Html\"\u003e \u0026#x3C;Head\u003e\n   \u0026#x3C;title\u003eCreate Next App\u0026#x3C;/title\u003e\n   \u0026#x3C;link rel=\"icon\" href=\"/favicon.ico\" /\u003e\n \u0026#x3C;/Head\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3 id=\"关于-css\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#关于-css\"\u003e\u003cspan class=\"icon icon-link\"\u003e\u003c/span\u003e\u003c/a\u003e关于 CSS\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003ecss\u003c/code\u003e 模块. \u003ccode\u003ecss\u003c/code\u003e 模块允许通过自动创建唯一的类名来在组件级别本地限定 \u003ccode\u003ecss\u003c/code\u003e. 这允许您在不同的文件中使用相同的 \u003ccode\u003ecss\u003c/code\u003e 类名, 而不必担心类名冲突\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eutils.module.cs\u003c/code\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-css\"\u003e.maxW100{\n  max-width:100rem;\n}\n``\npages/index.j\n```jsx\nimport utilStyles from \"../styles/utils.module.css\";\n\n\u0026#x3C;div className={utilStyles.maxW100}\u003etest style\u0026#x3C;/div\u003e\n``\n\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e通过其他方式来设置 \u003ccode\u003eNext.js\u003c/code\u003e 应用程序的样式\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eSASS\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ePostCss\u003c/code\u003e 库, 例如 \u003ca href=\"https://tailwindcss.com/docs/installation\"\u003eTailwindCss\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eCSS-in-JS\u003c/code\u003e 库, 例如 \u003ca href=\"https://nextjs.org/blog/styling-next-with-styled-jsx\"\u003estyled-jsx\u003c/a\u003e、\u003ca href=\"https://styled-components.com/\"\u003estyled-components\u003c/a\u003e 和 [Emotion](\u003ca href=\"https://github.com/emotion-js/emotion\"\u003ehttps://github.com/emotion-js/emotion\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e添加全局样式时, 需要创建一个名为 \u003ccode\u003epages/_app.js\u003c/code\u003e 的文件, 其内容如下\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-jsx\"\u003eimport '../styles/global.css';\nexport default function App({ Component, pageProps }) {\n  return \u0026#x3C;Component {...pageProps} /\u003e;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e该 \u003ccode\u003eApp\u003c/code\u003e 组件是所有不同页面通用的顶级组件.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3 id=\"预渲染与数据获取\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#预渲染与数据获取\"\u003e\u003cspan class=\"icon icon-link\"\u003e\u003c/span\u003e\u003c/a\u003e预渲染与数据获取\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003eNext.js\u003c/code\u003e 的预渲染功能\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e什么是预渲染\u003c/p\u003e\n\u003cp\u003e默认情况下, \u003ccode\u003eNext.js\u003c/code\u003e 预渲染每个页面.这意味着 \u003ccode\u003eNext.js\u003c/code\u003e 会提前为每个页面生成 \u003ccode\u003eHTML\u003c/code\u003e, 而不是全部由客户端 \u003ccode\u003eJavaScript\u003c/code\u003e 完成.预渲染可以带来更好的性能和 \u003ca href=\"https://zh.wikipedia.org/wiki/%E6%90%9C%E5%B0%8B%E5%BC%95%E6%93%8E%E6%9C%80%E4%BD%B3%E5%8C%96\"\u003eSEO\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003e每个生成的 HTML 都与该页面所需的最少 \u003ccode\u003eJavaScript\u003c/code\u003e 代码相关联.当浏览器加载页面时, 其 \u003ccode\u003eJavaScript\u003c/code\u003e 代码将运行并使页面完全交互.(这个过程称为水合作用.)\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e两种形式的预渲染\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003ccode\u003eSSR\u003c/code\u003e: 服务器端渲染是在每个请求上生成 \u003ccode\u003eHTML\u003c/code\u003e 的预渲染方法.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eSSG\u003c/code\u003e: 静态生成是在构建时生成 \u003ccode\u003eHTML\u003c/code\u003e 的预渲染方法.然后在每个请求上重用预呈现的 HTML\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003eSSG\u003c/code\u003e: 静态生成\n\u003ccode\u003eNext.js\u003c/code\u003e 提供了 \u003ccode\u003egetStaticProps\u003c/code\u003e 这样一个方法, 将其定义在需要获取数据的页面组件中, 并将其导出.\n两个注意点:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003ccode\u003edev\u003c/code\u003e 环境中, \u003ccode\u003egetStaticProps\u003c/code\u003e 会在每一个请求上运行, \u003ccode\u003eproduct\u003c/code\u003e 环境会在构建时运行\u003c/li\u003e\n\u003cli\u003e在函数内部可以获取外部的数据并将其以 \u003ccode\u003eprops\u003c/code\u003e 的形式传递至组件中\u003c/li\u003e\n\u003c/ol\u003e\n\u003cpre\u003e\u003ccode class=\"language-jsx\"\u003econst Home = (props) =\u003e { ... }\nexport const getStaticProps = async () =\u003e {\n  const data = [];\n\n  return {\n    props: data\n  }\n}\nexport default Home\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003eSSR\u003c/code\u003e: 服务端渲染\n如果需要在请求时而不是构建时获取数据, 可以使用服务端渲染. \u003ccode\u003eNext.js\u003c/code\u003e 同样提供了一个名为 \u003ccode\u003egetServerSideProps\u003c/code\u003e 的函数.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-JavaScript\"\u003eexport const getServerSideProps = (context) =\u003e {\n  return {\n    props:{}\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e因为 \u003ccode\u003egetServerSideProps\u003c/code\u003e 是在请求时调用的, 所以它的参数 \u003ccode\u003econtext\u003c/code\u003e 包含了请求特定的参数.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ol\u003e","ogImage":{"url":"/assets/blog/image/cover.jpg"},"coverImage":"/assets/blog/image/cover.jpg","theme":"condensed-night-purple","tag":["next.js","react"]}},"__N_SSG":true},"page":"/posts/[slug]","query":{"slug":"Next.js 学习记录"},"buildId":"ZAPbhu4b3AldmiEw_k7-s","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>