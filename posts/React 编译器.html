<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><link rel="apple-touch-icon" sizes="180x180" href="/favicon/apple-touch-icon.png"/><link rel="icon" type="image/png" sizes="32x32" href="/favicon/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="16x16" href="/favicon/favicon-16x16.png"/><link rel="manifest" href="/favicon/site.webmanifest"/><link rel="mask-icon" href="/favicon/safari-pinned-tab.svg" color="#000000"/><link rel="shortcut icon" href="/favicon/favicon.ico"/><meta name="msapplication-TileColor" content="#000000"/><meta name="msapplication-config" content="/favicon/browserconfig.xml"/><meta name="theme-color" content="#000"/><link rel="alternate" type="application/rss+xml" href="/feed.xml"/><meta property="og:image" content="https://og-image.vercel.app/Next.js%20Blog%20Starter%20Example.png?theme=light&amp;md=1&amp;fontSize=100px&amp;images=https%3A%2F%2Fassets.vercel.com%2Fimage%2Fupload%2Ffront%2Fassets%2Fdesign%2Fnextjs-black-logo.svg"/><title>React 编译器 | Ai.Haibara codes</title><meta name="next-head-count" content="14"/><link rel="preload" href="/_next/static/css/a5eda337cc81d9ab.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a5eda337cc81d9ab.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee7e63bc15b31913.js" defer=""></script><script src="/_next/static/chunks/framework-3b5a00d5d7e8d93b.js" defer=""></script><script src="/_next/static/chunks/main-319e858aa81ca629.js" defer=""></script><script src="/_next/static/chunks/pages/_app-91d7f786791773ad.js" defer=""></script><script src="/_next/static/chunks/799-575b46febca3af7d.js" defer=""></script><script src="/_next/static/chunks/642-f55f53346f993b53.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bslug%5D-23138caee0f75470.js" defer=""></script><script src="/_next/static/yIbYpMrVODDFyEXyLGSSq/_buildManifest.js" defer=""></script><script src="/_next/static/yIbYpMrVODDFyEXyLGSSq/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="min-h-screen"><header class="text-white bg-black drop-shadow-2xl"><div class="mx-auto my-0 max-w-[960px] py-6 px-4 flex items-center"><div class="flex items-center"><img alt="Ai.Haibara" src="/assets/blog/authors/haibara_2.jpg" width="100" height="100" decoding="async" data-nimg="1" class=" rounded-full" loading="lazy" style="color:transparent"/></div><div class="ml-6"><a class=" font-bold text-3xl" href="/">Ai.Haibara codes</a><div class="mt-2"><a class="p-1 rounded-sm text-xl mr-2 hover:border-b-2 border-indigo" href="/">Home</a><a class="p-1 rounded-sm text-xl mr-2 hover:border-b-2 border-indigo" href="/projects">Projects</a><a class="p-1 rounded-sm text-xl mr-2 hover:border-b-2 border-indigo" href="/talks">Talks</a><a class="p-1 rounded-sm text-xl mr-2 hover:border-b-2 border-indigo" href="/blogs">Blogs</a></div></div></div></header><main class="p-6 flex justify-center"><article><div class="flex justify-center font-[Arial] max-w-[864px] text-center"><h1 class="text-5xl font-bold bg-indigo px-5 py-2 rounded-sm text-shadow-lg leading-[1.1]">React 编译器</h1></div><time dateTime="2024-05-22" class="text-center block my-4 text-sm opacity-60">May	22, 2024</time><section><div class="markdown-body-fancy max-w-3xl"><p>发布于 2022年3月的 React 18 正式版已经“服役”两年多的时间了，现在终于要迎来 React 19 了。这个版本将引入期待已久的全新 <a href="https://react.dev/blog/2024/04/25/react-19">React 19 RC</a> 编译器！它通过自动化优化来简化前端开发流程，减少手动进行记忆化优化的需求。本文就来看看 React 编译器是什么？它是如何工作的？又带来了哪些好处？</p>
<h2 id="react-编译器介绍"><a aria-hidden="true" tabindex="-1" href="#react-编译器介绍"><span class="icon icon-link"></span></a>React 编译器介绍</h2>
<p>React 编译器是一款新的构建时工具，可自动优化 React 应用以提高其性能，尤其是在更新（重新渲染）时。在深入探究 React 编译器的工作原理之前，我们先回顾一下 React 的核心思维模型。</p>
<h3 id="react-心智模型"><a aria-hidden="true" tabindex="-1" href="#react-心智模型"><span class="icon icon-link"></span></a>React 心智模型</h3>
<p>React的核心是一个声明式和基于组件的心智模型。在前端开发中，声明式编程意味着描述 UI 的期望最终状态，而无需通过 DOM 操作来指定达到该状态的每一步。同时，基于组件的方法将 UI 元素分解为可重用、简洁、自包含的构建块，促进了模块化并简化了维护。</p>
<p>为了有效地识别需要更新的特定 DOM 元素，React使用了一个称为虚拟 DOM 的内存中UI表示。当应用状态发生变化时，React会将虚拟DOM与真实DOM进行比较，识别出所需的最小更改集，并精确地更新真实DOM。</p>
<p>简而言之，React的心智模型是：每当应用状态发生变化时，React就会重新渲染。然而，有时React可能会过于“反应灵敏”，导致不必要的重新渲染，从而降低应用的性能。</p>
<h3 id="rerender-的困境"><a aria-hidden="true" tabindex="-1" href="#rerender-的困境"><span class="icon icon-link"></span></a>ReRender 的困境</h3>
<p>React 对应用状态变化的快速响应能力是一把双刃剑。一方面，由于其声明式方法，它简化了前端开发。另一方面，它可能导致 UI 中组件对状态变化的过度重新渲染。</p>
<p>当处理如对象和数组这样的 JavaScript 数据结构时，重新渲染问题尤为常见。问题在于，JavaScript中没有一种计算效率高的方法来比较两个对象或数组是否相等（即具有相同的键和值）。</p>
<p>考虑以下场景：有一个React组件，它在每次渲染时都会生成一个新的对象或数组，如下所示：</p>
<pre><code class="hljs language-jsx"><span class="hljs-keyword">const</span> <span class="hljs-title class_">ListDemo</span>:<span class="hljs-title class_">React</span>.<span class="hljs-property">FC</span> = <span class="hljs-function">() =></span> {
  <span class="hljs-keyword">const</span> list = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>({ <span class="hljs-attr">length</span>: <span class="hljs-number">26</span> }, <span class="hljs-function">(<span class="hljs-params">_, i</span>) =></span> <span class="hljs-title class_">String</span>.<span class="hljs-title function_">fromCharCode</span>(<span class="hljs-number">65</span> + i));

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">div</span>></span>
      <span class="hljs-tag">&#x3C;<span class="hljs-name">h2</span>></span>List Demo<span class="hljs-tag">&#x3C;/<span class="hljs-name">h2</span>></span>
      <span class="hljs-tag">&#x3C;<span class="hljs-name">ul</span>></span>
        {list.map((letter, index) => (
          <span class="hljs-tag">&#x3C;<span class="hljs-name">li</span> <span class="hljs-attr">key</span>=<span class="hljs-string">{index}</span>></span>{letter}<span class="hljs-tag">&#x3C;/<span class="hljs-name">li</span>></span>
        ))}
      <span class="hljs-tag">&#x3C;/<span class="hljs-name">ul</span>></span>
    <span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span></span>
  );
};

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">ListDemo</span>;
</code></pre>
<p>尽管React组件在每次渲染时可能生成内容相同的本地数组，但React无法直接识别出这一点，因此可能会不必要地触发依赖于该数组中值的组件及其嵌套DOM元素的重新渲染，即使 UI 实际上没有变化。这种不受控制的重新渲染会很快导致性能下降，影响用户体验。</p>
<p>为了优化这种情况并减少不必要的重新渲染，React 开发人员可以利用记忆化技术。记忆化允许缓存基于特定输入的计算结果或组件输出，并在输入未变时直接复用这些结果。这种方法能够显著减少组件的重新渲染次数，提高 React 应用的整体性能和效率。</p>
<p>React 提供了以下记忆化工具来帮助我们实现这一目标：</p>
<ul>
<li><code>React.memo()</code>：一个高阶组件，允许基于props的浅比较来避免组件的重新渲染，只要props没有发生变化。</li>
<li><code>useMemo()</code>：用于在组件重新渲染之间缓存计算的结果。只有当依赖项之一发生变化时，useMemo()才会重新计算并返回新的结果。</li>
<li><code>useCallback()</code>：用于缓存函数的定义，确保在依赖项未变时不会重新创建函数。</li>
</ul>
<blockquote>
<p>通过使用useMemo() Hook，可以优化组件，避免在其依赖的数据（如数组）未发生变化时进行不必要的重新渲染。然而，性能优化总是会有成本，但并不总是带来好处。具体可见： <a href="https://kentcdodds.com/blog/usememo-and-usecallback">https://kentcdodds.com/blog/usememo-and-usecallback</a></p>
</blockquote>
<h3 id="react-编译器的诞生"><a aria-hidden="true" tabindex="-1" href="#react-编译器的诞生"><span class="icon icon-link"></span></a>React 编译器的诞生</h3>
<p>React 的记忆化工具确实在提升性能上起到了关键作用，但它们确实增加了开发者的工作量和代码复杂度，因为它要求开发者不仅描述 UI 的状态，还需显式管理渲染的优化。这在一定程度上违背了 React 强调的声明式编程哲学。</p>
<p>为了减轻开发者的负担，理想的解决方案是一个智能的编译器或工具链，它能够自动分析 React 组件的依赖关系，并生成优化的代码。这样的工具能够确保组件仅在状态值发生实质性变化时重新渲染，从而在不牺牲性能的前提下，保持代码的简洁性和可维护性。</p>
<p>为了优化应用程序，React Compiler 会自动记忆代码，也就是说无需开发者再去手动添加 <code>React.memo()</code>、<code>useMemo()</code>、<code>useCallback()</code> 这些记忆优化工具。</p>
<p>编译器利用其对 JavaScript 和 <a href="https://react.dev/reference/rules">React 规则</a> 的了解，自动记住组件和钩子中的值或值组。如果检测到违反规则的情况，它将自动跳过这些组件或钩子，并继续安全地编译其他代码。</p>
<h3 id="编译器做了什么"><a aria-hidden="true" tabindex="-1" href="#编译器做了什么"><span class="icon icon-link"></span></a>编译器做了什么</h3>
<p>首先了解目前 React 中记忆化的主要用例会很有帮助：</p>
<ol>
<li>跳过组件的级联重新渲染（perf）
<ul>
<li>重新渲染会导致组件树中的许多组件重新渲染，即使只有部分组件发生了变化</li>
</ul>
</li>
<li>跳过 React 外部的昂贵计算（perf）
<ul>
<li>例如，expensivelyProcessAReallyLargeArrayOfObjects()在需要该数据的组件或钩子内部调用</li>
</ul>
</li>
<li>将 deps 记忆化为效果
<ul>
<li>确保钩子的依赖项仍在===重新渲染，以防止钩子中的无限循环，例如useEffect()</li>
</ul>
</li>
</ol>
<p>React Compiler 的初始版本主要致力于提高更新性能（即重新渲染现有组件），因此它主要关注前两种用例。</p>
<h4 id="优化-rerender"><a aria-hidden="true" tabindex="-1" href="#优化-rerender"><span class="icon icon-link"></span></a>优化 ReRender</h4>
<p>在以下示例中，每当 <code>&#x3C;FriendList /></code> 的状态发生变化时，<code>&#x3C;MessageButton></code> 都会重新渲染：</p>
<pre><code class="hljs language-jsx"><span class="hljs-keyword">import</span> { useState } <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;
<span class="hljs-keyword">import</span> { useFriendOnlineCount } <span class="hljs-keyword">from</span> <span class="hljs-string">'./hooks/useFriendOnlineCount'</span>;

type <span class="hljs-title class_">Props</span> = {
  <span class="hljs-attr">friends</span>: <span class="hljs-title class_">Array</span>&#x3C;{ <span class="hljs-attr">name</span>: string; <span class="hljs-attr">id</span>: number }>;
};

<span class="hljs-keyword">function</span> <span class="hljs-title function_">NoFriends</span>(<span class="hljs-params"></span>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'====== re render NoFriends ======'</span>);
  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">div</span>></span>no friend<span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span></span>;
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">FriendListCard</span>(<span class="hljs-params">{ friend }: { friend: { name: string; id: number } }</span>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'====== re render FriendListCard ======'</span>);
  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">div</span>></span>friend name: {friend.name}<span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span></span>;
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">MessageButton</span>(<span class="hljs-params"></span>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'====== re render MessageButton ======'</span>);
  <span class="hljs-keyword">const</span> [messageCount, setMessageCount] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">button</span>
      <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =></span> {
        setMessageCount(messageCount + 1);
      }}
    >
      send message
    <span class="hljs-tag">&#x3C;/<span class="hljs-name">button</span>></span></span>
  );
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">FriendList</span>(<span class="hljs-params">{ friends }: Props</span>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'====== re render FriendList ======'</span>);

  <span class="hljs-keyword">const</span> onlineCount = <span class="hljs-title function_">useFriendOnlineCount</span>();
  <span class="hljs-keyword">if</span> (friends.<span class="hljs-property">length</span> === <span class="hljs-number">0</span>) {
    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">NoFriends</span> /></span></span>;
  }
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">div</span>></span>
      <span class="hljs-tag">&#x3C;<span class="hljs-name">span</span>></span>{onlineCount} online<span class="hljs-tag">&#x3C;/<span class="hljs-name">span</span>></span>
      {friends.map((friend) => (
        <span class="hljs-tag">&#x3C;<span class="hljs-name">FriendListCard</span> <span class="hljs-attr">key</span>=<span class="hljs-string">{friend.id}</span> <span class="hljs-attr">friend</span>=<span class="hljs-string">{friend}</span> /></span>
      ))}
      <span class="hljs-tag">&#x3C;<span class="hljs-name">MessageButton</span> /></span>
    <span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span></span>
  );
}

</code></pre>
<blockquote>
<p>当 <code>friends</code> 发生变化后触发的 ReRender</p>
</blockquote>
<p><img src="https://github.com/LZS911/LZS911.github.io/assets/42765421/e5252e3c-2982-4a43-a025-4f0691f97586" alt="image"></p>
<p>React Compiler 自动应用相当于手动记忆的功能，确保只有应用程序的相关部分在状态更改时重新渲染，这有时被称为“细粒度反应性”。在上面的示例中，React Compiler 确定  的返回值即使在 <code>friends</code> 发生引用变化时也可以重用，并且可以避免重新创建此 JSX 时重新渲染 。</p>
<blockquote>
<p>当 <code>friends</code> 发生变化后触发的 ReRender</p>
</blockquote>
<p><img src="https://github.com/LZS911/LZS911.github.io/assets/42765421/6c0022af-8c46-44d4-9ff6-146dcad8fb46" alt="image"></p>
<h4 id="记忆昂贵的计算"><a aria-hidden="true" tabindex="-1" href="#记忆昂贵的计算"><span class="icon icon-link"></span></a>记忆昂贵的计算</h4>
<p>编译器还可以自动记忆第二种用例：</p>
<pre><code class="hljs language-jsx"><span class="hljs-comment">// **Not** memoized by React Compiler, since this is not a component or hook</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">expensivelyProcessAReallyLargeArrayOfObjects</span>(<span class="hljs-params"></span>) { <span class="hljs-comment">/* ... */</span> } 

<span class="hljs-comment">// Memoized by React Compiler since this is a component</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">TableContainer</span>(<span class="hljs-params">{ items }</span>) {
  <span class="hljs-comment">// This function call would be memoized:</span>
  <span class="hljs-keyword">const</span> data = <span class="hljs-title function_">expensivelyProcessAReallyLargeArrayOfObjects</span>(items);
  <span class="hljs-comment">// ...</span>
}
</code></pre>
<p>但是，如果 <code>expensivelyProcessAReallyLargeArrayOfObjects</code> 确实是一个昂贵的函数，您可能需要考虑在 React 之外实现自己的记忆功能，因为：</p>
<ul>
<li>React Compiler 仅记忆 React 组件和 hooks，而不是每个函数</li>
<li>React Compiler 的记忆功能不会在多个组件或钩子之间共享</li>
</ul>
<p>因此，如果 <code>expensivelyProcessAReallyLargeArrayOfObjects</code> 在许多不同的组件中使用，即使传递了相同的项目，也会重复运行昂贵的计算。我们建议先<a href="https://react.dev/reference/react/useMemo#how-to-tell-if-a-calculation-is-expensive">进行分析</a>，看看它是否真的那么昂贵，然后再使代码变得更复杂。</p>
<h4 id="仍在的研究领域useeffect-的记忆"><a aria-hidden="true" tabindex="-1" href="#仍在的研究领域useeffect-的记忆"><span class="icon icon-link"></span></a>仍在的研究领域：useEffect 的记忆</h4>
<p>编译器的记忆化方式有时会与代码最初的记忆化方式不同。通常情况下，这是件好事，因为编译器可以比手动memoize更精细地进行memoize。例如，编译器使用底层原语而不是通过 useMemo 进行记忆化，因此在生成记忆化代码时无需遵循钩子规则，同时仍可安全地对钩子调用进行记忆化。</p>
<p>然而，如果以前以某种方式记忆化的内容不再以完全相同的方式记忆化，这可能会导致问题。最常见的例子是依赖于依赖项不发生变化以防止无限循环或过渡触发——例如 <code>useEffect</code>、<code>useLayoutEffect</code>。</p>
<p>这对于React团队来说仍然是一个研究的开放领域，他们正在寻找解决这个问题的最佳方式。目前，编译器将静态验证自动备忘与现有手动备忘的匹配情况。如果无法证明它们是相同的，组件或钩子将被安全地跳过。</p>
<p>因此，目前建议保留任何现有的useMemo()或useCallback()调用，以确保不改变 useEffect 的行为。React编译器仍将尝试产生更优化的记忆化代码，但如果它不能保持原始的记忆化行为，将跳过编译。</p>
<p>同时，建议不要删除现有的useMemo和useCallback，而是在编写新代码时完全不依赖它们。</p>
<h3 id="react-编译器的预设条件"><a aria-hidden="true" tabindex="-1" href="#react-编译器的预设条件"><span class="icon icon-link"></span></a>React 编译器的预设条件</h3>
<ol>
<li>React 编译器假定您的代码：
<ul>
<li>是有效、符合语义的 JavaScript</li>
<li>在访问可空/可选值和属性之前，测试它们是否已定义（例如，如果使用 TypeScript，则启用 strictNullChecks），即 if (object.nullableProperty) { object.nullableProperty.foo } 或使用可选链 object.nullableProperty?.foo</li>
</ul>
</li>
<li>遵循 <a href="https://react.dev/reference/rules">React 规则</a>
<ul>
<li>React 编译器可以静态验证许多 React 规则，并在检测到错误时跳过编译。要查看错误，建议同时安装 eslint-plugin-react-compiler。</li>
</ul>
</li>
</ol>
<h3 id="react-编译器的作用范围"><a aria-hidden="true" tabindex="-1" href="#react-编译器的作用范围"><span class="icon icon-link"></span></a>React 编译器的作用范围</h3>
<p>目前，React编译器一次只处理一个文件，这意味着它只使用单个文件中的信息来执行其优化。虽然这乍一看可能看起来有限，但由于React使用普通的JavaScript值以及编译器友好的约定和规则的编程模型，这种方法出奇地有效。
当然，也有权衡，比如不能使用另一个文件中的信息，这将允许更细粒度的记忆化。但当前的单文件方法在编译器的复杂性与输出质量之间取得了平衡，结果显示这是一个好的权衡。</p>
<p>虽然编译器目前不使用来自TypeScript或Flow等类型化JavaScript语言的类型信息，但在内部它有自己的类型系统，这有助于它更好地理解代码。</p>
<blockquote>
<p>参考至：</p>
<ol>
<li><a href="https://github.com/reactwg/react-compiler/discussions/5">https://github.com/reactwg/react-compiler/discussions/5</a></li>
<li><a href="https://react.dev/blog/2024/04/25/react-19#actions">https://react.dev/blog/2024/04/25/react-19#actions</a></li>
<li><a href="https://mp.weixin.qq.com/s/5F5HgOmzQLQhcEu8EIZCMw">https://mp.weixin.qq.com/s/5F5HgOmzQLQhcEu8EIZCMw</a></li>
<li><a href="https://react.dev/learn/react-compiler#other-issues">https://react.dev/learn/react-compiler#other-issues</a></li>
</ol>
</blockquote></div></section><div class="mt-10 max-w-3xl"><h3 class="text-2xl font-bold mb-4">评论</h3><p>加载评论中...</p></div></article></main><footer class="bg-neutral-50 border-t border-neutral-200 text-center text-xs opacity-50 py-4">© 2022,<!-- --> <a rel="noopener noreferrer" class="hover:underline hover:bg-indigo" href="https://github.com/LZS911" target="_blank">LZS_911</a>, build with<!-- --> <a rel="noopener noreferrer" class="underline hover:bg-indigo" href="https://nextjs.org/" target="_blank">Next.js</a> <!-- -->and<!-- --> <a rel="noopener noreferrer" class="underline hover:bg-indigo" href="https://pages.github.com/?(null)" target="_blank">GitHub Pages</a></footer></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"React 编译器","date":"2024-05-22","slug":"React 编译器","author":"Ai.Haibara","content":"\u003cp\u003e发布于 2022年3月的 React 18 正式版已经“服役”两年多的时间了，现在终于要迎来 React 19 了。这个版本将引入期待已久的全新 \u003ca href=\"https://react.dev/blog/2024/04/25/react-19\"\u003eReact 19 RC\u003c/a\u003e 编译器！它通过自动化优化来简化前端开发流程，减少手动进行记忆化优化的需求。本文就来看看 React 编译器是什么？它是如何工作的？又带来了哪些好处？\u003c/p\u003e\n\u003ch2 id=\"react-编译器介绍\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#react-编译器介绍\"\u003e\u003cspan class=\"icon icon-link\"\u003e\u003c/span\u003e\u003c/a\u003eReact 编译器介绍\u003c/h2\u003e\n\u003cp\u003eReact 编译器是一款新的构建时工具，可自动优化 React 应用以提高其性能，尤其是在更新（重新渲染）时。在深入探究 React 编译器的工作原理之前，我们先回顾一下 React 的核心思维模型。\u003c/p\u003e\n\u003ch3 id=\"react-心智模型\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#react-心智模型\"\u003e\u003cspan class=\"icon icon-link\"\u003e\u003c/span\u003e\u003c/a\u003eReact 心智模型\u003c/h3\u003e\n\u003cp\u003eReact的核心是一个声明式和基于组件的心智模型。在前端开发中，声明式编程意味着描述 UI 的期望最终状态，而无需通过 DOM 操作来指定达到该状态的每一步。同时，基于组件的方法将 UI 元素分解为可重用、简洁、自包含的构建块，促进了模块化并简化了维护。\u003c/p\u003e\n\u003cp\u003e为了有效地识别需要更新的特定 DOM 元素，React使用了一个称为虚拟 DOM 的内存中UI表示。当应用状态发生变化时，React会将虚拟DOM与真实DOM进行比较，识别出所需的最小更改集，并精确地更新真实DOM。\u003c/p\u003e\n\u003cp\u003e简而言之，React的心智模型是：每当应用状态发生变化时，React就会重新渲染。然而，有时React可能会过于“反应灵敏”，导致不必要的重新渲染，从而降低应用的性能。\u003c/p\u003e\n\u003ch3 id=\"rerender-的困境\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#rerender-的困境\"\u003e\u003cspan class=\"icon icon-link\"\u003e\u003c/span\u003e\u003c/a\u003eReRender 的困境\u003c/h3\u003e\n\u003cp\u003eReact 对应用状态变化的快速响应能力是一把双刃剑。一方面，由于其声明式方法，它简化了前端开发。另一方面，它可能导致 UI 中组件对状态变化的过度重新渲染。\u003c/p\u003e\n\u003cp\u003e当处理如对象和数组这样的 JavaScript 数据结构时，重新渲染问题尤为常见。问题在于，JavaScript中没有一种计算效率高的方法来比较两个对象或数组是否相等（即具有相同的键和值）。\u003c/p\u003e\n\u003cp\u003e考虑以下场景：有一个React组件，它在每次渲染时都会生成一个新的对象或数组，如下所示：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-jsx\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eListDemo\u003c/span\u003e:\u003cspan class=\"hljs-title class_\"\u003eReact\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eFC\u003c/span\u003e = \u003cspan class=\"hljs-function\"\u003e() =\u003e\u003c/span\u003e {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e list = \u003cspan class=\"hljs-title class_\"\u003eArray\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003efrom\u003c/span\u003e({ \u003cspan class=\"hljs-attr\"\u003elength\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e26\u003c/span\u003e }, \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003e_, i\u003c/span\u003e) =\u003e\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eString\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003efromCharCode\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e65\u003c/span\u003e + i));\n\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e (\n    \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eh2\u003c/span\u003e\u003e\u003c/span\u003eList Demo\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eh2\u003c/span\u003e\u003e\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eul\u003c/span\u003e\u003e\u003c/span\u003e\n        {list.map((letter, index) =\u003e (\n          \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eli\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ekey\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{index}\u003c/span\u003e\u003e\u003c/span\u003e{letter}\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eli\u003c/span\u003e\u003e\u003c/span\u003e\n        ))}\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eul\u003c/span\u003e\u003e\u003c/span\u003e\n    \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n  );\n};\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eListDemo\u003c/span\u003e;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e尽管React组件在每次渲染时可能生成内容相同的本地数组，但React无法直接识别出这一点，因此可能会不必要地触发依赖于该数组中值的组件及其嵌套DOM元素的重新渲染，即使 UI 实际上没有变化。这种不受控制的重新渲染会很快导致性能下降，影响用户体验。\u003c/p\u003e\n\u003cp\u003e为了优化这种情况并减少不必要的重新渲染，React 开发人员可以利用记忆化技术。记忆化允许缓存基于特定输入的计算结果或组件输出，并在输入未变时直接复用这些结果。这种方法能够显著减少组件的重新渲染次数，提高 React 应用的整体性能和效率。\u003c/p\u003e\n\u003cp\u003eReact 提供了以下记忆化工具来帮助我们实现这一目标：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eReact.memo()\u003c/code\u003e：一个高阶组件，允许基于props的浅比较来避免组件的重新渲染，只要props没有发生变化。\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003euseMemo()\u003c/code\u003e：用于在组件重新渲染之间缓存计算的结果。只有当依赖项之一发生变化时，useMemo()才会重新计算并返回新的结果。\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003euseCallback()\u003c/code\u003e：用于缓存函数的定义，确保在依赖项未变时不会重新创建函数。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cblockquote\u003e\n\u003cp\u003e通过使用useMemo() Hook，可以优化组件，避免在其依赖的数据（如数组）未发生变化时进行不必要的重新渲染。然而，性能优化总是会有成本，但并不总是带来好处。具体可见： \u003ca href=\"https://kentcdodds.com/blog/usememo-and-usecallback\"\u003ehttps://kentcdodds.com/blog/usememo-and-usecallback\u003c/a\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch3 id=\"react-编译器的诞生\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#react-编译器的诞生\"\u003e\u003cspan class=\"icon icon-link\"\u003e\u003c/span\u003e\u003c/a\u003eReact 编译器的诞生\u003c/h3\u003e\n\u003cp\u003eReact 的记忆化工具确实在提升性能上起到了关键作用，但它们确实增加了开发者的工作量和代码复杂度，因为它要求开发者不仅描述 UI 的状态，还需显式管理渲染的优化。这在一定程度上违背了 React 强调的声明式编程哲学。\u003c/p\u003e\n\u003cp\u003e为了减轻开发者的负担，理想的解决方案是一个智能的编译器或工具链，它能够自动分析 React 组件的依赖关系，并生成优化的代码。这样的工具能够确保组件仅在状态值发生实质性变化时重新渲染，从而在不牺牲性能的前提下，保持代码的简洁性和可维护性。\u003c/p\u003e\n\u003cp\u003e为了优化应用程序，React Compiler 会自动记忆代码，也就是说无需开发者再去手动添加 \u003ccode\u003eReact.memo()\u003c/code\u003e、\u003ccode\u003euseMemo()\u003c/code\u003e、\u003ccode\u003euseCallback()\u003c/code\u003e 这些记忆优化工具。\u003c/p\u003e\n\u003cp\u003e编译器利用其对 JavaScript 和 \u003ca href=\"https://react.dev/reference/rules\"\u003eReact 规则\u003c/a\u003e 的了解，自动记住组件和钩子中的值或值组。如果检测到违反规则的情况，它将自动跳过这些组件或钩子，并继续安全地编译其他代码。\u003c/p\u003e\n\u003ch3 id=\"编译器做了什么\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#编译器做了什么\"\u003e\u003cspan class=\"icon icon-link\"\u003e\u003c/span\u003e\u003c/a\u003e编译器做了什么\u003c/h3\u003e\n\u003cp\u003e首先了解目前 React 中记忆化的主要用例会很有帮助：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e跳过组件的级联重新渲染（perf）\n\u003cul\u003e\n\u003cli\u003e重新渲染会导致组件树中的许多组件重新渲染，即使只有部分组件发生了变化\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e跳过 React 外部的昂贵计算（perf）\n\u003cul\u003e\n\u003cli\u003e例如，expensivelyProcessAReallyLargeArrayOfObjects()在需要该数据的组件或钩子内部调用\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e将 deps 记忆化为效果\n\u003cul\u003e\n\u003cli\u003e确保钩子的依赖项仍在===重新渲染，以防止钩子中的无限循环，例如useEffect()\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eReact Compiler 的初始版本主要致力于提高更新性能（即重新渲染现有组件），因此它主要关注前两种用例。\u003c/p\u003e\n\u003ch4 id=\"优化-rerender\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#优化-rerender\"\u003e\u003cspan class=\"icon icon-link\"\u003e\u003c/span\u003e\u003c/a\u003e优化 ReRender\u003c/h4\u003e\n\u003cp\u003e在以下示例中，每当 \u003ccode\u003e\u0026#x3C;FriendList /\u003e\u003c/code\u003e 的状态发生变化时，\u003ccode\u003e\u0026#x3C;MessageButton\u003e\u003c/code\u003e 都会重新渲染：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-jsx\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { useState } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'react'\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { useFriendOnlineCount } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'./hooks/useFriendOnlineCount'\u003c/span\u003e;\n\ntype \u003cspan class=\"hljs-title class_\"\u003eProps\u003c/span\u003e = {\n  \u003cspan class=\"hljs-attr\"\u003efriends\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eArray\u003c/span\u003e\u0026#x3C;{ \u003cspan class=\"hljs-attr\"\u003ename\u003c/span\u003e: string; \u003cspan class=\"hljs-attr\"\u003eid\u003c/span\u003e: number }\u003e;\n};\n\n\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eNoFriends\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'====== re render NoFriends ======'\u003c/span\u003e);\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003eno friend\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e;\n}\n\n\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eFriendListCard\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e{ friend }: { friend: { name: string; id: number } }\u003c/span\u003e) {\n  \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'====== re render FriendListCard ======'\u003c/span\u003e);\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003efriend name: {friend.name}\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e;\n}\n\n\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eMessageButton\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'====== re render MessageButton ======'\u003c/span\u003e);\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e [messageCount, setMessageCount] = \u003cspan class=\"hljs-title function_\"\u003euseState\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e);\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e (\n    \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ebutton\u003c/span\u003e\n      \u003cspan class=\"hljs-attr\"\u003eonClick\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{()\u003c/span\u003e =\u003e\u003c/span\u003e {\n        setMessageCount(messageCount + 1);\n      }}\n    \u003e\n      send message\n    \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ebutton\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n  );\n}\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eFriendList\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e{ friends }: Props\u003c/span\u003e) {\n  \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'====== re render FriendList ======'\u003c/span\u003e);\n\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e onlineCount = \u003cspan class=\"hljs-title function_\"\u003euseFriendOnlineCount\u003c/span\u003e();\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (friends.\u003cspan class=\"hljs-property\"\u003elength\u003c/span\u003e === \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eNoFriends\u003c/span\u003e /\u003e\u003c/span\u003e\u003c/span\u003e;\n  }\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e (\n    \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003espan\u003c/span\u003e\u003e\u003c/span\u003e{onlineCount} online\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003espan\u003c/span\u003e\u003e\u003c/span\u003e\n      {friends.map((friend) =\u003e (\n        \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eFriendListCard\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ekey\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{friend.id}\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003efriend\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{friend}\u003c/span\u003e /\u003e\u003c/span\u003e\n      ))}\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eMessageButton\u003c/span\u003e /\u003e\u003c/span\u003e\n    \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n  );\n}\n\n\u003c/code\u003e\u003c/pre\u003e\n\u003cblockquote\u003e\n\u003cp\u003e当 \u003ccode\u003efriends\u003c/code\u003e 发生变化后触发的 ReRender\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e\u003cimg src=\"https://github.com/LZS911/LZS911.github.io/assets/42765421/e5252e3c-2982-4a43-a025-4f0691f97586\" alt=\"image\"\u003e\u003c/p\u003e\n\u003cp\u003eReact Compiler 自动应用相当于手动记忆的功能，确保只有应用程序的相关部分在状态更改时重新渲染，这有时被称为“细粒度反应性”。在上面的示例中，React Compiler 确定  的返回值即使在 \u003ccode\u003efriends\u003c/code\u003e 发生引用变化时也可以重用，并且可以避免重新创建此 JSX 时重新渲染 。\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e当 \u003ccode\u003efriends\u003c/code\u003e 发生变化后触发的 ReRender\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e\u003cimg src=\"https://github.com/LZS911/LZS911.github.io/assets/42765421/6c0022af-8c46-44d4-9ff6-146dcad8fb46\" alt=\"image\"\u003e\u003c/p\u003e\n\u003ch4 id=\"记忆昂贵的计算\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#记忆昂贵的计算\"\u003e\u003cspan class=\"icon icon-link\"\u003e\u003c/span\u003e\u003c/a\u003e记忆昂贵的计算\u003c/h4\u003e\n\u003cp\u003e编译器还可以自动记忆第二种用例：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-jsx\"\u003e\u003cspan class=\"hljs-comment\"\u003e// **Not** memoized by React Compiler, since this is not a component or hook\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eexpensivelyProcessAReallyLargeArrayOfObjects\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) { \u003cspan class=\"hljs-comment\"\u003e/* ... */\u003c/span\u003e } \n\n\u003cspan class=\"hljs-comment\"\u003e// Memoized by React Compiler since this is a component\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eTableContainer\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e{ items }\u003c/span\u003e) {\n  \u003cspan class=\"hljs-comment\"\u003e// This function call would be memoized:\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e data = \u003cspan class=\"hljs-title function_\"\u003eexpensivelyProcessAReallyLargeArrayOfObjects\u003c/span\u003e(items);\n  \u003cspan class=\"hljs-comment\"\u003e// ...\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e但是，如果 \u003ccode\u003eexpensivelyProcessAReallyLargeArrayOfObjects\u003c/code\u003e 确实是一个昂贵的函数，您可能需要考虑在 React 之外实现自己的记忆功能，因为：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eReact Compiler 仅记忆 React 组件和 hooks，而不是每个函数\u003c/li\u003e\n\u003cli\u003eReact Compiler 的记忆功能不会在多个组件或钩子之间共享\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e因此，如果 \u003ccode\u003eexpensivelyProcessAReallyLargeArrayOfObjects\u003c/code\u003e 在许多不同的组件中使用，即使传递了相同的项目，也会重复运行昂贵的计算。我们建议先\u003ca href=\"https://react.dev/reference/react/useMemo#how-to-tell-if-a-calculation-is-expensive\"\u003e进行分析\u003c/a\u003e，看看它是否真的那么昂贵，然后再使代码变得更复杂。\u003c/p\u003e\n\u003ch4 id=\"仍在的研究领域useeffect-的记忆\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#仍在的研究领域useeffect-的记忆\"\u003e\u003cspan class=\"icon icon-link\"\u003e\u003c/span\u003e\u003c/a\u003e仍在的研究领域：useEffect 的记忆\u003c/h4\u003e\n\u003cp\u003e编译器的记忆化方式有时会与代码最初的记忆化方式不同。通常情况下，这是件好事，因为编译器可以比手动memoize更精细地进行memoize。例如，编译器使用底层原语而不是通过 useMemo 进行记忆化，因此在生成记忆化代码时无需遵循钩子规则，同时仍可安全地对钩子调用进行记忆化。\u003c/p\u003e\n\u003cp\u003e然而，如果以前以某种方式记忆化的内容不再以完全相同的方式记忆化，这可能会导致问题。最常见的例子是依赖于依赖项不发生变化以防止无限循环或过渡触发——例如 \u003ccode\u003euseEffect\u003c/code\u003e、\u003ccode\u003euseLayoutEffect\u003c/code\u003e。\u003c/p\u003e\n\u003cp\u003e这对于React团队来说仍然是一个研究的开放领域，他们正在寻找解决这个问题的最佳方式。目前，编译器将静态验证自动备忘与现有手动备忘的匹配情况。如果无法证明它们是相同的，组件或钩子将被安全地跳过。\u003c/p\u003e\n\u003cp\u003e因此，目前建议保留任何现有的useMemo()或useCallback()调用，以确保不改变 useEffect 的行为。React编译器仍将尝试产生更优化的记忆化代码，但如果它不能保持原始的记忆化行为，将跳过编译。\u003c/p\u003e\n\u003cp\u003e同时，建议不要删除现有的useMemo和useCallback，而是在编写新代码时完全不依赖它们。\u003c/p\u003e\n\u003ch3 id=\"react-编译器的预设条件\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#react-编译器的预设条件\"\u003e\u003cspan class=\"icon icon-link\"\u003e\u003c/span\u003e\u003c/a\u003eReact 编译器的预设条件\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003eReact 编译器假定您的代码：\n\u003cul\u003e\n\u003cli\u003e是有效、符合语义的 JavaScript\u003c/li\u003e\n\u003cli\u003e在访问可空/可选值和属性之前，测试它们是否已定义（例如，如果使用 TypeScript，则启用 strictNullChecks），即 if (object.nullableProperty) { object.nullableProperty.foo } 或使用可选链 object.nullableProperty?.foo\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e遵循 \u003ca href=\"https://react.dev/reference/rules\"\u003eReact 规则\u003c/a\u003e\n\u003cul\u003e\n\u003cli\u003eReact 编译器可以静态验证许多 React 规则，并在检测到错误时跳过编译。要查看错误，建议同时安装 eslint-plugin-react-compiler。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3 id=\"react-编译器的作用范围\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#react-编译器的作用范围\"\u003e\u003cspan class=\"icon icon-link\"\u003e\u003c/span\u003e\u003c/a\u003eReact 编译器的作用范围\u003c/h3\u003e\n\u003cp\u003e目前，React编译器一次只处理一个文件，这意味着它只使用单个文件中的信息来执行其优化。虽然这乍一看可能看起来有限，但由于React使用普通的JavaScript值以及编译器友好的约定和规则的编程模型，这种方法出奇地有效。\n当然，也有权衡，比如不能使用另一个文件中的信息，这将允许更细粒度的记忆化。但当前的单文件方法在编译器的复杂性与输出质量之间取得了平衡，结果显示这是一个好的权衡。\u003c/p\u003e\n\u003cp\u003e虽然编译器目前不使用来自TypeScript或Flow等类型化JavaScript语言的类型信息，但在内部它有自己的类型系统，这有助于它更好地理解代码。\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e参考至：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/reactwg/react-compiler/discussions/5\"\u003ehttps://github.com/reactwg/react-compiler/discussions/5\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://react.dev/blog/2024/04/25/react-19#actions\"\u003ehttps://react.dev/blog/2024/04/25/react-19#actions\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://mp.weixin.qq.com/s/5F5HgOmzQLQhcEu8EIZCMw\"\u003ehttps://mp.weixin.qq.com/s/5F5HgOmzQLQhcEu8EIZCMw\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://react.dev/learn/react-compiler#other-issues\"\u003ehttps://react.dev/learn/react-compiler#other-issues\u003c/a\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/blockquote\u003e","theme":"fancy"}},"__N_SSG":true},"page":"/posts/[slug]","query":{"slug":"React 编译器"},"buildId":"yIbYpMrVODDFyEXyLGSSq","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>