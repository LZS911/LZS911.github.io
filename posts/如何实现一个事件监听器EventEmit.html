<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><link rel="apple-touch-icon" sizes="180x180" href="/favicon/apple-touch-icon.png"/><link rel="icon" type="image/png" sizes="32x32" href="/favicon/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="16x16" href="/favicon/favicon-16x16.png"/><link rel="manifest" href="/favicon/site.webmanifest"/><link rel="mask-icon" href="/favicon/safari-pinned-tab.svg" color="#000000"/><link rel="shortcut icon" href="/favicon/favicon.ico"/><meta name="msapplication-TileColor" content="#000000"/><meta name="msapplication-config" content="/favicon/browserconfig.xml"/><meta name="theme-color" content="#000"/><link rel="alternate" type="application/rss+xml" href="/feed.xml"/><meta property="og:image" content="https://og-image.vercel.app/Next.js%20Blog%20Starter%20Example.png?theme=light&amp;md=1&amp;fontSize=100px&amp;images=https%3A%2F%2Fassets.vercel.com%2Fimage%2Fupload%2Ffront%2Fassets%2Fdesign%2Fnextjs-black-logo.svg"/><title>如何实现一个EventEmit? | Ai.Haibara codes</title><meta name="next-head-count" content="14"/><link rel="preload" href="/_next/static/css/8681f744d5932be6.css" as="style"/><link rel="stylesheet" href="/_next/static/css/8681f744d5932be6.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-8fa1640cc84ba8fe.js" defer=""></script><script src="/_next/static/chunks/framework-3b5a00d5d7e8d93b.js" defer=""></script><script src="/_next/static/chunks/main-59a90320855f5cf5.js" defer=""></script><script src="/_next/static/chunks/pages/_app-f46e289d7ac5e197.js" defer=""></script><script src="/_next/static/chunks/799-575b46febca3af7d.js" defer=""></script><script src="/_next/static/chunks/399-cac0cd8ed02bf02a.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bslug%5D-e2afa3a98c674f72.js" defer=""></script><script src="/_next/static/Qfhv06CUT0IfGCtGEzEqq/_buildManifest.js" defer=""></script><script src="/_next/static/Qfhv06CUT0IfGCtGEzEqq/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="min-h-screen"><header class="text-white bg-black drop-shadow-2xl"><div class="mx-auto my-0 max-w-[960px] py-6 px-4 flex items-center"><div class="flex items-center"><img alt="Ai.Haibara" src="/assets/blog/authors/haibara_2.jpg" width="100" height="100" decoding="async" data-nimg="1" class=" rounded-full" loading="lazy" style="color:transparent"/></div><div class="ml-6"><a class=" font-bold text-3xl" href="/">Ai.Haibara codes</a><div class="mt-2"><a class="p-1 rounded-sm text-xl mr-2 hover:border-b-2 border-indigo" href="/">Home</a><a class="p-1 rounded-sm text-xl mr-2 hover:border-b-2 border-indigo" href="/projects">Projects</a><a class="p-1 rounded-sm text-xl mr-2 hover:border-b-2 border-indigo" href="/talks">Talks</a><a class="p-1 rounded-sm text-xl mr-2 hover:border-b-2 border-indigo" href="/blogs">Blogs</a></div></div></div></header><main class="p-6 flex justify-center"><article><div class="flex justify-center font-[Arial] max-w-[864px] text-center"><h1 class="text-5xl font-bold bg-indigo px-5 py-2 rounded-sm text-shadow-lg leading-[1.1]">如何实现一个EventEmit?</h1></div><time dateTime="2022-09-07" class="text-center block my-4 text-sm opacity-60">September	7, 2022</time><section><div class="markdown-body-orange max-w-3xl"><h2 id="eventemit-简介"><a aria-hidden="true" tabindex="-1" href="#eventemit-简介"><span class="icon icon-link"></span></a>EventEmit 简介</h2>
<p><code>node.js</code> 所有的异步 <code>I/O</code> 操作在完成时都会发送一个事件到事件队列. 一个 <code>fs.readStream</code> 对象会在文件被打开的时候触发一个事件. 所有这些产生事件的对象都是 <code>events.EventEmitter</code> 的实例.</p>
<p><code>EventEmit</code> 是 <code>node.js</code> 内置模块 <code>events</code> 提供的一个 <code>class</code>, 在 <code>node.js</code> 环境中可以直接 <code>require</code> 后使用. 在 <code>web</code> 环境中我们可以使用第三方 <code>npm</code> 包或者原生的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/EventTarget">EventTarget</a>. 当然, 也可以自己实现一个类似 <code>node.js</code> 的简易版本.</p>
<p>我们先来看下 <code>EventEmit</code> 的基本使用方法:</p>
<pre><code class="language-javascript">const { EventEmitter } = require('node:events');

const event = new EventEmitter();

const fn = () => {
  console.log('event 事件触发!');
};

//为指定事件注册一个监听器
event.addListener('event', fn);

//触发监听器
event.emit('event');

//移除监听器
event.removeListener('event', fn);
</code></pre>
<p>其中, 当我们添加新的监听器时, <code>newListener</code> 事件会触发, <code>当监听器被移除时，removeListener</code> 事件被触发.</p>
<h3 id="实现的-api-介绍"><a aria-hidden="true" tabindex="-1" href="#实现的-api-介绍"><span class="icon icon-link"></span></a>实现的 Api 介绍</h3>
<ol>
<li>
<p><code>emitter.addListener(eventName, listener)</code> 为指定事件注册一个监听器，接受一个 <code>string</code> (或 <code>symbol</code>) 类型的 <code>eventName</code> 和一个回调函数. 返回值为 <code>EventEmit</code> 的实例, 以便链式调用.</p>
<ul>
<li><code>eventName</code> <code>&#x3C;string></code> | <code>&#x3C;symbol></code></li>
<li><code>listener</code> <code>&#x3C;Function></code></li>
<li><code>Returns</code> <code>&#x3C;EventEmit></code></li>
</ul>
</li>
<li>
<p><code>emitter.emit(eventName, [...args])</code> 同步调用为名为 <code>eventName</code> 的事件注册的每个监听器, 按照它们注册的顺序, 将提供的参数传递给每个侦听器, 如果存在该监听器, 则返回 <code>True</code>, 否则返回 <code>False</code></p>
<ul>
<li><code>eventName</code> <code>&#x3C;string></code> | <code>&#x3C;symbol></code></li>
<li><code>...args</code> <code>&#x3C;any></code></li>
<li><code>Returns</code> <code>&#x3C;boolean></code></li>
</ul>
</li>
<li>
<p><code>emitter.once(eventName, listener)</code> 和 <code>addListener</code> 类似, 但只触发一次, 随后便解除事件监听.</p>
</li>
<li>
<p><code>emitter.removeListener(eventName, listener)</code> 移除指定事件的某个监听回调.</p>
<ul>
<li><code>eventName</code> <code>&#x3C;string></code> | <code>&#x3C;symbol></code></li>
<li><code>listener</code> <code>&#x3C;Function></code></li>
<li><code>Returns</code> <code>&#x3C;EventEmit></code></li>
</ul>
</li>
<li>
<p><code>emitter.removeAllListeners([eventName])</code> 删除所有监听器, 或删除指定 <code>eventName</code> 的监听器.</p>
<ul>
<li><code>eventName</code> <code>&#x3C;string></code> | <code>&#x3C;symbol></code></li>
<li><code>Returns</code> <code>&#x3C;EventEmitter></code></li>
</ul>
</li>
<li>
<p><code>emitter.setMaxListeners(n)</code> 用于修改监听器的默认限制的数量. (默认大于 10 个监听回调时会产生警告)</p>
<ul>
<li><code>n</code> <code>&#x3C;integer></code></li>
<li><code>Returns</code> <code>&#x3C;EventEmitter></code></li>
</ul>
</li>
<li>
<p><code>emitter.getMaxListeners()</code> 获取限制监听器的数量</p>
</li>
<li>
<p><code>emitter.listeners(eventName)</code> 返回名为 <code>eventName</code> 的事件的监听器数组的副本.</p>
<ul>
<li><code>eventName</code> <code>&#x3C;string></code> | <code>&#x3C;symbol></code></li>
<li><code>Returns</code> <code>&#x3C;Function></code></li>
</ul>
</li>
<li>
<p><code>emitter.listenerCount(eventName)</code> 返回监听名为 <code>eventName</code> 的事件的监听器数量</p>
</li>
<li>
<p><code>emitter.on</code> <code>emitter.addListener</code>的别名函数</p>
</li>
<li>
<p><code>emitter.off</code> <code>emitter.removeListener</code>的别名函数</p>
</li>
</ol>
<h3 id="构造函数"><a aria-hidden="true" tabindex="-1" href="#构造函数"><span class="icon icon-link"></span></a>构造函数</h3>
<pre><code class="language-javascript">  #maxListeners = 10;
  constructor() {
    this.listeners = Object.create(null);
    this.#maxListeners = 10;
  }
</code></pre>
<p>其中 <code>listeners</code> 的结构如下:</p>
<pre><code class="language-JSON">{
  "event1": [f1,f2,f3]，
  "event2": [f4,f5]，
  ...
}
</code></pre>
<h3 id="addlistener-方法"><a aria-hidden="true" tabindex="-1" href="#addlistener-方法"><span class="icon icon-link"></span></a>addListener 方法</h3>
<ol>
<li>
<p>判断该事件监听器数组是否初始化，若未初始化，则将 <code>listeners[event]</code> 初始化为数组，并加入监听器 <code>cb</code>, 并触发 <code>newListener</code> 事件.</p>
</li>
<li>
<p>判断该事件的监听器数量是否已超限，超限则报警告.</p>
</li>
<li>
<p>判断数组中是否已存在 <code>cb</code>, 不存在则添加，已存在则不做操作.</p>
</li>
<li>
<p>指定 <code>on</code> 等于 <code>addListener</code> 方法</p>
</li>
</ol>
<pre><code class="language-javascript">  addListener(eventName, cb) {
    if (
      !this.listeners[eventName || !Array.isArray(this.listeners[eventName])]
    ) {
      this.listeners[eventName] = [cb];
      if (eventName !== "newListener") {
        this.emit("newListener");
      }
      return this;
    }
    if (this.listeners[eventName].length >= this.#maxListeners) {
      console.error(
        "MaxListenersExceededWarning: Possible EventEmitter memory leak detected. %d event6 listeners added to [EventEmitter]. Use emitter.setMaxListeners() to increase limit",
        this.#maxListeners
      );
    }

    this.listeners[eventName].push(cb);
    return this;
  }

</code></pre>
<h3 id="emit-方法"><a aria-hidden="true" tabindex="-1" href="#emit-方法"><span class="icon icon-link"></span></a>emit 方法</h3>
<p>遍历监听器,通过 <code>apply</code> 方法把上面得到的 <code>args</code> 参数传进去, 需要注意的是不要漏了返回值.</p>
<pre><code class="language-javascript">  emit(eventName, ...args) {
    const isExistEvent =
      this.listeners[eventName] &#x26;&#x26; this.listeners[eventName].length > 0;

    if (isExistEvent) {
      this.listeners[eventName].forEach((cb) => {
        cb.apply(null, args);
      });
    }
    return isExistEvent;
  }
</code></pre>
<h3 id="removelistener-方法"><a aria-hidden="true" tabindex="-1" href="#removelistener-方法"><span class="icon icon-link"></span></a>removeListener 方法</h3>
<pre><code class="language-javascript">  removeListener(eventName, listener) {
    const index = (this.listeners[eventName] || []).indexOf(listener);
    if (index !== -1) {
      this.listeners[eventName].splice(index, 1);
      if (eventName !== "removeListener") {
        this.emit("removeListener");
      }
    }
    return this;
  }
</code></pre>
<h3 id="once-方法"><a aria-hidden="true" tabindex="-1" href="#once-方法"><span class="icon icon-link"></span></a>once 方法</h3>
<p><code>once</code> 方法是 <code>on</code> 方法和 <code>removeListener</code> 方法的结合：用 <code>on</code> 方法监听，在回调结束的最后位置，通过<code>removeListener</code> 删掉监听函数自身</p>
<pre><code class="language-javascript">  once(eventName, listener) {
    const fn = (...args) => {
      listener.apply(null, args);
      this.removeListener(eventName, fn);
    };
    this.on(eventName, fn);
    return this;
  }
</code></pre>
<h3 id="removealllisteners-方法"><a aria-hidden="true" tabindex="-1" href="#removealllisteners-方法"><span class="icon icon-link"></span></a>removeAllListeners 方法</h3>
<pre><code class="language-javascript">  removeAllListeners(eventNames = []) {
    if (eventNames.length === 0) {
      this.listeners = Object.create(null);
    } else {
      eventNames.forEach((v) => {
        this.listeners[v] = null;
      });
    }
    return this;
  }
</code></pre>
<h3 id="setmaxlistenersgetmaxlistenerslistenercountonoff-方法"><a aria-hidden="true" tabindex="-1" href="#setmaxlistenersgetmaxlistenerslistenercountonoff-方法"><span class="icon icon-link"></span></a>setMaxListeners、getMaxListeners、listenerCount、on、off 方法</h3>
<pre><code class="language-javascript">  setMaxListeners(maxListeners) {
    this.#maxListeners = maxListeners;
  }
  getMaxListeners() {
    return this.#maxListeners;
  }
  listenerCount(eventName) {
    return this.listeners[eventName]?.length ?? 0;
  }

  EventEmitter.prototype.on = EventEmitter.prototype.addListener;
  EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
</code></pre>
<h4 id="完整代码地址-httpsgithubcomlzs911eventemit"><a aria-hidden="true" tabindex="-1" href="#完整代码地址-httpsgithubcomlzs911eventemit"><span class="icon icon-link"></span></a>完整代码地址: <a href="https://github.com/LZS911/EventEmit">https://github.com/LZS911/EventEmit</a></h4></div></section></article></main><footer class="bg-neutral-50 border-t border-neutral-200 text-center text-xs opacity-50 py-4">© 2022,<!-- --> <a rel="noopener noreferrer" class="hover:underline hover:bg-indigo" href="https://github.com/LZS911" target="_blank">LZS_911</a>, build with<!-- --> <a rel="noopener noreferrer" class="underline hover:bg-indigo" href="https://nextjs.org/" target="_blank">Next.js</a> <!-- -->and<!-- --> <a rel="noopener noreferrer" class="underline hover:bg-indigo" href="https://pages.github.com/?(null)" target="_blank">GitHub Pages</a></footer></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"如何实现一个EventEmit?","date":"2022-09-07","slug":"如何实现一个事件监听器EventEmit","author":"LZS_911","content":"\u003ch2 id=\"eventemit-简介\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#eventemit-简介\"\u003e\u003cspan class=\"icon icon-link\"\u003e\u003c/span\u003e\u003c/a\u003eEventEmit 简介\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003enode.js\u003c/code\u003e 所有的异步 \u003ccode\u003eI/O\u003c/code\u003e 操作在完成时都会发送一个事件到事件队列. 一个 \u003ccode\u003efs.readStream\u003c/code\u003e 对象会在文件被打开的时候触发一个事件. 所有这些产生事件的对象都是 \u003ccode\u003eevents.EventEmitter\u003c/code\u003e 的实例.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eEventEmit\u003c/code\u003e 是 \u003ccode\u003enode.js\u003c/code\u003e 内置模块 \u003ccode\u003eevents\u003c/code\u003e 提供的一个 \u003ccode\u003eclass\u003c/code\u003e, 在 \u003ccode\u003enode.js\u003c/code\u003e 环境中可以直接 \u003ccode\u003erequire\u003c/code\u003e 后使用. 在 \u003ccode\u003eweb\u003c/code\u003e 环境中我们可以使用第三方 \u003ccode\u003enpm\u003c/code\u003e 包或者原生的 \u003ca href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/EventTarget\"\u003eEventTarget\u003c/a\u003e. 当然, 也可以自己实现一个类似 \u003ccode\u003enode.js\u003c/code\u003e 的简易版本.\u003c/p\u003e\n\u003cp\u003e我们先来看下 \u003ccode\u003eEventEmit\u003c/code\u003e 的基本使用方法:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003econst { EventEmitter } = require('node:events');\n\nconst event = new EventEmitter();\n\nconst fn = () =\u003e {\n  console.log('event 事件触发!');\n};\n\n//为指定事件注册一个监听器\nevent.addListener('event', fn);\n\n//触发监听器\nevent.emit('event');\n\n//移除监听器\nevent.removeListener('event', fn);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e其中, 当我们添加新的监听器时, \u003ccode\u003enewListener\u003c/code\u003e 事件会触发, \u003ccode\u003e当监听器被移除时，removeListener\u003c/code\u003e 事件被触发.\u003c/p\u003e\n\u003ch3 id=\"实现的-api-介绍\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#实现的-api-介绍\"\u003e\u003cspan class=\"icon icon-link\"\u003e\u003c/span\u003e\u003c/a\u003e实现的 Api 介绍\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003eemitter.addListener(eventName, listener)\u003c/code\u003e 为指定事件注册一个监听器，接受一个 \u003ccode\u003estring\u003c/code\u003e (或 \u003ccode\u003esymbol\u003c/code\u003e) 类型的 \u003ccode\u003eeventName\u003c/code\u003e 和一个回调函数. 返回值为 \u003ccode\u003eEventEmit\u003c/code\u003e 的实例, 以便链式调用.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eeventName\u003c/code\u003e \u003ccode\u003e\u0026#x3C;string\u003e\u003c/code\u003e | \u003ccode\u003e\u0026#x3C;symbol\u003e\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003elistener\u003c/code\u003e \u003ccode\u003e\u0026#x3C;Function\u003e\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eReturns\u003c/code\u003e \u003ccode\u003e\u0026#x3C;EventEmit\u003e\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003eemitter.emit(eventName, [...args])\u003c/code\u003e 同步调用为名为 \u003ccode\u003eeventName\u003c/code\u003e 的事件注册的每个监听器, 按照它们注册的顺序, 将提供的参数传递给每个侦听器, 如果存在该监听器, 则返回 \u003ccode\u003eTrue\u003c/code\u003e, 否则返回 \u003ccode\u003eFalse\u003c/code\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eeventName\u003c/code\u003e \u003ccode\u003e\u0026#x3C;string\u003e\u003c/code\u003e | \u003ccode\u003e\u0026#x3C;symbol\u003e\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e...args\u003c/code\u003e \u003ccode\u003e\u0026#x3C;any\u003e\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eReturns\u003c/code\u003e \u003ccode\u003e\u0026#x3C;boolean\u003e\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003eemitter.once(eventName, listener)\u003c/code\u003e 和 \u003ccode\u003eaddListener\u003c/code\u003e 类似, 但只触发一次, 随后便解除事件监听.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003eemitter.removeListener(eventName, listener)\u003c/code\u003e 移除指定事件的某个监听回调.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eeventName\u003c/code\u003e \u003ccode\u003e\u0026#x3C;string\u003e\u003c/code\u003e | \u003ccode\u003e\u0026#x3C;symbol\u003e\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003elistener\u003c/code\u003e \u003ccode\u003e\u0026#x3C;Function\u003e\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eReturns\u003c/code\u003e \u003ccode\u003e\u0026#x3C;EventEmit\u003e\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003eemitter.removeAllListeners([eventName])\u003c/code\u003e 删除所有监听器, 或删除指定 \u003ccode\u003eeventName\u003c/code\u003e 的监听器.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eeventName\u003c/code\u003e \u003ccode\u003e\u0026#x3C;string\u003e\u003c/code\u003e | \u003ccode\u003e\u0026#x3C;symbol\u003e\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eReturns\u003c/code\u003e \u003ccode\u003e\u0026#x3C;EventEmitter\u003e\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003eemitter.setMaxListeners(n)\u003c/code\u003e 用于修改监听器的默认限制的数量. (默认大于 10 个监听回调时会产生警告)\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003en\u003c/code\u003e \u003ccode\u003e\u0026#x3C;integer\u003e\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eReturns\u003c/code\u003e \u003ccode\u003e\u0026#x3C;EventEmitter\u003e\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003eemitter.getMaxListeners()\u003c/code\u003e 获取限制监听器的数量\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003eemitter.listeners(eventName)\u003c/code\u003e 返回名为 \u003ccode\u003eeventName\u003c/code\u003e 的事件的监听器数组的副本.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eeventName\u003c/code\u003e \u003ccode\u003e\u0026#x3C;string\u003e\u003c/code\u003e | \u003ccode\u003e\u0026#x3C;symbol\u003e\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eReturns\u003c/code\u003e \u003ccode\u003e\u0026#x3C;Function\u003e\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003eemitter.listenerCount(eventName)\u003c/code\u003e 返回监听名为 \u003ccode\u003eeventName\u003c/code\u003e 的事件的监听器数量\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003eemitter.on\u003c/code\u003e \u003ccode\u003eemitter.addListener\u003c/code\u003e的别名函数\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003eemitter.off\u003c/code\u003e \u003ccode\u003eemitter.removeListener\u003c/code\u003e的别名函数\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3 id=\"构造函数\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#构造函数\"\u003e\u003cspan class=\"icon icon-link\"\u003e\u003c/span\u003e\u003c/a\u003e构造函数\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003e  #maxListeners = 10;\n  constructor() {\n    this.listeners = Object.create(null);\n    this.#maxListeners = 10;\n  }\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e其中 \u003ccode\u003elisteners\u003c/code\u003e 的结构如下:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-JSON\"\u003e{\n  \"event1\": [f1,f2,f3]，\n  \"event2\": [f4,f5]，\n  ...\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"addlistener-方法\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#addlistener-方法\"\u003e\u003cspan class=\"icon icon-link\"\u003e\u003c/span\u003e\u003c/a\u003eaddListener 方法\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e判断该事件监听器数组是否初始化，若未初始化，则将 \u003ccode\u003elisteners[event]\u003c/code\u003e 初始化为数组，并加入监听器 \u003ccode\u003ecb\u003c/code\u003e, 并触发 \u003ccode\u003enewListener\u003c/code\u003e 事件.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e判断该事件的监听器数量是否已超限，超限则报警告.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e判断数组中是否已存在 \u003ccode\u003ecb\u003c/code\u003e, 不存在则添加，已存在则不做操作.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e指定 \u003ccode\u003eon\u003c/code\u003e 等于 \u003ccode\u003eaddListener\u003c/code\u003e 方法\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003e  addListener(eventName, cb) {\n    if (\n      !this.listeners[eventName || !Array.isArray(this.listeners[eventName])]\n    ) {\n      this.listeners[eventName] = [cb];\n      if (eventName !== \"newListener\") {\n        this.emit(\"newListener\");\n      }\n      return this;\n    }\n    if (this.listeners[eventName].length \u003e= this.#maxListeners) {\n      console.error(\n        \"MaxListenersExceededWarning: Possible EventEmitter memory leak detected. %d event6 listeners added to [EventEmitter]. Use emitter.setMaxListeners() to increase limit\",\n        this.#maxListeners\n      );\n    }\n\n    this.listeners[eventName].push(cb);\n    return this;\n  }\n\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"emit-方法\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#emit-方法\"\u003e\u003cspan class=\"icon icon-link\"\u003e\u003c/span\u003e\u003c/a\u003eemit 方法\u003c/h3\u003e\n\u003cp\u003e遍历监听器,通过 \u003ccode\u003eapply\u003c/code\u003e 方法把上面得到的 \u003ccode\u003eargs\u003c/code\u003e 参数传进去, 需要注意的是不要漏了返回值.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003e  emit(eventName, ...args) {\n    const isExistEvent =\n      this.listeners[eventName] \u0026#x26;\u0026#x26; this.listeners[eventName].length \u003e 0;\n\n    if (isExistEvent) {\n      this.listeners[eventName].forEach((cb) =\u003e {\n        cb.apply(null, args);\n      });\n    }\n    return isExistEvent;\n  }\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"removelistener-方法\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#removelistener-方法\"\u003e\u003cspan class=\"icon icon-link\"\u003e\u003c/span\u003e\u003c/a\u003eremoveListener 方法\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003e  removeListener(eventName, listener) {\n    const index = (this.listeners[eventName] || []).indexOf(listener);\n    if (index !== -1) {\n      this.listeners[eventName].splice(index, 1);\n      if (eventName !== \"removeListener\") {\n        this.emit(\"removeListener\");\n      }\n    }\n    return this;\n  }\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"once-方法\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#once-方法\"\u003e\u003cspan class=\"icon icon-link\"\u003e\u003c/span\u003e\u003c/a\u003eonce 方法\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003eonce\u003c/code\u003e 方法是 \u003ccode\u003eon\u003c/code\u003e 方法和 \u003ccode\u003eremoveListener\u003c/code\u003e 方法的结合：用 \u003ccode\u003eon\u003c/code\u003e 方法监听，在回调结束的最后位置，通过\u003ccode\u003eremoveListener\u003c/code\u003e 删掉监听函数自身\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003e  once(eventName, listener) {\n    const fn = (...args) =\u003e {\n      listener.apply(null, args);\n      this.removeListener(eventName, fn);\n    };\n    this.on(eventName, fn);\n    return this;\n  }\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"removealllisteners-方法\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#removealllisteners-方法\"\u003e\u003cspan class=\"icon icon-link\"\u003e\u003c/span\u003e\u003c/a\u003eremoveAllListeners 方法\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003e  removeAllListeners(eventNames = []) {\n    if (eventNames.length === 0) {\n      this.listeners = Object.create(null);\n    } else {\n      eventNames.forEach((v) =\u003e {\n        this.listeners[v] = null;\n      });\n    }\n    return this;\n  }\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"setmaxlistenersgetmaxlistenerslistenercountonoff-方法\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#setmaxlistenersgetmaxlistenerslistenercountonoff-方法\"\u003e\u003cspan class=\"icon icon-link\"\u003e\u003c/span\u003e\u003c/a\u003esetMaxListeners、getMaxListeners、listenerCount、on、off 方法\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003e  setMaxListeners(maxListeners) {\n    this.#maxListeners = maxListeners;\n  }\n  getMaxListeners() {\n    return this.#maxListeners;\n  }\n  listenerCount(eventName) {\n    return this.listeners[eventName]?.length ?? 0;\n  }\n\n  EventEmitter.prototype.on = EventEmitter.prototype.addListener;\n  EventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch4 id=\"完整代码地址-httpsgithubcomlzs911eventemit\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#完整代码地址-httpsgithubcomlzs911eventemit\"\u003e\u003cspan class=\"icon icon-link\"\u003e\u003c/span\u003e\u003c/a\u003e完整代码地址: \u003ca href=\"https://github.com/LZS911/EventEmit\"\u003ehttps://github.com/LZS911/EventEmit\u003c/a\u003e\u003c/h4\u003e","ogImage":{"url":"/assets/blog/image/cover.jpg"},"coverImage":"/assets/blog/image/cover.jpg","theme":"orange","tag":["node","javascript","EventEmit"]}},"__N_SSG":true},"page":"/posts/[slug]","query":{"slug":"如何实现一个事件监听器EventEmit"},"buildId":"Qfhv06CUT0IfGCtGEzEqq","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>