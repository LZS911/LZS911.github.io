<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><link rel="apple-touch-icon" sizes="180x180" href="/favicon/apple-touch-icon.png"/><link rel="icon" type="image/png" sizes="32x32" href="/favicon/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="16x16" href="/favicon/favicon-16x16.png"/><link rel="manifest" href="/favicon/site.webmanifest"/><link rel="mask-icon" href="/favicon/safari-pinned-tab.svg" color="#000000"/><link rel="shortcut icon" href="/favicon/favicon.ico"/><meta name="msapplication-TileColor" content="#000000"/><meta name="msapplication-config" content="/favicon/browserconfig.xml"/><meta name="theme-color" content="#000"/><link rel="alternate" type="application/rss+xml" href="/feed.xml"/><meta property="og:image" content="https://og-image.vercel.app/Next.js%20Blog%20Starter%20Example.png?theme=light&amp;md=1&amp;fontSize=100px&amp;images=https%3A%2F%2Fassets.vercel.com%2Fimage%2Fupload%2Ffront%2Fassets%2Fdesign%2Fnextjs-black-logo.svg"/><title>TypeScript中的 infer 与 TemplateLiteral | Ai.Haibara codes</title><meta name="next-head-count" content="14"/><link rel="preload" href="/_next/static/css/376bae3e9f18d9d5.css" as="style"/><link rel="stylesheet" href="/_next/static/css/376bae3e9f18d9d5.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-8fa1640cc84ba8fe.js" defer=""></script><script src="/_next/static/chunks/framework-3b5a00d5d7e8d93b.js" defer=""></script><script src="/_next/static/chunks/main-59a90320855f5cf5.js" defer=""></script><script src="/_next/static/chunks/pages/_app-58fce1570f46b1f7.js" defer=""></script><script src="/_next/static/chunks/799-575b46febca3af7d.js" defer=""></script><script src="/_next/static/chunks/399-cac0cd8ed02bf02a.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bslug%5D-455fd7ac934c0bb1.js" defer=""></script><script src="/_next/static/EvvGr9SIhpNxcrXrStbVQ/_buildManifest.js" defer=""></script><script src="/_next/static/EvvGr9SIhpNxcrXrStbVQ/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="min-h-screen"><header class="text-white bg-black drop-shadow-2xl"><div class="mx-auto my-0 max-w-[960px] py-6 px-4 flex items-center"><div class="flex items-center"><img alt="Ai.Haibara" src="/assets/blog/authors/haibara_2.jpg" width="100" height="100" decoding="async" data-nimg="1" class=" rounded-full" loading="lazy" style="color:transparent"/></div><div class="ml-6"><a class=" font-bold text-3xl" href="/">Ai.Haibara codes</a><div class="mt-2"><a class="p-1 rounded-sm text-xl mr-2 hover:border-b-2 border-indigo" href="/">Home</a><a class="p-1 rounded-sm text-xl mr-2 hover:border-b-2 border-indigo" href="/projects">Projects</a><a class="p-1 rounded-sm text-xl mr-2 hover:border-b-2 border-indigo" href="/talks">Talks</a><a class="p-1 rounded-sm text-xl mr-2 hover:border-b-2 border-indigo" href="/blogs">Blogs</a></div></div></div></header><main class="p-6 flex justify-center"><article><div class="flex justify-center font-[Arial]"><h1 class="text-5xl font-bold bg-indigo px-5 py-2 rounded-sm text-shadow-lg leading-[1.1]">TypeScript中的 infer 与 TemplateLiteral</h1></div><time dateTime="2022-11-21" class="text-center block my-4 text-sm opacity-60">November	21, 2022</time><section><div class="markdown-body-fancy max-w-3xl"><h2>infer</h2>
<p>在介绍 <code>infer</code> 之前, 我们需要先了解一个前置知识点: <code>extends</code>, 也就是条件类型.</p>
<p>来自 <code>Typescript</code> 官网的介绍:</p>
<blockquote>
<p>大多数有效程序的核心是，我们必须依据输入做出一些决定。 JavaScript 程序也是如此，但是由于值可以很容易地被内省，这些决定也是基于输入的类型。 条件类型 有助于描述输入和输出类型之间的关系。</p>
</blockquote>
<pre><code class="language-Typescript">interface Animal {
  live(): void;
}
interface Dog extends Animal {
  woof(): void;
}
 
type Example1 = Dog extends Animal ? number : string;
        
// type Example1 = number
 
type Example2 = RegExp extends Animal ? number : string;
        
// type Example2 = string
</code></pre>
<p>可以看到 <code>extends</code> 的用法与 <code>javascript</code> 中的三元表达式没有太多的区别. 接下来, 回到文章的主题 --- <code>infer</code> 关键字.</p>
<p>首先, 我们先来实现一个工具类型: 判断接受的泛型是否为一个函数, 如果是, 则返回函数的返回值类型, 否则返回泛型它自己.</p>
<pre><code class="language-Typescript">type f1 = () => void;
type f2 = (arg: string, arg2: number) => number;
type f3 = (arg: number) => string;
type t4 = { name: string };

type Example1&#x3C;T> = T extends ((...arg: any) => infer ResultType) ? ResultType : T;

type r1 = Example1&#x3C;f1> // type r1 = void;
type r2 = Example1&#x3C;f2> // type r2 = number
type r3 = Example1&#x3C;f3> // type r3 = string;
type r4 = Example1&#x3C;t4> // type t4 = { name: string }
</code></pre>
<p>在这里, 我们通过 <code>infer</code> 关键字引入了类型一个名为 <code>ResultType</code> 的新泛型类型变量, 或者可以理解为一个占位符, 当条件类型成立时, <code>ResultType</code> 会替换为满足条件类型时所需的类型, 在这个栗子中 <code>ResultType</code> 代表的是函数的返回类型, 也就完成了我们需要的工具类型.</p>
<h2>Template Literal</h2>
<p>我们先看下基础的字符串文字类型:</p>
<pre><code class="language-Typescript">type Demo = 'demo';
</code></pre>
<p>模版文字类型是建立在字符串文字类型上的, 举个栗子</p>
<pre><code class="language-Typescript">type Hello = 'hello';
type HelloWorld = `${Hello} world`; //type HelloWorld = "hello world"
</code></pre>
<p>单从语法上来说, 也是和 <code>javascript</code> 中的模版字符串大同小异.</p>
<p>配合联合类型时, 会生成出每个联合成员可以表示的每个可能的字符串文字的集合.</p>
<pre><code class="language-Typescript">type EmailLocaleIDs = "welcome_email" | "email_heading";
type FooterLocaleIDs = "footer_title" | "footer_sendoff";
 
type AllLocaleIDs = `${EmailLocaleIDs | FooterLocaleIDs}_id`; 
//type AllLocaleIDs = "welcome_email_id" | "email_heading_id" | "footer_title_id" | "footer_sendoff_id"
</code></pre>
<p>就概念来说, <code>infer</code> 与 <code>Template Literal</code> 并不是很复杂, 最重要的还是在了解基本概念后能灵活的将其应用到实践中.</p>
<p>对实践感兴趣的可以转到: <a href="https://lzs911-blog-next.vercel.app/posts/Typescript%20%E4%BD%93%E6%93%8D%E7%BB%83%E4%B9%A0">https://lzs911-blog-next.vercel.app/posts/Typescript%20%E4%BD%93%E6%93%8D%E7%BB%83%E4%B9%A0</a></p></div></section></article></main><footer class="bg-neutral-50 border-t border-neutral-200 text-center text-xs opacity-50 py-4">© 2022,<!-- --> <a rel="noopener noreferrer" class="hover:underline hover:bg-indigo" href="https://github.com/LZS911" target="_blank">LZS_911</a>, built with<!-- --> <a rel="noopener noreferrer" class="underline hover:bg-indigo" href="https://nextjs.org/" target="_blank">Next.js</a> <!-- -->and<!-- --> <a rel="noopener noreferrer" class="underline hover:bg-indigo" href="https://pages.github.com/?(null)" target="_blank">GitHub Pages</a></footer></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"TypeScript中的 infer 与 TemplateLiteral","date":"2022-11-21","slug":"TypeScript中的Infer与TemplateLiteral","author":"LZS_911","content":"\u003ch2\u003einfer\u003c/h2\u003e\n\u003cp\u003e在介绍 \u003ccode\u003einfer\u003c/code\u003e 之前, 我们需要先了解一个前置知识点: \u003ccode\u003eextends\u003c/code\u003e, 也就是条件类型.\u003c/p\u003e\n\u003cp\u003e来自 \u003ccode\u003eTypescript\u003c/code\u003e 官网的介绍:\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e大多数有效程序的核心是，我们必须依据输入做出一些决定。 JavaScript 程序也是如此，但是由于值可以很容易地被内省，这些决定也是基于输入的类型。 条件类型 有助于描述输入和输出类型之间的关系。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cpre\u003e\u003ccode class=\"language-Typescript\"\u003einterface Animal {\n  live(): void;\n}\ninterface Dog extends Animal {\n  woof(): void;\n}\n \ntype Example1 = Dog extends Animal ? number : string;\n        \n// type Example1 = number\n \ntype Example2 = RegExp extends Animal ? number : string;\n        \n// type Example2 = string\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e可以看到 \u003ccode\u003eextends\u003c/code\u003e 的用法与 \u003ccode\u003ejavascript\u003c/code\u003e 中的三元表达式没有太多的区别. 接下来, 回到文章的主题 --- \u003ccode\u003einfer\u003c/code\u003e 关键字.\u003c/p\u003e\n\u003cp\u003e首先, 我们先来实现一个工具类型: 判断接受的泛型是否为一个函数, 如果是, 则返回函数的返回值类型, 否则返回泛型它自己.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-Typescript\"\u003etype f1 = () =\u003e void;\ntype f2 = (arg: string, arg2: number) =\u003e number;\ntype f3 = (arg: number) =\u003e string;\ntype t4 = { name: string };\n\ntype Example1\u0026#x3C;T\u003e = T extends ((...arg: any) =\u003e infer ResultType) ? ResultType : T;\n\ntype r1 = Example1\u0026#x3C;f1\u003e // type r1 = void;\ntype r2 = Example1\u0026#x3C;f2\u003e // type r2 = number\ntype r3 = Example1\u0026#x3C;f3\u003e // type r3 = string;\ntype r4 = Example1\u0026#x3C;t4\u003e // type t4 = { name: string }\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e在这里, 我们通过 \u003ccode\u003einfer\u003c/code\u003e 关键字引入了类型一个名为 \u003ccode\u003eResultType\u003c/code\u003e 的新泛型类型变量, 或者可以理解为一个占位符, 当条件类型成立时, \u003ccode\u003eResultType\u003c/code\u003e 会替换为满足条件类型时所需的类型, 在这个栗子中 \u003ccode\u003eResultType\u003c/code\u003e 代表的是函数的返回类型, 也就完成了我们需要的工具类型.\u003c/p\u003e\n\u003ch2\u003eTemplate Literal\u003c/h2\u003e\n\u003cp\u003e我们先看下基础的字符串文字类型:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-Typescript\"\u003etype Demo = 'demo';\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e模版文字类型是建立在字符串文字类型上的, 举个栗子\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-Typescript\"\u003etype Hello = 'hello';\ntype HelloWorld = `${Hello} world`; //type HelloWorld = \"hello world\"\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e单从语法上来说, 也是和 \u003ccode\u003ejavascript\u003c/code\u003e 中的模版字符串大同小异.\u003c/p\u003e\n\u003cp\u003e配合联合类型时, 会生成出每个联合成员可以表示的每个可能的字符串文字的集合.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-Typescript\"\u003etype EmailLocaleIDs = \"welcome_email\" | \"email_heading\";\ntype FooterLocaleIDs = \"footer_title\" | \"footer_sendoff\";\n \ntype AllLocaleIDs = `${EmailLocaleIDs | FooterLocaleIDs}_id`; \n//type AllLocaleIDs = \"welcome_email_id\" | \"email_heading_id\" | \"footer_title_id\" | \"footer_sendoff_id\"\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e就概念来说, \u003ccode\u003einfer\u003c/code\u003e 与 \u003ccode\u003eTemplate Literal\u003c/code\u003e 并不是很复杂, 最重要的还是在了解基本概念后能灵活的将其应用到实践中.\u003c/p\u003e\n\u003cp\u003e对实践感兴趣的可以转到: \u003ca href=\"https://lzs911-blog-next.vercel.app/posts/Typescript%20%E4%BD%93%E6%93%8D%E7%BB%83%E4%B9%A0\"\u003ehttps://lzs911-blog-next.vercel.app/posts/Typescript%20%E4%BD%93%E6%93%8D%E7%BB%83%E4%B9%A0\u003c/a\u003e\u003c/p\u003e","ogImage":{"url":"/assets/blog/image/cover.jpg"},"coverImage":"/assets/blog/image/cover.jpg","theme":"fancy","tag":[null]}},"__N_SSG":true},"page":"/posts/[slug]","query":{"slug":"TypeScript中的Infer与TemplateLiteral"},"buildId":"EvvGr9SIhpNxcrXrStbVQ","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>