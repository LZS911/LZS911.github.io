<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><link rel="apple-touch-icon" sizes="180x180" href="/favicon/apple-touch-icon.png"/><link rel="icon" type="image/png" sizes="32x32" href="/favicon/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="16x16" href="/favicon/favicon-16x16.png"/><link rel="manifest" href="/favicon/site.webmanifest"/><link rel="mask-icon" href="/favicon/safari-pinned-tab.svg" color="#000000"/><link rel="shortcut icon" href="/favicon/favicon.ico"/><meta name="msapplication-TileColor" content="#000000"/><meta name="msapplication-config" content="/favicon/browserconfig.xml"/><meta name="theme-color" content="#000"/><link rel="alternate" type="application/rss+xml" href="/feed.xml"/><meta property="og:image" content="https://og-image.vercel.app/Next.js%20Blog%20Starter%20Example.png?theme=light&amp;md=1&amp;fontSize=100px&amp;images=https%3A%2F%2Fassets.vercel.com%2Fimage%2Fupload%2Ffront%2Fassets%2Fdesign%2Fnextjs-black-logo.svg"/><title>TypeScript中的 infer 与 TemplateLiteral | Ai.Haibara codes</title><meta name="next-head-count" content="14"/><link rel="preload" href="/_next/static/css/cbc0135ff184ccab.css" as="style"/><link rel="stylesheet" href="/_next/static/css/cbc0135ff184ccab.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-8fa1640cc84ba8fe.js" defer=""></script><script src="/_next/static/chunks/framework-3b5a00d5d7e8d93b.js" defer=""></script><script src="/_next/static/chunks/main-59a90320855f5cf5.js" defer=""></script><script src="/_next/static/chunks/pages/_app-f46e289d7ac5e197.js" defer=""></script><script src="/_next/static/chunks/799-575b46febca3af7d.js" defer=""></script><script src="/_next/static/chunks/399-cac0cd8ed02bf02a.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bslug%5D-ca05212d4081d62f.js" defer=""></script><script src="/_next/static/zBK-7x4DColqBPVN7Z7Pf/_buildManifest.js" defer=""></script><script src="/_next/static/zBK-7x4DColqBPVN7Z7Pf/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="min-h-screen"><header class="text-white bg-black drop-shadow-2xl"><div class="mx-auto my-0 max-w-[960px] py-6 px-4 flex items-center"><div class="flex items-center"><img alt="Ai.Haibara" src="/assets/blog/authors/haibara_2.jpg" width="100" height="100" decoding="async" data-nimg="1" class=" rounded-full" loading="lazy" style="color:transparent"/></div><div class="ml-6"><a class=" font-bold text-3xl" href="/">Ai.Haibara codes</a><div class="mt-2"><a class="p-1 rounded-sm text-xl mr-2 hover:border-b-2 border-indigo" href="/">Home</a><a class="p-1 rounded-sm text-xl mr-2 hover:border-b-2 border-indigo" href="/projects">Projects</a><a class="p-1 rounded-sm text-xl mr-2 hover:border-b-2 border-indigo" href="/talks">Talks</a><a class="p-1 rounded-sm text-xl mr-2 hover:border-b-2 border-indigo" href="/blogs">Blogs</a></div></div></div></header><main class="p-6 flex justify-center"><article><div class="flex justify-center font-[Arial]"><h1 class="text-5xl font-bold bg-indigo px-5 py-2 rounded-sm text-shadow-lg leading-[1.1]">TypeScript中的 infer 与 TemplateLiteral</h1></div><time dateTime="2022-11-21" class="text-center block my-4 text-sm opacity-60">November	21, 2022</time><section><div class="markdown-body-fancy max-w-3xl"><h2 id="infer"><a aria-hidden="true" tabindex="-1" href="#infer"><span class="icon icon-link"></span></a>infer</h2>
<p>在介绍 infer 之前, 我们需要先了解一个前置知识点: extends, 也就是条件类型.</p>
<p>来自 Typescript 官网的介绍:</p>
<blockquote>
<p>大多数有效程序的核心是，我们必须依据输入做出一些决定。 JavaScript 程序也是如此，但是由于值可以很容易地被内省，这些决定也是基于输入的类型。 条件类型 有助于描述输入和输出类型之间的关系。</p>
</blockquote>
<pre><code class="language-Typescript">interface Animal {
  live(): void;
}
interface Dog extends Animal {
  woof(): void;
}
 
type Example1 = Dog extends Animal ? number : string;
        
// type Example1 = number
 
type Example2 = RegExp extends Animal ? number : string;
        
// type Example2 = string
</code></pre>
<p>可以看到 extends 的用法与 javascript 中的三元表达式没有太多的区别. 接下来, 回到文章的主题 --- infer 关键字.</p>
<p>首先, 我们先来实现一个工具类型: <em>判断接受的泛型是否为一个函数, 如果是, 则返回函数的返回值类型, 否则返回它自己</em></p>
<pre><code class="language-Typescript">type f1 = () => void;
type f2 = (arg: string, arg2: number) => number;
type f3 = (arg: number) => string;
type t4 = { name: string };

type Example1&#x3C;T> = T extends ((...arg: infer params) => infer ResultType) ? ResultType : T;
</code></pre>
<p><img src="/assets/infer_templateLiteral/example-1.png" alt="alt">
<img src="/assets/infer_templateLiteral/example-2.png" alt="alt">
<img src="/assets/infer_templateLiteral/example-3.png" alt="alt">
<img src="/assets/infer_templateLiteral/example-4.png" alt="alt"></p>
<p>在这里, 我们通过 infer 关键字引入了类型一个名为 ResultType 的新泛型类型变量, 或者可以理解为一个占位符, 当条件类型成立时, ResultType 会替换为满足条件类型时所需的类型, 在这个栗子中 ResultType 代表的是函数的返回类型, 也就完成了我们需要的工具类型.</p>
<p>同样, 我们也可以实现一个 <em>提取元组类型中最后一个元素的类型</em></p>
<pre><code class="language-Typescript">type lastArrType&#x3C;T extends unknown[]> = T extends [
  ...infer rest,
  infer ResultType
]
  ? ResultType
  : never;
</code></pre>
<p><img src="/assets/infer_templateLiteral/example-5.png" alt="alt"></p>
<h2 id="template-literal"><a aria-hidden="true" tabindex="-1" href="#template-literal"><span class="icon icon-link"></span></a>Template Literal</h2>
<p>我们先看下基础的字符串文字类型:</p>
<pre><code class="language-Typescript">type Demo = 'demo';
</code></pre>
<p>模版文字类型是建立在字符串文字类型上的, 举个栗子</p>
<pre><code class="language-Typescript">type Hello = 'hello';
type HelloWorld = `${Hello} world`; //type HelloWorld = "hello world"
</code></pre>
<p>单从语法上来说, 也是和 javascript 中的模版字符串大同小异.</p>
<p>配合联合类型时, 会生成出每个联合成员可以表示的每个可能的字符串文字的集合.</p>
<pre><code class="language-Typescript">type EmailLocaleIDs = "welcome_email" | "email_heading";
type FooterLocaleIDs = "footer_title" | "footer_sendoff";
</code></pre>
<p><img src="/assets/infer_templateLiteral/example-6.png" alt="alt"></p>
<h2 id="实践"><a aria-hidden="true" tabindex="-1" href="#实践"><span class="icon icon-link"></span></a>实践</h2>
<p>结合 infer 以及 Template Literal 实现一个类似 <code>String.replace</code> 的工具类型</p>
<pre><code class="language-Typescript">type ReplaceStr&#x3C;
  Str extends string,
  From extends string,
  To extends string
> = Str extends `${infer Prefix}${From}${infer Suffix}`
  ? `${Prefix}${To}${Suffix}`
  : Str;
</code></pre>
<p><img src="/assets/infer_templateLiteral/example-7.png" alt="alt"></p>
<p>对更多实践感兴趣的可以转到: <a href="https://lzs911.github.io/posts/Typescript%20%E4%BD%93%E6%93%8D%E7%BB%83%E4%B9%A0">https://lzs911.github.io/posts/Typescript%20%E4%BD%93%E6%93%8D%E7%BB%83%E4%B9%A0</a></p></div></section></article></main><footer class="bg-neutral-50 border-t border-neutral-200 text-center text-xs opacity-50 py-4">© 2022,<!-- --> <a rel="noopener noreferrer" class="hover:underline hover:bg-indigo" href="https://github.com/LZS911" target="_blank">LZS_911</a>, build with<!-- --> <a rel="noopener noreferrer" class="underline hover:bg-indigo" href="https://nextjs.org/" target="_blank">Next.js</a> <!-- -->and<!-- --> <a rel="noopener noreferrer" class="underline hover:bg-indigo" href="https://pages.github.com/?(null)" target="_blank">GitHub Pages</a></footer></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"TypeScript中的 infer 与 TemplateLiteral","date":"2022-11-21","slug":"TypeScript中的Infer与TemplateLiteral","author":"LZS_911","content":"\u003ch2 id=\"infer\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#infer\"\u003e\u003cspan class=\"icon icon-link\"\u003e\u003c/span\u003e\u003c/a\u003einfer\u003c/h2\u003e\n\u003cp\u003e在介绍 infer 之前, 我们需要先了解一个前置知识点: extends, 也就是条件类型.\u003c/p\u003e\n\u003cp\u003e来自 Typescript 官网的介绍:\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e大多数有效程序的核心是，我们必须依据输入做出一些决定。 JavaScript 程序也是如此，但是由于值可以很容易地被内省，这些决定也是基于输入的类型。 条件类型 有助于描述输入和输出类型之间的关系。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cpre\u003e\u003ccode class=\"language-Typescript\"\u003einterface Animal {\n  live(): void;\n}\ninterface Dog extends Animal {\n  woof(): void;\n}\n \ntype Example1 = Dog extends Animal ? number : string;\n        \n// type Example1 = number\n \ntype Example2 = RegExp extends Animal ? number : string;\n        \n// type Example2 = string\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e可以看到 extends 的用法与 javascript 中的三元表达式没有太多的区别. 接下来, 回到文章的主题 --- infer 关键字.\u003c/p\u003e\n\u003cp\u003e首先, 我们先来实现一个工具类型: \u003cem\u003e判断接受的泛型是否为一个函数, 如果是, 则返回函数的返回值类型, 否则返回它自己\u003c/em\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-Typescript\"\u003etype f1 = () =\u003e void;\ntype f2 = (arg: string, arg2: number) =\u003e number;\ntype f3 = (arg: number) =\u003e string;\ntype t4 = { name: string };\n\ntype Example1\u0026#x3C;T\u003e = T extends ((...arg: infer params) =\u003e infer ResultType) ? ResultType : T;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cimg src=\"/assets/infer_templateLiteral/example-1.png\" alt=\"alt\"\u003e\n\u003cimg src=\"/assets/infer_templateLiteral/example-2.png\" alt=\"alt\"\u003e\n\u003cimg src=\"/assets/infer_templateLiteral/example-3.png\" alt=\"alt\"\u003e\n\u003cimg src=\"/assets/infer_templateLiteral/example-4.png\" alt=\"alt\"\u003e\u003c/p\u003e\n\u003cp\u003e在这里, 我们通过 infer 关键字引入了类型一个名为 ResultType 的新泛型类型变量, 或者可以理解为一个占位符, 当条件类型成立时, ResultType 会替换为满足条件类型时所需的类型, 在这个栗子中 ResultType 代表的是函数的返回类型, 也就完成了我们需要的工具类型.\u003c/p\u003e\n\u003cp\u003e同样, 我们也可以实现一个 \u003cem\u003e提取元组类型中最后一个元素的类型\u003c/em\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-Typescript\"\u003etype lastArrType\u0026#x3C;T extends unknown[]\u003e = T extends [\n  ...infer rest,\n  infer ResultType\n]\n  ? ResultType\n  : never;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cimg src=\"/assets/infer_templateLiteral/example-5.png\" alt=\"alt\"\u003e\u003c/p\u003e\n\u003ch2 id=\"template-literal\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#template-literal\"\u003e\u003cspan class=\"icon icon-link\"\u003e\u003c/span\u003e\u003c/a\u003eTemplate Literal\u003c/h2\u003e\n\u003cp\u003e我们先看下基础的字符串文字类型:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-Typescript\"\u003etype Demo = 'demo';\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e模版文字类型是建立在字符串文字类型上的, 举个栗子\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-Typescript\"\u003etype Hello = 'hello';\ntype HelloWorld = `${Hello} world`; //type HelloWorld = \"hello world\"\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e单从语法上来说, 也是和 javascript 中的模版字符串大同小异.\u003c/p\u003e\n\u003cp\u003e配合联合类型时, 会生成出每个联合成员可以表示的每个可能的字符串文字的集合.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-Typescript\"\u003etype EmailLocaleIDs = \"welcome_email\" | \"email_heading\";\ntype FooterLocaleIDs = \"footer_title\" | \"footer_sendoff\";\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cimg src=\"/assets/infer_templateLiteral/example-6.png\" alt=\"alt\"\u003e\u003c/p\u003e\n\u003ch2 id=\"实践\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#实践\"\u003e\u003cspan class=\"icon icon-link\"\u003e\u003c/span\u003e\u003c/a\u003e实践\u003c/h2\u003e\n\u003cp\u003e结合 infer 以及 Template Literal 实现一个类似 \u003ccode\u003eString.replace\u003c/code\u003e 的工具类型\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-Typescript\"\u003etype ReplaceStr\u0026#x3C;\n  Str extends string,\n  From extends string,\n  To extends string\n\u003e = Str extends `${infer Prefix}${From}${infer Suffix}`\n  ? `${Prefix}${To}${Suffix}`\n  : Str;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cimg src=\"/assets/infer_templateLiteral/example-7.png\" alt=\"alt\"\u003e\u003c/p\u003e\n\u003cp\u003e对更多实践感兴趣的可以转到: \u003ca href=\"https://lzs911.github.io/posts/Typescript%20%E4%BD%93%E6%93%8D%E7%BB%83%E4%B9%A0\"\u003ehttps://lzs911.github.io/posts/Typescript%20%E4%BD%93%E6%93%8D%E7%BB%83%E4%B9%A0\u003c/a\u003e\u003c/p\u003e","ogImage":{"url":"/assets/blog/image/cover.jpg"},"coverImage":"/assets/blog/image/cover.jpg","theme":"fancy","tag":[null]}},"__N_SSG":true},"page":"/posts/[slug]","query":{"slug":"TypeScript中的Infer与TemplateLiteral"},"buildId":"zBK-7x4DColqBPVN7Z7Pf","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>