<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><link rel="apple-touch-icon" sizes="180x180" href="/favicon/apple-touch-icon.png"/><link rel="icon" type="image/png" sizes="32x32" href="/favicon/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="16x16" href="/favicon/favicon-16x16.png"/><link rel="manifest" href="/favicon/site.webmanifest"/><link rel="mask-icon" href="/favicon/safari-pinned-tab.svg" color="#000000"/><link rel="shortcut icon" href="/favicon/favicon.ico"/><meta name="msapplication-TileColor" content="#000000"/><meta name="msapplication-config" content="/favicon/browserconfig.xml"/><meta name="theme-color" content="#000"/><link rel="alternate" type="application/rss+xml" href="/feed.xml"/><meta property="og:image" content="https://og-image.vercel.app/Next.js%20Blog%20Starter%20Example.png?theme=light&amp;md=1&amp;fontSize=100px&amp;images=https%3A%2F%2Fassets.vercel.com%2Fimage%2Fupload%2Ffront%2Fassets%2Fdesign%2Fnextjs-black-logo.svg"/><title>TypeScript中的 infer 与 TemplateLiteral | Ai.Haibara codes</title><meta name="next-head-count" content="14"/><link rel="preload" href="/_next/static/css/a5eda337cc81d9ab.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a5eda337cc81d9ab.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee7e63bc15b31913.js" defer=""></script><script src="/_next/static/chunks/framework-3b5a00d5d7e8d93b.js" defer=""></script><script src="/_next/static/chunks/main-59a90320855f5cf5.js" defer=""></script><script src="/_next/static/chunks/pages/_app-91d7f786791773ad.js" defer=""></script><script src="/_next/static/chunks/799-575b46febca3af7d.js" defer=""></script><script src="/_next/static/chunks/642-f55f53346f993b53.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bslug%5D-8e1a2fba1f5daa00.js" defer=""></script><script src="/_next/static/YweoWqZUfFtvB-M1jJ2CU/_buildManifest.js" defer=""></script><script src="/_next/static/YweoWqZUfFtvB-M1jJ2CU/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="min-h-screen"><header class="text-white bg-black drop-shadow-2xl"><div class="mx-auto my-0 max-w-[960px] py-6 px-4 flex items-center"><div class="flex items-center"><img alt="Ai.Haibara" src="/assets/blog/authors/haibara_2.jpg" width="100" height="100" decoding="async" data-nimg="1" class=" rounded-full" loading="lazy" style="color:transparent"/></div><div class="ml-6"><a class=" font-bold text-3xl" href="/">Ai.Haibara codes</a><div class="mt-2"><a class="p-1 rounded-sm text-xl mr-2 hover:border-b-2 border-indigo" href="/">Home</a><a class="p-1 rounded-sm text-xl mr-2 hover:border-b-2 border-indigo" href="/projects">Projects</a><a class="p-1 rounded-sm text-xl mr-2 hover:border-b-2 border-indigo" href="/talks">Talks</a><a class="p-1 rounded-sm text-xl mr-2 hover:border-b-2 border-indigo" href="/blogs">Blogs</a></div></div></div></header><main class="p-6 flex justify-center"><article><div class="flex justify-center font-[Arial] max-w-[864px] text-center"><h1 class="text-5xl font-bold bg-indigo px-5 py-2 rounded-sm text-shadow-lg leading-[1.1]">TypeScript中的 infer 与 TemplateLiteral</h1></div><time dateTime="2022-11-21" class="text-center block my-4 text-sm opacity-60">November	21, 2022</time><section><div class="markdown-body-fancy max-w-3xl"><h2 id="infer"><a aria-hidden="true" tabindex="-1" href="#infer"><span class="icon icon-link"></span></a>infer</h2>
<p>在介绍 infer 之前, 我们需要先了解一个前置知识点: extends, 也就是条件类型.</p>
<p>来自 Typescript 官网的介绍:</p>
<blockquote>
<p>大多数有效程序的核心是，我们必须依据输入做出一些决定。 JavaScript 程序也是如此，但是由于值可以很容易地被内省，这些决定也是基于输入的类型。 条件类型 有助于描述输入和输出类型之间的关系。</p>
</blockquote>
<pre><code class="hljs language-Typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Animal</span> {
  <span class="hljs-title function_">live</span>(): <span class="hljs-built_in">void</span>;
}
<span class="hljs-keyword">interface</span> <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span> {
  <span class="hljs-title function_">woof</span>(): <span class="hljs-built_in">void</span>;
}
 
<span class="hljs-keyword">type</span> <span class="hljs-title class_">Example1</span> = <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span> ? <span class="hljs-built_in">number</span> : <span class="hljs-built_in">string</span>;
        
<span class="hljs-comment">// type Example1 = number</span>
 
<span class="hljs-keyword">type</span> <span class="hljs-title class_">Example2</span> = <span class="hljs-title class_">RegExp</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span> ? <span class="hljs-built_in">number</span> : <span class="hljs-built_in">string</span>;
        
<span class="hljs-comment">// type Example2 = string</span>
</code></pre>
<p>可以看到 extends 的用法与 javascript 中的三元表达式没有太多的区别. 接下来, 回到文章的主题 --- infer 关键字.</p>
<p>首先, 我们先来实现一个工具类型: <em>判断接受的泛型是否为一个函数, 如果是, 则返回函数的返回值类型, 否则返回它自己</em></p>
<pre><code class="hljs language-Typescript"><span class="hljs-keyword">type</span> f1 = <span class="hljs-function">() =></span> <span class="hljs-built_in">void</span>;
<span class="hljs-keyword">type</span> f2 = <span class="hljs-function">(<span class="hljs-params"><span class="hljs-attr">arg</span>: <span class="hljs-built_in">string</span>, <span class="hljs-attr">arg2</span>: <span class="hljs-built_in">number</span></span>) =></span> <span class="hljs-built_in">number</span>;
<span class="hljs-keyword">type</span> f3 = <span class="hljs-function">(<span class="hljs-params"><span class="hljs-attr">arg</span>: <span class="hljs-built_in">number</span></span>) =></span> <span class="hljs-built_in">string</span>;
<span class="hljs-keyword">type</span> t4 = { <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span> };

<span class="hljs-keyword">type</span> <span class="hljs-title class_">Example1</span>&#x3C;T> = T <span class="hljs-title function_">extends</span> (<span class="hljs-function">(<span class="hljs-params">...<span class="hljs-attr">arg</span>: infer params</span>) =></span> infer <span class="hljs-title class_">ResultType</span>) ? <span class="hljs-title class_">ResultType</span> : T;
</code></pre>
<p><img src="/assets/infer_templateLiteral/example-1.png" alt="alt">
<img src="/assets/infer_templateLiteral/example-2.png" alt="alt">
<img src="/assets/infer_templateLiteral/example-3.png" alt="alt">
<img src="/assets/infer_templateLiteral/example-4.png" alt="alt"></p>
<p>在这里, 我们通过 infer 关键字引入了类型一个名为 ResultType 的新泛型类型变量, 或者可以理解为一个占位符, 当条件类型成立时, ResultType 会替换为满足条件类型时所需的类型, 在这个栗子中 ResultType 代表的是函数的返回类型, 也就完成了我们需要的工具类型.</p>
<p>同样, 我们也可以实现一个 <em>提取元组类型中最后一个元素的类型</em></p>
<pre><code class="hljs language-Typescript"><span class="hljs-keyword">type</span> lastArrType&#x3C;T <span class="hljs-keyword">extends</span> <span class="hljs-built_in">unknown</span>[]> = T <span class="hljs-keyword">extends</span> [
  ...infer rest,
  infer <span class="hljs-title class_">ResultType</span>
]
  ? <span class="hljs-title class_">ResultType</span>
  : <span class="hljs-built_in">never</span>;
</code></pre>
<p><img src="/assets/infer_templateLiteral/example-5.png" alt="alt"></p>
<h2 id="template-literal"><a aria-hidden="true" tabindex="-1" href="#template-literal"><span class="icon icon-link"></span></a>Template Literal</h2>
<p>我们先看下基础的字符串文字类型:</p>
<pre><code class="hljs language-Typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">Demo</span> = <span class="hljs-string">'demo'</span>;
</code></pre>
<p>模版文字类型是建立在字符串文字类型上的, 举个栗子</p>
<pre><code class="hljs language-Typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">Hello</span> = <span class="hljs-string">'hello'</span>;
<span class="hljs-keyword">type</span> <span class="hljs-title class_">HelloWorld</span> = <span class="hljs-string">`<span class="hljs-subst">${Hello}</span> world`</span>; <span class="hljs-comment">//type HelloWorld = "hello world"</span>
</code></pre>
<p>单从语法上来说, 也是和 javascript 中的模版字符串大同小异.</p>
<p>配合联合类型时, 会生成出每个联合成员可以表示的每个可能的字符串文字的集合.</p>
<pre><code class="hljs language-Typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">EmailLocaleIDs</span> = <span class="hljs-string">"welcome_email"</span> | <span class="hljs-string">"email_heading"</span>;
<span class="hljs-keyword">type</span> <span class="hljs-title class_">FooterLocaleIDs</span> = <span class="hljs-string">"footer_title"</span> | <span class="hljs-string">"footer_sendoff"</span>;
</code></pre>
<p><img src="/assets/infer_templateLiteral/example-6.png" alt="alt"></p>
<h2 id="实践"><a aria-hidden="true" tabindex="-1" href="#实践"><span class="icon icon-link"></span></a>实践</h2>
<p>结合 infer 以及 Template Literal 实现一个类似 <code>String.replace</code> 的工具类型</p>
<pre><code class="hljs language-Typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">ReplaceStr</span>&#x3C;
  <span class="hljs-title class_">Str</span> <span class="hljs-keyword">extends</span> <span class="hljs-built_in">string</span>,
  <span class="hljs-title class_">From</span> <span class="hljs-keyword">extends</span> <span class="hljs-built_in">string</span>,
  <span class="hljs-title class_">To</span> <span class="hljs-keyword">extends</span> <span class="hljs-built_in">string</span>
> = <span class="hljs-title class_">Str</span> <span class="hljs-keyword">extends</span> <span class="hljs-string">`<span class="hljs-subst">${infer Prefix}</span><span class="hljs-subst">${From}</span><span class="hljs-subst">${infer Suffix}</span>`</span>
  ? <span class="hljs-string">`<span class="hljs-subst">${Prefix}</span><span class="hljs-subst">${To}</span><span class="hljs-subst">${Suffix}</span>`</span>
  : <span class="hljs-title class_">Str</span>;
</code></pre>
<p><img src="/assets/infer_templateLiteral/example-7.png" alt="alt"></p>
<p>对更多实践感兴趣的可以转到: <a href="https://lzs911.github.io/posts/Typescript%20%E4%BD%93%E6%93%8D%E7%BB%83%E4%B9%A0">https://lzs911.github.io/posts/Typescript%20%E4%BD%93%E6%93%8D%E7%BB%83%E4%B9%A0</a></p></div></section><div class="mt-10 max-w-3xl"><h3 class="text-2xl font-bold mb-4">评论</h3><p>加载评论中...</p></div></article></main><footer class="bg-neutral-50 border-t border-neutral-200 text-center text-xs opacity-50 py-4">© 2022,<!-- --> <a rel="noopener noreferrer" class="hover:underline hover:bg-indigo" href="https://github.com/LZS911" target="_blank">LZS_911</a>, build with<!-- --> <a rel="noopener noreferrer" class="underline hover:bg-indigo" href="https://nextjs.org/" target="_blank">Next.js</a> <!-- -->and<!-- --> <a rel="noopener noreferrer" class="underline hover:bg-indigo" href="https://pages.github.com/?(null)" target="_blank">GitHub Pages</a></footer></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"TypeScript中的 infer 与 TemplateLiteral","date":"2022-11-21","slug":"TypeScript中的Infer与TemplateLiteral","author":"LZS_911","content":"\u003ch2 id=\"infer\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#infer\"\u003e\u003cspan class=\"icon icon-link\"\u003e\u003c/span\u003e\u003c/a\u003einfer\u003c/h2\u003e\n\u003cp\u003e在介绍 infer 之前, 我们需要先了解一个前置知识点: extends, 也就是条件类型.\u003c/p\u003e\n\u003cp\u003e来自 Typescript 官网的介绍:\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e大多数有效程序的核心是，我们必须依据输入做出一些决定。 JavaScript 程序也是如此，但是由于值可以很容易地被内省，这些决定也是基于输入的类型。 条件类型 有助于描述输入和输出类型之间的关系。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-Typescript\"\u003e\u003cspan class=\"hljs-keyword\"\u003einterface\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eAnimal\u003c/span\u003e {\n  \u003cspan class=\"hljs-title function_\"\u003elive\u003c/span\u003e(): \u003cspan class=\"hljs-built_in\"\u003evoid\u003c/span\u003e;\n}\n\u003cspan class=\"hljs-keyword\"\u003einterface\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eDog\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eextends\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eAnimal\u003c/span\u003e {\n  \u003cspan class=\"hljs-title function_\"\u003ewoof\u003c/span\u003e(): \u003cspan class=\"hljs-built_in\"\u003evoid\u003c/span\u003e;\n}\n \n\u003cspan class=\"hljs-keyword\"\u003etype\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eExample1\u003c/span\u003e = \u003cspan class=\"hljs-title class_\"\u003eDog\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eextends\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eAnimal\u003c/span\u003e ? \u003cspan class=\"hljs-built_in\"\u003enumber\u003c/span\u003e : \u003cspan class=\"hljs-built_in\"\u003estring\u003c/span\u003e;\n        \n\u003cspan class=\"hljs-comment\"\u003e// type Example1 = number\u003c/span\u003e\n \n\u003cspan class=\"hljs-keyword\"\u003etype\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eExample2\u003c/span\u003e = \u003cspan class=\"hljs-title class_\"\u003eRegExp\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eextends\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eAnimal\u003c/span\u003e ? \u003cspan class=\"hljs-built_in\"\u003enumber\u003c/span\u003e : \u003cspan class=\"hljs-built_in\"\u003estring\u003c/span\u003e;\n        \n\u003cspan class=\"hljs-comment\"\u003e// type Example2 = string\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e可以看到 extends 的用法与 javascript 中的三元表达式没有太多的区别. 接下来, 回到文章的主题 --- infer 关键字.\u003c/p\u003e\n\u003cp\u003e首先, 我们先来实现一个工具类型: \u003cem\u003e判断接受的泛型是否为一个函数, 如果是, 则返回函数的返回值类型, 否则返回它自己\u003c/em\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-Typescript\"\u003e\u003cspan class=\"hljs-keyword\"\u003etype\u003c/span\u003e f1 = \u003cspan class=\"hljs-function\"\u003e() =\u003e\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003evoid\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003etype\u003c/span\u003e f2 = \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003e\u003cspan class=\"hljs-attr\"\u003earg\u003c/span\u003e: \u003cspan class=\"hljs-built_in\"\u003estring\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003earg2\u003c/span\u003e: \u003cspan class=\"hljs-built_in\"\u003enumber\u003c/span\u003e\u003c/span\u003e) =\u003e\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003enumber\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003etype\u003c/span\u003e f3 = \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003e\u003cspan class=\"hljs-attr\"\u003earg\u003c/span\u003e: \u003cspan class=\"hljs-built_in\"\u003enumber\u003c/span\u003e\u003c/span\u003e) =\u003e\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003estring\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003etype\u003c/span\u003e t4 = { \u003cspan class=\"hljs-attr\"\u003ename\u003c/span\u003e: \u003cspan class=\"hljs-built_in\"\u003estring\u003c/span\u003e };\n\n\u003cspan class=\"hljs-keyword\"\u003etype\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eExample1\u003c/span\u003e\u0026#x3C;T\u003e = T \u003cspan class=\"hljs-title function_\"\u003eextends\u003c/span\u003e (\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003e...\u003cspan class=\"hljs-attr\"\u003earg\u003c/span\u003e: infer params\u003c/span\u003e) =\u003e\u003c/span\u003e infer \u003cspan class=\"hljs-title class_\"\u003eResultType\u003c/span\u003e) ? \u003cspan class=\"hljs-title class_\"\u003eResultType\u003c/span\u003e : T;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cimg src=\"/assets/infer_templateLiteral/example-1.png\" alt=\"alt\"\u003e\n\u003cimg src=\"/assets/infer_templateLiteral/example-2.png\" alt=\"alt\"\u003e\n\u003cimg src=\"/assets/infer_templateLiteral/example-3.png\" alt=\"alt\"\u003e\n\u003cimg src=\"/assets/infer_templateLiteral/example-4.png\" alt=\"alt\"\u003e\u003c/p\u003e\n\u003cp\u003e在这里, 我们通过 infer 关键字引入了类型一个名为 ResultType 的新泛型类型变量, 或者可以理解为一个占位符, 当条件类型成立时, ResultType 会替换为满足条件类型时所需的类型, 在这个栗子中 ResultType 代表的是函数的返回类型, 也就完成了我们需要的工具类型.\u003c/p\u003e\n\u003cp\u003e同样, 我们也可以实现一个 \u003cem\u003e提取元组类型中最后一个元素的类型\u003c/em\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-Typescript\"\u003e\u003cspan class=\"hljs-keyword\"\u003etype\u003c/span\u003e lastArrType\u0026#x3C;T \u003cspan class=\"hljs-keyword\"\u003eextends\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003eunknown\u003c/span\u003e[]\u003e = T \u003cspan class=\"hljs-keyword\"\u003eextends\u003c/span\u003e [\n  ...infer rest,\n  infer \u003cspan class=\"hljs-title class_\"\u003eResultType\u003c/span\u003e\n]\n  ? \u003cspan class=\"hljs-title class_\"\u003eResultType\u003c/span\u003e\n  : \u003cspan class=\"hljs-built_in\"\u003enever\u003c/span\u003e;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cimg src=\"/assets/infer_templateLiteral/example-5.png\" alt=\"alt\"\u003e\u003c/p\u003e\n\u003ch2 id=\"template-literal\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#template-literal\"\u003e\u003cspan class=\"icon icon-link\"\u003e\u003c/span\u003e\u003c/a\u003eTemplate Literal\u003c/h2\u003e\n\u003cp\u003e我们先看下基础的字符串文字类型:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-Typescript\"\u003e\u003cspan class=\"hljs-keyword\"\u003etype\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eDemo\u003c/span\u003e = \u003cspan class=\"hljs-string\"\u003e'demo'\u003c/span\u003e;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e模版文字类型是建立在字符串文字类型上的, 举个栗子\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-Typescript\"\u003e\u003cspan class=\"hljs-keyword\"\u003etype\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eHello\u003c/span\u003e = \u003cspan class=\"hljs-string\"\u003e'hello'\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003etype\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eHelloWorld\u003c/span\u003e = \u003cspan class=\"hljs-string\"\u003e`\u003cspan class=\"hljs-subst\"\u003e${Hello}\u003c/span\u003e world`\u003c/span\u003e; \u003cspan class=\"hljs-comment\"\u003e//type HelloWorld = \"hello world\"\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e单从语法上来说, 也是和 javascript 中的模版字符串大同小异.\u003c/p\u003e\n\u003cp\u003e配合联合类型时, 会生成出每个联合成员可以表示的每个可能的字符串文字的集合.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-Typescript\"\u003e\u003cspan class=\"hljs-keyword\"\u003etype\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eEmailLocaleIDs\u003c/span\u003e = \u003cspan class=\"hljs-string\"\u003e\"welcome_email\"\u003c/span\u003e | \u003cspan class=\"hljs-string\"\u003e\"email_heading\"\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003etype\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eFooterLocaleIDs\u003c/span\u003e = \u003cspan class=\"hljs-string\"\u003e\"footer_title\"\u003c/span\u003e | \u003cspan class=\"hljs-string\"\u003e\"footer_sendoff\"\u003c/span\u003e;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cimg src=\"/assets/infer_templateLiteral/example-6.png\" alt=\"alt\"\u003e\u003c/p\u003e\n\u003ch2 id=\"实践\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#实践\"\u003e\u003cspan class=\"icon icon-link\"\u003e\u003c/span\u003e\u003c/a\u003e实践\u003c/h2\u003e\n\u003cp\u003e结合 infer 以及 Template Literal 实现一个类似 \u003ccode\u003eString.replace\u003c/code\u003e 的工具类型\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-Typescript\"\u003e\u003cspan class=\"hljs-keyword\"\u003etype\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eReplaceStr\u003c/span\u003e\u0026#x3C;\n  \u003cspan class=\"hljs-title class_\"\u003eStr\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eextends\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003estring\u003c/span\u003e,\n  \u003cspan class=\"hljs-title class_\"\u003eFrom\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eextends\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003estring\u003c/span\u003e,\n  \u003cspan class=\"hljs-title class_\"\u003eTo\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eextends\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003estring\u003c/span\u003e\n\u003e = \u003cspan class=\"hljs-title class_\"\u003eStr\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eextends\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e`\u003cspan class=\"hljs-subst\"\u003e${infer Prefix}\u003c/span\u003e\u003cspan class=\"hljs-subst\"\u003e${From}\u003c/span\u003e\u003cspan class=\"hljs-subst\"\u003e${infer Suffix}\u003c/span\u003e`\u003c/span\u003e\n  ? \u003cspan class=\"hljs-string\"\u003e`\u003cspan class=\"hljs-subst\"\u003e${Prefix}\u003c/span\u003e\u003cspan class=\"hljs-subst\"\u003e${To}\u003c/span\u003e\u003cspan class=\"hljs-subst\"\u003e${Suffix}\u003c/span\u003e`\u003c/span\u003e\n  : \u003cspan class=\"hljs-title class_\"\u003eStr\u003c/span\u003e;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cimg src=\"/assets/infer_templateLiteral/example-7.png\" alt=\"alt\"\u003e\u003c/p\u003e\n\u003cp\u003e对更多实践感兴趣的可以转到: \u003ca href=\"https://lzs911.github.io/posts/Typescript%20%E4%BD%93%E6%93%8D%E7%BB%83%E4%B9%A0\"\u003ehttps://lzs911.github.io/posts/Typescript%20%E4%BD%93%E6%93%8D%E7%BB%83%E4%B9%A0\u003c/a\u003e\u003c/p\u003e","ogImage":{"url":"/assets/blog/image/cover.jpg"},"coverImage":"/assets/blog/image/cover.jpg","theme":"fancy","tag":[null]}},"__N_SSG":true},"page":"/posts/[slug]","query":{"slug":"TypeScript中的Infer与TemplateLiteral"},"buildId":"YweoWqZUfFtvB-M1jJ2CU","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>