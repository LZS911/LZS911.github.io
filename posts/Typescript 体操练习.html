<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><link rel="apple-touch-icon" sizes="180x180" href="/favicon/apple-touch-icon.png"/><link rel="icon" type="image/png" sizes="32x32" href="/favicon/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="16x16" href="/favicon/favicon-16x16.png"/><link rel="manifest" href="/favicon/site.webmanifest"/><link rel="mask-icon" href="/favicon/safari-pinned-tab.svg" color="#000000"/><link rel="shortcut icon" href="/favicon/favicon.ico"/><meta name="msapplication-TileColor" content="#000000"/><meta name="msapplication-config" content="/favicon/browserconfig.xml"/><meta name="theme-color" content="#000"/><link rel="alternate" type="application/rss+xml" href="/feed.xml"/><meta property="og:image" content="https://og-image.vercel.app/Next.js%20Blog%20Starter%20Example.png?theme=light&amp;md=1&amp;fontSize=100px&amp;images=https%3A%2F%2Fassets.vercel.com%2Fimage%2Fupload%2Ffront%2Fassets%2Fdesign%2Fnextjs-black-logo.svg"/><title>Typescript 体操练习 | Ai.Haibara codes</title><meta name="next-head-count" content="14"/><link rel="preload" href="/_next/static/css/4d9faa1c82c5289e.css" as="style"/><link rel="stylesheet" href="/_next/static/css/4d9faa1c82c5289e.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-8fa1640cc84ba8fe.js" defer=""></script><script src="/_next/static/chunks/framework-3b5a00d5d7e8d93b.js" defer=""></script><script src="/_next/static/chunks/main-59a90320855f5cf5.js" defer=""></script><script src="/_next/static/chunks/pages/_app-a2603426f792f9a7.js" defer=""></script><script src="/_next/static/chunks/799-575b46febca3af7d.js" defer=""></script><script src="/_next/static/chunks/399-cac0cd8ed02bf02a.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bslug%5D-ca05212d4081d62f.js" defer=""></script><script src="/_next/static/n0e0FHUm5j2EY3kOk6REo/_buildManifest.js" defer=""></script><script src="/_next/static/n0e0FHUm5j2EY3kOk6REo/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="min-h-screen"><header class="text-white bg-black drop-shadow-2xl"><div class="mx-auto my-0 max-w-[960px] py-6 px-4 flex items-center"><div class="flex items-center"><img alt="Ai.Haibara" src="/assets/blog/authors/haibara_2.jpg" width="100" height="100" decoding="async" data-nimg="1" class=" rounded-full" loading="lazy" style="color:transparent"/></div><div class="ml-6"><a class=" font-bold text-3xl" href="/">Ai.Haibara codes</a><div class="mt-2"><a class="p-1 rounded-sm text-xl mr-2 hover:border-b-2 border-indigo" href="/">Home</a><a class="p-1 rounded-sm text-xl mr-2 hover:border-b-2 border-indigo" href="/projects">Projects</a><a class="p-1 rounded-sm text-xl mr-2 hover:border-b-2 border-indigo" href="/talks">Talks</a><a class="p-1 rounded-sm text-xl mr-2 hover:border-b-2 border-indigo" href="/blogs">Blogs</a></div></div></div></header><main class="p-6 flex justify-center"><article><div class="flex justify-center font-[Arial]"><h1 class="text-5xl font-bold bg-indigo px-5 py-2 rounded-sm text-shadow-lg leading-[1.1]">Typescript 体操练习</h1></div><time dateTime="2022-09-26" class="text-center block my-4 text-sm opacity-60">September	26, 2022</time><section><div class="markdown-body-fancy max-w-3xl"><p><strong>注: Typescript 使用最新版本号 v4.94</strong></p>
<h2>1. 将下划线模式的 string 类型转化成驼峰类型</h2>
<pre><code class="language-Typescript">type TransformToCamelCase&#x3C;T extends string> =
  T extends `${infer Left}_${infer Rest}`
    ? `${Left}${TransformToCamelCase&#x3C;Capitalize&#x3C;Rest>>}`
    : T;

</code></pre>
<p><img src="/assets/typescript/example-1.png" alt="alt"></p>
<p>注意点:</p>
<p>需要递归继续处理剩余的部分.</p>
<h3>应用: 当服务端定义的实体中的 <code>key</code> 的模式为下环线, 但前端代码中需要使用驼峰模式时</h3>
<p>实现:</p>
<pre><code class="language-Typescript">type CamelCase&#x3C;T extends Record&#x3C;string, any>> = T extends any
  ? {
      [key in keyof T as TransformToCamelCase&#x3C;
        key &#x26; string
      >]: T[key] extends Array&#x3C;infer Element>
        ? Array&#x3C;
            Element extends string
              ? TransformToCamelCase&#x3C;Element>
              : CamelCase&#x3C;Element>
          >
        : T[key] extends Record&#x3C;string, any>
        ? CamelCase&#x3C;T[key]>
        : T[key];
    }
  : never;
</code></pre>
<p><img src="/assets/typescript/example-2.png" alt="alt"></p>
<p>注意点:</p>
<ol>
<li>当某项 <code>key</code> 的类型仍然满足 <code>Record&#x3C;string, any></code> 时, 需要递归继续.</li>
<li>因为 <code>Typescript</code> 不会去计算递归中的表达式, 所以需要加上一个一定为 <code>true</code> 的判断, 让他去执行, 也就是 <code>T extends any</code>.</li>
<li>需要注意 <code>Array</code> 的情况.</li>
</ol>
<h2>2. 将索引类型转化为联合类型</h2>
<ul>
<li>索引类型是一个聚合了多个元素的类型，对象、类、元组等都是索引类型, 举个栗子:</li>
</ul>
<pre><code class="language-Typescript">type ExampleType = {
  name: string;
  sex: boolean;
  age: number;
  hobbies: string[];
}
</code></pre>
<ul>
<li>联合类型. 顾名思义, 它是一个联合了多种类型的集合, 取值可以取其中任意一种类型.</li>
</ul>
<pre><code class="language-Typescript">type UnionTypes = { name: string } | { sex: boolean } | { age: number} | { hobbies: string[] };
</code></pre>
<ul>
<li>
<p>需求: 实现一个工具类, 将 <code>ExampleType</code> 转化为 <code>UnionTypes</code></p>
</li>
<li>
<p>实现:</p>
<pre><code class="language-Typescript">type SpiltObj&#x3C;T> = {
  [key in keyof T]: {
    [key2 in key]:T[key2]
  }
}[keyof T]
</code></pre>
</li>
<li>
<p>拆分, 先看第一部分</p>
<pre><code class="language-Typescript">type SpiltObj&#x3C;T> = {
  [key in keyof T]: {
    [key2 in key]:T[key2]
  }
}
</code></pre>
<pre><code class="language-Typescript">  type Res1 = SpiltObj&#x3C;ExampleType>
</code></pre>
<p><img src="/assets/typescript/example-3.png" alt="alt"></p>
<p>第二部分</p>
<pre><code class="language-Typescript">  type ExampleType = {
    name: string;
    sex: boolean;
    age: number;
    hobbies: string[];
  }

  type Res2 = ExampleType[keyof ExampleType]
</code></pre>
<p><img src="/assets/typescript/example-4.png" alt="alt"></p>
</li>
<li>
<p>拓展, 实现一个工具类, 拿到索性类型键值路径的联合类型</p>
<pre><code class="language-Typescript">type Template = {
  aa: {
    bb: string;
  };
  cc: number;
  dd: {
    ee: {
      ff: string;
    }
  };
  gg: {
    hh: number
  };
}

type TemplateKeyPath&#x3C;T> ={
   [key in keyof T]: key extends string ? T[key] extends Record&#x3C;string, any> ? key | `${key}.${TemplateKeyPath&#x3C;T[key]>}` : key : never;
}[keyof T]

type Res3 = TemplateKeyPath&#x3C;Template>
</code></pre>
<p><img src="/assets/typescript/example-5.png" alt="alt"></p>
</li>
</ul>
<h2>3. 数组长度数值计算</h2>
<p>Typescript 本身是没有加减乘除运算符的, 所以需要取巧来处理数值的计算.</p>
<p>利用构造数组, 然后获取它的 <code>length</code>.</p>
<p><strong>注: 因为数组长度不会为负数, 所以这里做的数值计算只包含正整数</strong></p>
<p><img src="/assets/typescript/example-6.png" alt="alt"></p>
<p>实现运算方法之前, 先实现一个构造数组的工具类</p>
<pre><code class="language-Typescript">type BuildArray&#x3C;
  Length extends number,
  Element = unknown,
  Array extends unknown[] = []
> = Array['length'] extends Length
  ? Array
  : BuildArray&#x3C;Length, Element, [Element, ...Array]>;

</code></pre>
<p><img src="/assets/typescript/example-7.png" alt="alt"></p>
<p><code>BuildArray</code> 接收三个泛形, 其中第一个参数 <code>Length</code> 为需要构造出来的数组长度, <code>Element</code> 为数组类的元素类型, 默认值为 <code>unknown</code>, <code>Array</code> 为返回结果, 用来递归处理. 如果将其转化为 <code>javascript</code> 代码, 大致如下:</p>
<pre><code class="language-javascript">const buildArray = (length, element, arr = []) => {
  if (length === arr.length) {
    return arr;
  }

  return buildArray(length, element, [element, ...arr]);
};
</code></pre>
<h3>1. 加法运算</h3>
<pre><code class="language-typescript">type Add&#x3C;Num1 extends number, Num2 extends number> = [...BuildArray&#x3C;Num1>, ...BuildArray&#x3C;Num2>]['length']
</code></pre>
<p><img src="/assets/typescript/example-8.png" alt="alt"></p>
<p><img src="/assets/typescript/example-9.png" alt="alt"></p>
<h3>2. 减法运算</h3>
<pre><code class="language-typescript">type Subtract&#x3C;
  Num1 extends number,
  Num2 extends number
> = BuildArray&#x3C;Num1> extends [...arr1: BuildArray&#x3C;Num2>, ...arr2: infer Rest]
  ? Rest['length']
  : never;

</code></pre>
<p><img src="/assets/typescript/example-10.png" alt="alt"></p>
<p><img src="/assets/typescript/example-11.png" alt="alt"></p>
<h3>3. 乘法运算</h3>
<pre><code class="language-typescript">type Multiply&#x3C;
  Num1 extends number,
  Num2 extends number,
  ResultArray extends unknown[] = []
> = Num2 extends 0
  ? ResultArray['length']
  : Multiply&#x3C;Num1, Subtract&#x3C;Num2, 1>, [...BuildArray&#x3C;Num1>, ...ResultArray]>;
</code></pre>
<p><img src="/assets/typescript/example-12.png" alt="alt"></p>
<p><img src="/assets/typescript/example-13.png" alt="alt"></p>
<h3>4. 除法运算</h3>
<pre><code class="language-typescript">type Divide&#x3C;
  Num1 extends number,
  Num2 extends number,
  ResultArray extends unknown[] = []
> = Num1 extends 0
  ? ResultArray['length']
  : Divide&#x3C;Subtract&#x3C;Num1, Num2>, Num2, [unknown, ...ResultArray]>; 
  // [unknown, ...ResultArray] => [...BuildArray&#x3C;Add&#x3C;ResultArray['length'], 1> &#x26; number>]

</code></pre>
<p><img src="/assets/typescript/example-14.png" alt="alt"></p>
<p><img src="/assets/typescript/example-15.png" alt="alt"></p></div></section></article></main><footer class="bg-neutral-50 border-t border-neutral-200 text-center text-xs opacity-50 py-4">© 2022,<!-- --> <a rel="noopener noreferrer" class="hover:underline hover:bg-indigo" href="https://github.com/LZS911" target="_blank">LZS_911</a>, build with<!-- --> <a rel="noopener noreferrer" class="underline hover:bg-indigo" href="https://nextjs.org/" target="_blank">Next.js</a> <!-- -->and<!-- --> <a rel="noopener noreferrer" class="underline hover:bg-indigo" href="https://pages.github.com/?(null)" target="_blank">GitHub Pages</a></footer></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"Typescript 体操练习","date":"2022-09-26","slug":"Typescript 体操练习","author":"LZS_911","content":"\u003cp\u003e\u003cstrong\u003e注: Typescript 使用最新版本号 v4.94\u003c/strong\u003e\u003c/p\u003e\n\u003ch2\u003e1. 将下划线模式的 string 类型转化成驼峰类型\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"language-Typescript\"\u003etype TransformToCamelCase\u0026#x3C;T extends string\u003e =\n  T extends `${infer Left}_${infer Rest}`\n    ? `${Left}${TransformToCamelCase\u0026#x3C;Capitalize\u0026#x3C;Rest\u003e\u003e}`\n    : T;\n\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cimg src=\"/assets/typescript/example-1.png\" alt=\"alt\"\u003e\u003c/p\u003e\n\u003cp\u003e注意点:\u003c/p\u003e\n\u003cp\u003e需要递归继续处理剩余的部分.\u003c/p\u003e\n\u003ch3\u003e应用: 当服务端定义的实体中的 \u003ccode\u003ekey\u003c/code\u003e 的模式为下环线, 但前端代码中需要使用驼峰模式时\u003c/h3\u003e\n\u003cp\u003e实现:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-Typescript\"\u003etype CamelCase\u0026#x3C;T extends Record\u0026#x3C;string, any\u003e\u003e = T extends any\n  ? {\n      [key in keyof T as TransformToCamelCase\u0026#x3C;\n        key \u0026#x26; string\n      \u003e]: T[key] extends Array\u0026#x3C;infer Element\u003e\n        ? Array\u0026#x3C;\n            Element extends string\n              ? TransformToCamelCase\u0026#x3C;Element\u003e\n              : CamelCase\u0026#x3C;Element\u003e\n          \u003e\n        : T[key] extends Record\u0026#x3C;string, any\u003e\n        ? CamelCase\u0026#x3C;T[key]\u003e\n        : T[key];\n    }\n  : never;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cimg src=\"/assets/typescript/example-2.png\" alt=\"alt\"\u003e\u003c/p\u003e\n\u003cp\u003e注意点:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e当某项 \u003ccode\u003ekey\u003c/code\u003e 的类型仍然满足 \u003ccode\u003eRecord\u0026#x3C;string, any\u003e\u003c/code\u003e 时, 需要递归继续.\u003c/li\u003e\n\u003cli\u003e因为 \u003ccode\u003eTypescript\u003c/code\u003e 不会去计算递归中的表达式, 所以需要加上一个一定为 \u003ccode\u003etrue\u003c/code\u003e 的判断, 让他去执行, 也就是 \u003ccode\u003eT extends any\u003c/code\u003e.\u003c/li\u003e\n\u003cli\u003e需要注意 \u003ccode\u003eArray\u003c/code\u003e 的情况.\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2\u003e2. 将索引类型转化为联合类型\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e索引类型是一个聚合了多个元素的类型，对象、类、元组等都是索引类型, 举个栗子:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"language-Typescript\"\u003etype ExampleType = {\n  name: string;\n  sex: boolean;\n  age: number;\n  hobbies: string[];\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003e联合类型. 顾名思义, 它是一个联合了多种类型的集合, 取值可以取其中任意一种类型.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"language-Typescript\"\u003etype UnionTypes = { name: string } | { sex: boolean } | { age: number} | { hobbies: string[] };\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e需求: 实现一个工具类, 将 \u003ccode\u003eExampleType\u003c/code\u003e 转化为 \u003ccode\u003eUnionTypes\u003c/code\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e实现:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-Typescript\"\u003etype SpiltObj\u0026#x3C;T\u003e = {\n  [key in keyof T]: {\n    [key2 in key]:T[key2]\n  }\n}[keyof T]\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e拆分, 先看第一部分\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-Typescript\"\u003etype SpiltObj\u0026#x3C;T\u003e = {\n  [key in keyof T]: {\n    [key2 in key]:T[key2]\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class=\"language-Typescript\"\u003e  type Res1 = SpiltObj\u0026#x3C;ExampleType\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cimg src=\"/assets/typescript/example-3.png\" alt=\"alt\"\u003e\u003c/p\u003e\n\u003cp\u003e第二部分\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-Typescript\"\u003e  type ExampleType = {\n    name: string;\n    sex: boolean;\n    age: number;\n    hobbies: string[];\n  }\n\n  type Res2 = ExampleType[keyof ExampleType]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cimg src=\"/assets/typescript/example-4.png\" alt=\"alt\"\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e拓展, 实现一个工具类, 拿到索性类型键值路径的联合类型\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-Typescript\"\u003etype Template = {\n  aa: {\n    bb: string;\n  };\n  cc: number;\n  dd: {\n    ee: {\n      ff: string;\n    }\n  };\n  gg: {\n    hh: number\n  };\n}\n\ntype TemplateKeyPath\u0026#x3C;T\u003e ={\n   [key in keyof T]: key extends string ? T[key] extends Record\u0026#x3C;string, any\u003e ? key | `${key}.${TemplateKeyPath\u0026#x3C;T[key]\u003e}` : key : never;\n}[keyof T]\n\ntype Res3 = TemplateKeyPath\u0026#x3C;Template\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cimg src=\"/assets/typescript/example-5.png\" alt=\"alt\"\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e3. 数组长度数值计算\u003c/h2\u003e\n\u003cp\u003eTypescript 本身是没有加减乘除运算符的, 所以需要取巧来处理数值的计算.\u003c/p\u003e\n\u003cp\u003e利用构造数组, 然后获取它的 \u003ccode\u003elength\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e注: 因为数组长度不会为负数, 所以这里做的数值计算只包含正整数\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/typescript/example-6.png\" alt=\"alt\"\u003e\u003c/p\u003e\n\u003cp\u003e实现运算方法之前, 先实现一个构造数组的工具类\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-Typescript\"\u003etype BuildArray\u0026#x3C;\n  Length extends number,\n  Element = unknown,\n  Array extends unknown[] = []\n\u003e = Array['length'] extends Length\n  ? Array\n  : BuildArray\u0026#x3C;Length, Element, [Element, ...Array]\u003e;\n\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cimg src=\"/assets/typescript/example-7.png\" alt=\"alt\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eBuildArray\u003c/code\u003e 接收三个泛形, 其中第一个参数 \u003ccode\u003eLength\u003c/code\u003e 为需要构造出来的数组长度, \u003ccode\u003eElement\u003c/code\u003e 为数组类的元素类型, 默认值为 \u003ccode\u003eunknown\u003c/code\u003e, \u003ccode\u003eArray\u003c/code\u003e 为返回结果, 用来递归处理. 如果将其转化为 \u003ccode\u003ejavascript\u003c/code\u003e 代码, 大致如下:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003econst buildArray = (length, element, arr = []) =\u003e {\n  if (length === arr.length) {\n    return arr;\n  }\n\n  return buildArray(length, element, [element, ...arr]);\n};\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e1. 加法运算\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-typescript\"\u003etype Add\u0026#x3C;Num1 extends number, Num2 extends number\u003e = [...BuildArray\u0026#x3C;Num1\u003e, ...BuildArray\u0026#x3C;Num2\u003e]['length']\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cimg src=\"/assets/typescript/example-8.png\" alt=\"alt\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/typescript/example-9.png\" alt=\"alt\"\u003e\u003c/p\u003e\n\u003ch3\u003e2. 减法运算\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-typescript\"\u003etype Subtract\u0026#x3C;\n  Num1 extends number,\n  Num2 extends number\n\u003e = BuildArray\u0026#x3C;Num1\u003e extends [...arr1: BuildArray\u0026#x3C;Num2\u003e, ...arr2: infer Rest]\n  ? Rest['length']\n  : never;\n\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cimg src=\"/assets/typescript/example-10.png\" alt=\"alt\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/typescript/example-11.png\" alt=\"alt\"\u003e\u003c/p\u003e\n\u003ch3\u003e3. 乘法运算\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-typescript\"\u003etype Multiply\u0026#x3C;\n  Num1 extends number,\n  Num2 extends number,\n  ResultArray extends unknown[] = []\n\u003e = Num2 extends 0\n  ? ResultArray['length']\n  : Multiply\u0026#x3C;Num1, Subtract\u0026#x3C;Num2, 1\u003e, [...BuildArray\u0026#x3C;Num1\u003e, ...ResultArray]\u003e;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cimg src=\"/assets/typescript/example-12.png\" alt=\"alt\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/typescript/example-13.png\" alt=\"alt\"\u003e\u003c/p\u003e\n\u003ch3\u003e4. 除法运算\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-typescript\"\u003etype Divide\u0026#x3C;\n  Num1 extends number,\n  Num2 extends number,\n  ResultArray extends unknown[] = []\n\u003e = Num1 extends 0\n  ? ResultArray['length']\n  : Divide\u0026#x3C;Subtract\u0026#x3C;Num1, Num2\u003e, Num2, [unknown, ...ResultArray]\u003e; \n  // [unknown, ...ResultArray] =\u003e [...BuildArray\u0026#x3C;Add\u0026#x3C;ResultArray['length'], 1\u003e \u0026#x26; number\u003e]\n\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cimg src=\"/assets/typescript/example-14.png\" alt=\"alt\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/typescript/example-15.png\" alt=\"alt\"\u003e\u003c/p\u003e","theme":"fancy","tag":["Typescript"]}},"__N_SSG":true},"page":"/posts/[slug]","query":{"slug":"Typescript 体操练习"},"buildId":"n0e0FHUm5j2EY3kOk6REo","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>