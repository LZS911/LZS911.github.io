<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><link rel="apple-touch-icon" sizes="180x180" href="/favicon/apple-touch-icon.png"/><link rel="icon" type="image/png" sizes="32x32" href="/favicon/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="16x16" href="/favicon/favicon-16x16.png"/><link rel="manifest" href="/favicon/site.webmanifest"/><link rel="mask-icon" href="/favicon/safari-pinned-tab.svg" color="#000000"/><link rel="shortcut icon" href="/favicon/favicon.ico"/><meta name="msapplication-TileColor" content="#000000"/><meta name="msapplication-config" content="/favicon/browserconfig.xml"/><meta name="theme-color" content="#000"/><link rel="alternate" type="application/rss+xml" href="/feed.xml"/><meta property="og:image" content="https://og-image.vercel.app/Next.js%20Blog%20Starter%20Example.png?theme=light&amp;md=1&amp;fontSize=100px&amp;images=https%3A%2F%2Fassets.vercel.com%2Fimage%2Fupload%2Ffront%2Fassets%2Fdesign%2Fnextjs-black-logo.svg"/><title>Typescript 体操练习 | Ai.Haibara codes</title><meta name="next-head-count" content="14"/><link rel="preload" href="/_next/static/css/4d9faa1c82c5289e.css" as="style"/><link rel="stylesheet" href="/_next/static/css/4d9faa1c82c5289e.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-8fa1640cc84ba8fe.js" defer=""></script><script src="/_next/static/chunks/framework-3b5a00d5d7e8d93b.js" defer=""></script><script src="/_next/static/chunks/main-59a90320855f5cf5.js" defer=""></script><script src="/_next/static/chunks/pages/_app-a2603426f792f9a7.js" defer=""></script><script src="/_next/static/chunks/799-575b46febca3af7d.js" defer=""></script><script src="/_next/static/chunks/399-cac0cd8ed02bf02a.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bslug%5D-ca05212d4081d62f.js" defer=""></script><script src="/_next/static/zaON12bJ9YYL1p-RBJjs6/_buildManifest.js" defer=""></script><script src="/_next/static/zaON12bJ9YYL1p-RBJjs6/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="min-h-screen"><header class="text-white bg-black drop-shadow-2xl"><div class="mx-auto my-0 max-w-[960px] py-6 px-4 flex items-center"><div class="flex items-center"><img alt="Ai.Haibara" src="/assets/blog/authors/haibara_2.jpg" width="100" height="100" decoding="async" data-nimg="1" class=" rounded-full" loading="lazy" style="color:transparent"/></div><div class="ml-6"><a class=" font-bold text-3xl" href="/">Ai.Haibara codes</a><div class="mt-2"><a class="p-1 rounded-sm text-xl mr-2 hover:border-b-2 border-indigo" href="/">Home</a><a class="p-1 rounded-sm text-xl mr-2 hover:border-b-2 border-indigo" href="/projects">Projects</a><a class="p-1 rounded-sm text-xl mr-2 hover:border-b-2 border-indigo" href="/talks">Talks</a><a class="p-1 rounded-sm text-xl mr-2 hover:border-b-2 border-indigo" href="/blogs">Blogs</a></div></div></div></header><main class="p-6 flex justify-center"><article><div class="flex justify-center font-[Arial]"><h1 class="text-5xl font-bold bg-indigo px-5 py-2 rounded-sm text-shadow-lg leading-[1.1]">Typescript 体操练习</h1></div><time dateTime="2022-09-26" class="text-center block my-4 text-sm opacity-60">September	26, 2022</time><section><div class="markdown-body-fancy max-w-3xl"><h2>1. 将下划线模式的 string 类型转化成驼峰类型</h2>
<pre><code class="language-Typescript">type TransformToCamelCase&#x3C;T extends string> =
  T extends `${infer Left}_${infer Rest}`
    ? `${Left}${TransformToCamelCase&#x3C;Capitalize&#x3C;Rest>>}`
    : T;

type res1 = TransformToCamelCase&#x3C;'aa_bb_cc_dd'>; //type res1 = "aaBbCcDd"

</code></pre>
<p>注意点:</p>
<p>需要递归继续处理剩余的部分.</p>
<h3>应用: 当服务端定义的实体中的 <code>key</code> 的模式为下环线, 但前端代码中需要使用驼峰模式时</h3>
<p>实现:</p>
<pre><code class="language-Typescript">type CamelCase&#x3C;T extends Record&#x3C;string, any>> = T extends any
  ? {
      [key in keyof T as TransformToCamelCase&#x3C;
        key &#x26; string
      >]: T[key] extends Array&#x3C;infer Element>
        ? Array&#x3C;
            Element extends string
              ? TransformToCamelCase&#x3C;Element>
              : CamelCase&#x3C;Element>
          >
        : T[key] extends Record&#x3C;string, any>
        ? CamelCase&#x3C;T[key]>
        : T[key];
    }
  : never;
</code></pre>
<p>注意点:</p>
<ol>
<li>当某项 <code>key</code> 的类型仍然满足 <code>Record&#x3C;string, any></code> 时, 需要递归继续.</li>
<li>因为 <code>Typescript</code> 不会去计算递归中的表达式, 所以需要加上一个一定为 <code>true</code> 的判断, 让他去执行, 也就是 <code>T extends any</code>.</li>
<li>需要注意 <code>Array</code> 的情况.</li>
</ol>
<h2>2. 将索引类型转化为联合类型</h2>
<ul>
<li>索引类型是一个聚合了多个元素的类型，对象、类、元组等都是索引类型, 举个栗子:</li>
</ul>
<pre><code class="language-Typescript">type ExampleType = {
  name: string;
  sex: boolean;
  age: number;
  hobbies: string[];
}
</code></pre>
<ul>
<li>联合类型. 顾名思义, 它是一个联合了多种类型的集合, 取值可以取其中任意一种类型.</li>
</ul>
<pre><code class="language-Typescript">type UnionTypes = { name: string } | { sex: boolean } | { age: number} | { hobbies: string[] };
</code></pre>
<ul>
<li>
<p>需求: 实现一个工具类, 将 <code>ExampleType</code> 转化为 <code>UnionTypes</code></p>
</li>
<li>
<p>实现:</p>
<pre><code class="language-Typescript">type SpiltObj&#x3C;T> = {
  [key in keyof T]: {
    [key2 in key]:T[key2]
  }
}[keyof T]
</code></pre>
</li>
<li>
<p>拆分, 先看第一部分</p>
<pre><code class="language-Typescript">type SpiltObj&#x3C;T> = {
  [key in keyof T]: {
    [key2 in key]:T[key2]
  }
}
</code></pre>
<pre><code class="language-Typescript">  type Res = SpiltObj&#x3C;ExampleType>

  /** type Res = {
   name: string;
   } | {
       sex: boolean;
   } | {
       age: number;
   } | {
       hobbies: string[];
   } **/
</code></pre>
<p>第二部分</p>
<pre><code class="language-Typescript">  type ExampleType = {
    name: string;
    sex: boolean;
    age: number;
    hobbies: string[];
  }

  type res = ExampleType[keyof ExampleType]

  //type res = string | number | boolean | string[]
</code></pre>
</li>
<li>
<p>拓展, 实现一个工具类, 拿到索性类型键值路径的联合类型</p>
<pre><code class="language-Typescript">type Template = {
  aa: {
    bb: string;
  };
  cc: number;
  dd: {
    ee: {
      ff: string;
    }
  };
  gg: {
    hh: number
  };
}

type demo = 'aa' | 'cc' | 'dd' | 'gg' | 'aa.bb' |'dd.ee' | 'dd.ee.ff' | 'gg.hh'

type TemplateKeyPath&#x3C;T> ={
   [key in keyof T]: key extends string ? T[key] extends Record&#x3C;string, any> ? key | `${key}.${TemplateKeyPath&#x3C;T[key]>}` : key : never;
}[keyof T]

type res2 = TemplateKeyPath&#x3C;Template>
//type res2 = "aa" | "cc" | "dd" | "gg" | "aa.bb" | "dd.ee" | "dd.ee.ff" | "gg.hh"
</code></pre>
</li>
</ul></div></section></article></main><footer class="bg-neutral-50 border-t border-neutral-200 text-center text-xs opacity-50 py-4">© 2022,<!-- --> <a rel="noopener noreferrer" class="hover:underline hover:bg-indigo" href="https://github.com/LZS911" target="_blank">LZS_911</a>, build with<!-- --> <a rel="noopener noreferrer" class="underline hover:bg-indigo" href="https://nextjs.org/" target="_blank">Next.js</a> <!-- -->and<!-- --> <a rel="noopener noreferrer" class="underline hover:bg-indigo" href="https://pages.github.com/?(null)" target="_blank">GitHub Pages</a></footer></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"Typescript 体操练习","date":"2022-09-26","slug":"Typescript 体操练习","author":"LZS_911","content":"\u003ch2\u003e1. 将下划线模式的 string 类型转化成驼峰类型\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"language-Typescript\"\u003etype TransformToCamelCase\u0026#x3C;T extends string\u003e =\n  T extends `${infer Left}_${infer Rest}`\n    ? `${Left}${TransformToCamelCase\u0026#x3C;Capitalize\u0026#x3C;Rest\u003e\u003e}`\n    : T;\n\ntype res1 = TransformToCamelCase\u0026#x3C;'aa_bb_cc_dd'\u003e; //type res1 = \"aaBbCcDd\"\n\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e注意点:\u003c/p\u003e\n\u003cp\u003e需要递归继续处理剩余的部分.\u003c/p\u003e\n\u003ch3\u003e应用: 当服务端定义的实体中的 \u003ccode\u003ekey\u003c/code\u003e 的模式为下环线, 但前端代码中需要使用驼峰模式时\u003c/h3\u003e\n\u003cp\u003e实现:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-Typescript\"\u003etype CamelCase\u0026#x3C;T extends Record\u0026#x3C;string, any\u003e\u003e = T extends any\n  ? {\n      [key in keyof T as TransformToCamelCase\u0026#x3C;\n        key \u0026#x26; string\n      \u003e]: T[key] extends Array\u0026#x3C;infer Element\u003e\n        ? Array\u0026#x3C;\n            Element extends string\n              ? TransformToCamelCase\u0026#x3C;Element\u003e\n              : CamelCase\u0026#x3C;Element\u003e\n          \u003e\n        : T[key] extends Record\u0026#x3C;string, any\u003e\n        ? CamelCase\u0026#x3C;T[key]\u003e\n        : T[key];\n    }\n  : never;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e注意点:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e当某项 \u003ccode\u003ekey\u003c/code\u003e 的类型仍然满足 \u003ccode\u003eRecord\u0026#x3C;string, any\u003e\u003c/code\u003e 时, 需要递归继续.\u003c/li\u003e\n\u003cli\u003e因为 \u003ccode\u003eTypescript\u003c/code\u003e 不会去计算递归中的表达式, 所以需要加上一个一定为 \u003ccode\u003etrue\u003c/code\u003e 的判断, 让他去执行, 也就是 \u003ccode\u003eT extends any\u003c/code\u003e.\u003c/li\u003e\n\u003cli\u003e需要注意 \u003ccode\u003eArray\u003c/code\u003e 的情况.\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2\u003e2. 将索引类型转化为联合类型\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e索引类型是一个聚合了多个元素的类型，对象、类、元组等都是索引类型, 举个栗子:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"language-Typescript\"\u003etype ExampleType = {\n  name: string;\n  sex: boolean;\n  age: number;\n  hobbies: string[];\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003e联合类型. 顾名思义, 它是一个联合了多种类型的集合, 取值可以取其中任意一种类型.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"language-Typescript\"\u003etype UnionTypes = { name: string } | { sex: boolean } | { age: number} | { hobbies: string[] };\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e需求: 实现一个工具类, 将 \u003ccode\u003eExampleType\u003c/code\u003e 转化为 \u003ccode\u003eUnionTypes\u003c/code\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e实现:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-Typescript\"\u003etype SpiltObj\u0026#x3C;T\u003e = {\n  [key in keyof T]: {\n    [key2 in key]:T[key2]\n  }\n}[keyof T]\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e拆分, 先看第一部分\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-Typescript\"\u003etype SpiltObj\u0026#x3C;T\u003e = {\n  [key in keyof T]: {\n    [key2 in key]:T[key2]\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class=\"language-Typescript\"\u003e  type Res = SpiltObj\u0026#x3C;ExampleType\u003e\n\n  /** type Res = {\n   name: string;\n   } | {\n       sex: boolean;\n   } | {\n       age: number;\n   } | {\n       hobbies: string[];\n   } **/\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e第二部分\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-Typescript\"\u003e  type ExampleType = {\n    name: string;\n    sex: boolean;\n    age: number;\n    hobbies: string[];\n  }\n\n  type res = ExampleType[keyof ExampleType]\n\n  //type res = string | number | boolean | string[]\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e拓展, 实现一个工具类, 拿到索性类型键值路径的联合类型\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-Typescript\"\u003etype Template = {\n  aa: {\n    bb: string;\n  };\n  cc: number;\n  dd: {\n    ee: {\n      ff: string;\n    }\n  };\n  gg: {\n    hh: number\n  };\n}\n\ntype demo = 'aa' | 'cc' | 'dd' | 'gg' | 'aa.bb' |'dd.ee' | 'dd.ee.ff' | 'gg.hh'\n\ntype TemplateKeyPath\u0026#x3C;T\u003e ={\n   [key in keyof T]: key extends string ? T[key] extends Record\u0026#x3C;string, any\u003e ? key | `${key}.${TemplateKeyPath\u0026#x3C;T[key]\u003e}` : key : never;\n}[keyof T]\n\ntype res2 = TemplateKeyPath\u0026#x3C;Template\u003e\n//type res2 = \"aa\" | \"cc\" | \"dd\" | \"gg\" | \"aa.bb\" | \"dd.ee\" | \"dd.ee.ff\" | \"gg.hh\"\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003c/ul\u003e","ogImage":{"url":"/assets/blog/image/cover.jpg"},"coverImage":"/assets/blog/image/cover.jpg","theme":"fancy","tag":["Typescript"]}},"__N_SSG":true},"page":"/posts/[slug]","query":{"slug":"Typescript 体操练习"},"buildId":"zaON12bJ9YYL1p-RBJjs6","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>