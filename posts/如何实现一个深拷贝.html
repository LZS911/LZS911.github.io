<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><link rel="apple-touch-icon" sizes="180x180" href="/favicon/apple-touch-icon.png"/><link rel="icon" type="image/png" sizes="32x32" href="/favicon/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="16x16" href="/favicon/favicon-16x16.png"/><link rel="manifest" href="/favicon/site.webmanifest"/><link rel="mask-icon" href="/favicon/safari-pinned-tab.svg" color="#000000"/><link rel="shortcut icon" href="/favicon/favicon.ico"/><meta name="msapplication-TileColor" content="#000000"/><meta name="msapplication-config" content="/favicon/browserconfig.xml"/><meta name="theme-color" content="#000"/><link rel="alternate" type="application/rss+xml" href="/feed.xml"/><meta property="og:image" content="https://og-image.vercel.app/Next.js%20Blog%20Starter%20Example.png?theme=light&amp;md=1&amp;fontSize=100px&amp;images=https%3A%2F%2Fassets.vercel.com%2Fimage%2Fupload%2Ffront%2Fassets%2Fdesign%2Fnextjs-black-logo.svg"/><title>如何实现一个深拷贝? | Ai.Haibara codes</title><meta name="next-head-count" content="14"/><link rel="preload" href="/_next/static/css/cbc0135ff184ccab.css" as="style"/><link rel="stylesheet" href="/_next/static/css/cbc0135ff184ccab.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-8fa1640cc84ba8fe.js" defer=""></script><script src="/_next/static/chunks/framework-3b5a00d5d7e8d93b.js" defer=""></script><script src="/_next/static/chunks/main-59a90320855f5cf5.js" defer=""></script><script src="/_next/static/chunks/pages/_app-f46e289d7ac5e197.js" defer=""></script><script src="/_next/static/chunks/799-575b46febca3af7d.js" defer=""></script><script src="/_next/static/chunks/399-cac0cd8ed02bf02a.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bslug%5D-ca05212d4081d62f.js" defer=""></script><script src="/_next/static/49fLkzfs_HcmweSHi3iJW/_buildManifest.js" defer=""></script><script src="/_next/static/49fLkzfs_HcmweSHi3iJW/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="min-h-screen"><header class="text-white bg-black drop-shadow-2xl"><div class="mx-auto my-0 max-w-[960px] py-6 px-4 flex items-center"><div class="flex items-center"><img alt="Ai.Haibara" src="/assets/blog/authors/haibara_2.jpg" width="100" height="100" decoding="async" data-nimg="1" class=" rounded-full" loading="lazy" style="color:transparent"/></div><div class="ml-6"><a class=" font-bold text-3xl" href="/">Ai.Haibara codes</a><div class="mt-2"><a class="p-1 rounded-sm text-xl mr-2 hover:border-b-2 border-indigo" href="/">Home</a><a class="p-1 rounded-sm text-xl mr-2 hover:border-b-2 border-indigo" href="/projects">Projects</a><a class="p-1 rounded-sm text-xl mr-2 hover:border-b-2 border-indigo" href="/talks">Talks</a><a class="p-1 rounded-sm text-xl mr-2 hover:border-b-2 border-indigo" href="/blogs">Blogs</a></div></div></div></header><main class="p-6 flex justify-center"><article><div class="flex justify-center font-[Arial]"><h1 class="text-5xl font-bold bg-indigo px-5 py-2 rounded-sm text-shadow-lg leading-[1.1]">如何实现一个深拷贝?</h1></div><time dateTime="2021-12-06" class="text-center block my-4 text-sm opacity-60">December	6, 2021</time><section><div class="markdown-body-vuepress max-w-3xl"><h2 id="赋值浅拷贝"><a aria-hidden="true" tabindex="-1" href="#赋值浅拷贝"><span class="icon icon-link"></span></a>赋值、浅拷贝</h2>
<hr>
<p>首先, 我们来看一个概念性的问题, 赋值、浅拷贝、深拷贝之间有什么区别?</p>
<ol>
<li>
<p>赋值:</p>
<pre><code class="language-javascript">const obj = { bar: 'foo' };
const obj2 = obj;
obj2.bar = 'baz';
console.log(obj); //{ bar: 'baz' }
</code></pre>
<p>当我们复制引用类型的变量时，实际上复制的是栈中存储的地址，所以复制出来的 <code>obj2</code> 实际上和 <code>obj</code> 指向的堆中同一个对象。因此， 我们改变其中任何一个变量的值，另一个变量都会受到影响，这就是为什么会有深拷贝和浅拷贝的原因。</p>
</li>
<li>
<p>浅拷贝:</p>
<pre><code class="language-javascript">const foo = { name: 'foo' };
const obj = { bar: 'str', baz: foo };
const obj2 = { ...obj };
obj2.bar = 'number';
obj2.baz.name = 'foo2';
console.log(obj); //{ bar: 'str', baz: { name: 'foo2' } }
</code></pre>
<p>创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。如果属性是基本类型，拷贝的就是基本类型的值，如果属性是引用类型，拷贝的就是内存地址 ，所以如果其中一个对象改变了这个地址，就会影响到另一个对象。</p>
</li>
</ol>
<p>讲个题外话: 值传递和引用传递</p>
<p>先看两段代码:</p>
<pre><code class="language-javascript">function setName(name) {
  name = 'foo';
}

const bar = 'bar';

setName(bar);
console.log(bar); //'bar'
</code></pre>
<p>很明显，上面的执行结果是 <code>bar</code>，即函数参数仅仅是被传入变量赋值给了的一个局部变量，改变这个局部变量不会对外部变量产生影响.</p>
<pre><code class="language-javascript">function setName(obj) {
  obj.name = 'foo';
}

const obj = { name: 'baz' };

setName(obj);
console.log(obj); //{name: 'foo'; }
</code></pre>
<p>上面的代码可能让你产生疑惑，是不是参数是引用类型就是引用传递呢？</p>
<p>当函数参数是引用类型时，我们同样将参数复制了一个副本到局部变量，只不过复制的这个副本是指向堆内存中的地址而已，我们在函数内部对对象的属性进行操作，实际上和外部变量指向堆内存中的值相同，但是这并不代表着引用传递，下面我们再看一段代码:</p>
<pre><code class="language-javascript">const obj = {};

function setName(o) {
  o.name = 'bar';
  o = { name: 'baz' };
}
setName(obj);

console.log(obj);
</code></pre>
<p>最后 输出为 <code>{name: 'bar'}</code>, 函数参数传递的并不是变量的引用，而是变量拷贝的副本，当变量是原始类型时，这个副本就是值本身，当变量是引用类型时，这个副本是指向堆内存的地址.</p>
<h2 id="深拷贝"><a aria-hidden="true" tabindex="-1" href="#深拷贝"><span class="icon icon-link"></span></a>深拷贝</h2>
<hr>
<p>回到主题, 来实现我们的深拷贝.</p>
<ol>
<li>
<p>乞丐版:</p>
<pre><code class="language-javascript">const deepClone = (obj) => JSON.parse(JSON.stringify(obj));
</code></pre>
<p>最简易实现方式, 但对于值为 <code>function、undefined、symbol</code> 类型时无法处理</p>
</li>
<li>
<p>合格版</p>
<pre><code class="language-javascript">const deepClone = (source) => {
  if (source === null) {
    return null;
  }
  if (source === undefined) {
    return undefined;
  }

  if (typeof source === 'object') {
    if (Array.isArray(source)) {
      const clone = [];
      source.forEach((v) => {
        clone.push(deepClone(v));
      });
      return clone;
    }
    const clone = {};
    Object.keys(source).forEach((key) => {
      clone[key] = deepClone(source[key]);
    });
    return clone;
  }
  return source;
};
</code></pre>
<p>能正确的处理 <code>function、undefined、symbol, array</code> 等类型, 但是当存在循环引用是, 会进入死循环.</p>
</li>
<li>
<p>较完整版</p>
<pre><code class="language-typescript">const isArray = &#x3C;T>(source: unknown): source is Array&#x3C;T> =>
  Array.isArray(source);

const isMap = (source: unknown): source is Map =>
  Object.prototype.toString.call(source) === '[object Map]';

const isSet = &#x3C;T>(source: unknown): source is Set&#x3C;T> =>
  Object.prototype.toString.call(source) === '[object Set]';

const isObject = (source: unknown) => {
  const type = typeof source;
  return source !== null &#x26;&#x26; type === 'object';
};

const initData = (source: any) => {
  const { constructor } = source;
  if (!!constructor) {
    return new constructor();
  }
  return;
};

const deepClone = (source: unknown, map = new WeakMap()) => {
  if (!isObject(source)) {
    return source;
  }
  const clone = initData(source);
  if (!clone) {
    return source;
  }
  if (!!map.has(source as Object)) {
    return map.get(source as Object);
  }
  map.set(source as Object, clone);

  if (isArray&#x3C;any>(source)) {
    source.forEach((v) => {
      (clone as Array&#x3C;any>).push(deepClone(v, map));
    });
    return clone;
  }

  if (isMap&#x3C;any, any>(source)) {
    source.forEach((v, key) => {
      (clone as Map&#x3C;any, any>).set(key, deepClone(v, map));
    });
    return clone;
  }

  if (isSet&#x3C;any>(source)) {
    source.forEach((v) => {
      (clone as Set&#x3C;any>).add(deepClone(v, map));
    });
    return clone;
  }

  Object.keys(source as any).forEach((v) => {
    clone[v] = deepClone((source as any)[v], map);
  });
  return clone;
};

export default deepClone;
</code></pre>
</li>
</ol>
<p>解决循环引用问题，我们可以额外开辟一个存储空间，来存储当前对象和拷贝对象的对应关系，当需要拷贝当前对象时，先去存储空间中找，有没有拷贝过这个对象，如果有的话直接返回，如果没有的话继续拷贝，这样就巧妙化解的循环引用的问题。</p>
<p>这个存储空间，需要可以存储 <code>key-value</code> 形式的数据，且 <code>key</code> 可以是一个引用类型，我们可以选择 <code>WeakMap</code> 这种数据结构：
</p>
<ul>
<li>检查 <code>map</code> 中有无克隆过的对象</li>
<li>有 - 直接返回</li>
<li>没有 - 将当前对象作为 <code>key</code>，克隆对象作为 <code>value</code> 进行存储</li>
<li>继续克隆</li>
</ul>
<p>当然, 这里只考虑了 <code>Array</code> 、 <code>Object</code>、 <code>Map</code> 和 <code>Set</code> 四种可继续遍历类型, 还有其他类型, 这里不继续研究了...</p>
<h2 id="map-与-weakmap"><a aria-hidden="true" tabindex="-1" href="#map-与-weakmap"><span class="icon icon-link"></span></a><a href="https://es6.ruanyifeng.com/#docs/set-map#Map"><code>Map</code> 与 <code>WeakMap</code></a></h2>
<hr>
<p><code>Map</code> 是 <code>ES6</code> 中新增数据类型, 主要为了解决传统 <code>Object</code> 只能使用字符串作为键值, 并且不能够很方便的获取键的长度.</p>
<p><code>WeakMap</code> 与 <code>Map</code> 的区别有两点:</p>
<ol>
<li>
<p><code>WeakMap</code> 只接受对象作为键名（<code>null</code> 除外），不接受其他类型的值作为键名。</p>
</li>
<li>
<p><code>WeakMap</code> 的键名所指向的对象，不计入垃圾回收机制。</p>
</li>
</ol>
<p>利用第 2 点便不用担心当我们要拷贝的对象非常庞大时，使用 Map 会对内存造成非常大的额外消耗，而且我们需要手动清除 Map 的属性才能释放这块内存，而 WeakMap 会帮我们巧妙化解这个问题。</p>
<p>测试代码地址: <a href="https://github.com/LZS911/vue3-ts-vite2-ly-component/tree/master/src/utils/deepClone">https://github.com/LZS911/vue3-ts-vite2-ly-component/tree/master/src/utils/deepClone</a></p></div></section></article></main><footer class="bg-neutral-50 border-t border-neutral-200 text-center text-xs opacity-50 py-4">© 2022,<!-- --> <a rel="noopener noreferrer" class="hover:underline hover:bg-indigo" href="https://github.com/LZS911" target="_blank">LZS_911</a>, build with<!-- --> <a rel="noopener noreferrer" class="underline hover:bg-indigo" href="https://nextjs.org/" target="_blank">Next.js</a> <!-- -->and<!-- --> <a rel="noopener noreferrer" class="underline hover:bg-indigo" href="https://pages.github.com/?(null)" target="_blank">GitHub Pages</a></footer></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"如何实现一个深拷贝?","date":"2021-12-06","slug":"如何实现一个深拷贝","author":"LZS_911","content":"\u003ch2 id=\"赋值浅拷贝\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#赋值浅拷贝\"\u003e\u003cspan class=\"icon icon-link\"\u003e\u003c/span\u003e\u003c/a\u003e赋值、浅拷贝\u003c/h2\u003e\n\u003chr\u003e\n\u003cp\u003e首先, 我们来看一个概念性的问题, 赋值、浅拷贝、深拷贝之间有什么区别?\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e赋值:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003econst obj = { bar: 'foo' };\nconst obj2 = obj;\nobj2.bar = 'baz';\nconsole.log(obj); //{ bar: 'baz' }\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e当我们复制引用类型的变量时，实际上复制的是栈中存储的地址，所以复制出来的 \u003ccode\u003eobj2\u003c/code\u003e 实际上和 \u003ccode\u003eobj\u003c/code\u003e 指向的堆中同一个对象。因此， 我们改变其中任何一个变量的值，另一个变量都会受到影响，这就是为什么会有深拷贝和浅拷贝的原因。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e浅拷贝:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003econst foo = { name: 'foo' };\nconst obj = { bar: 'str', baz: foo };\nconst obj2 = { ...obj };\nobj2.bar = 'number';\nobj2.baz.name = 'foo2';\nconsole.log(obj); //{ bar: 'str', baz: { name: 'foo2' } }\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。如果属性是基本类型，拷贝的就是基本类型的值，如果属性是引用类型，拷贝的就是内存地址 ，所以如果其中一个对象改变了这个地址，就会影响到另一个对象。\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e讲个题外话: 值传递和引用传递\u003c/p\u003e\n\u003cp\u003e先看两段代码:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003efunction setName(name) {\n  name = 'foo';\n}\n\nconst bar = 'bar';\n\nsetName(bar);\nconsole.log(bar); //'bar'\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e很明显，上面的执行结果是 \u003ccode\u003ebar\u003c/code\u003e，即函数参数仅仅是被传入变量赋值给了的一个局部变量，改变这个局部变量不会对外部变量产生影响.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003efunction setName(obj) {\n  obj.name = 'foo';\n}\n\nconst obj = { name: 'baz' };\n\nsetName(obj);\nconsole.log(obj); //{name: 'foo'; }\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e上面的代码可能让你产生疑惑，是不是参数是引用类型就是引用传递呢？\u003c/p\u003e\n\u003cp\u003e当函数参数是引用类型时，我们同样将参数复制了一个副本到局部变量，只不过复制的这个副本是指向堆内存中的地址而已，我们在函数内部对对象的属性进行操作，实际上和外部变量指向堆内存中的值相同，但是这并不代表着引用传递，下面我们再看一段代码:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003econst obj = {};\n\nfunction setName(o) {\n  o.name = 'bar';\n  o = { name: 'baz' };\n}\nsetName(obj);\n\nconsole.log(obj);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e最后 输出为 \u003ccode\u003e{name: 'bar'}\u003c/code\u003e, 函数参数传递的并不是变量的引用，而是变量拷贝的副本，当变量是原始类型时，这个副本就是值本身，当变量是引用类型时，这个副本是指向堆内存的地址.\u003c/p\u003e\n\u003ch2 id=\"深拷贝\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#深拷贝\"\u003e\u003cspan class=\"icon icon-link\"\u003e\u003c/span\u003e\u003c/a\u003e深拷贝\u003c/h2\u003e\n\u003chr\u003e\n\u003cp\u003e回到主题, 来实现我们的深拷贝.\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e乞丐版:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003econst deepClone = (obj) =\u003e JSON.parse(JSON.stringify(obj));\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e最简易实现方式, 但对于值为 \u003ccode\u003efunction、undefined、symbol\u003c/code\u003e 类型时无法处理\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e合格版\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003econst deepClone = (source) =\u003e {\n  if (source === null) {\n    return null;\n  }\n  if (source === undefined) {\n    return undefined;\n  }\n\n  if (typeof source === 'object') {\n    if (Array.isArray(source)) {\n      const clone = [];\n      source.forEach((v) =\u003e {\n        clone.push(deepClone(v));\n      });\n      return clone;\n    }\n    const clone = {};\n    Object.keys(source).forEach((key) =\u003e {\n      clone[key] = deepClone(source[key]);\n    });\n    return clone;\n  }\n  return source;\n};\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e能正确的处理 \u003ccode\u003efunction、undefined、symbol, array\u003c/code\u003e 等类型, 但是当存在循环引用是, 会进入死循环.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e较完整版\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-typescript\"\u003econst isArray = \u0026#x3C;T\u003e(source: unknown): source is Array\u0026#x3C;T\u003e =\u003e\n  Array.isArray(source);\n\nconst isMap = (source: unknown): source is Map =\u003e\n  Object.prototype.toString.call(source) === '[object Map]';\n\nconst isSet = \u0026#x3C;T\u003e(source: unknown): source is Set\u0026#x3C;T\u003e =\u003e\n  Object.prototype.toString.call(source) === '[object Set]';\n\nconst isObject = (source: unknown) =\u003e {\n  const type = typeof source;\n  return source !== null \u0026#x26;\u0026#x26; type === 'object';\n};\n\nconst initData = (source: any) =\u003e {\n  const { constructor } = source;\n  if (!!constructor) {\n    return new constructor();\n  }\n  return;\n};\n\nconst deepClone = (source: unknown, map = new WeakMap()) =\u003e {\n  if (!isObject(source)) {\n    return source;\n  }\n  const clone = initData(source);\n  if (!clone) {\n    return source;\n  }\n  if (!!map.has(source as Object)) {\n    return map.get(source as Object);\n  }\n  map.set(source as Object, clone);\n\n  if (isArray\u0026#x3C;any\u003e(source)) {\n    source.forEach((v) =\u003e {\n      (clone as Array\u0026#x3C;any\u003e).push(deepClone(v, map));\n    });\n    return clone;\n  }\n\n  if (isMap\u0026#x3C;any, any\u003e(source)) {\n    source.forEach((v, key) =\u003e {\n      (clone as Map\u0026#x3C;any, any\u003e).set(key, deepClone(v, map));\n    });\n    return clone;\n  }\n\n  if (isSet\u0026#x3C;any\u003e(source)) {\n    source.forEach((v) =\u003e {\n      (clone as Set\u0026#x3C;any\u003e).add(deepClone(v, map));\n    });\n    return clone;\n  }\n\n  Object.keys(source as any).forEach((v) =\u003e {\n    clone[v] = deepClone((source as any)[v], map);\n  });\n  return clone;\n};\n\nexport default deepClone;\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e解决循环引用问题，我们可以额外开辟一个存储空间，来存储当前对象和拷贝对象的对应关系，当需要拷贝当前对象时，先去存储空间中找，有没有拷贝过这个对象，如果有的话直接返回，如果没有的话继续拷贝，这样就巧妙化解的循环引用的问题。\u003c/p\u003e\n\u003cp\u003e这个存储空间，需要可以存储 \u003ccode\u003ekey-value\u003c/code\u003e 形式的数据，且 \u003ccode\u003ekey\u003c/code\u003e 可以是一个引用类型，我们可以选择 \u003ccode\u003eWeakMap\u003c/code\u003e 这种数据结构：\n\b\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e检查 \u003ccode\u003emap\u003c/code\u003e 中有无克隆过的对象\u003c/li\u003e\n\u003cli\u003e有 - 直接返回\u003c/li\u003e\n\u003cli\u003e没有 - 将当前对象作为 \u003ccode\u003ekey\u003c/code\u003e，克隆对象作为 \u003ccode\u003evalue\u003c/code\u003e 进行存储\u003c/li\u003e\n\u003cli\u003e继续克隆\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e当然, 这里只考虑了 \u003ccode\u003eArray\u003c/code\u003e 、 \u003ccode\u003eObject\u003c/code\u003e、 \u003ccode\u003eMap\u003c/code\u003e 和 \u003ccode\u003eSet\u003c/code\u003e 四种可继续遍历类型, 还有其他类型, 这里不继续研究了...\u003c/p\u003e\n\u003ch2 id=\"map-与-weakmap\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#map-与-weakmap\"\u003e\u003cspan class=\"icon icon-link\"\u003e\u003c/span\u003e\u003c/a\u003e\u003ca href=\"https://es6.ruanyifeng.com/#docs/set-map#Map\"\u003e\u003ccode\u003eMap\u003c/code\u003e 与 \u003ccode\u003eWeakMap\u003c/code\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003chr\u003e\n\u003cp\u003e\u003ccode\u003eMap\u003c/code\u003e 是 \u003ccode\u003eES6\u003c/code\u003e 中新增数据类型, 主要为了解决传统 \u003ccode\u003eObject\u003c/code\u003e 只能使用字符串作为键值, 并且不能够很方便的获取键的长度.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eWeakMap\u003c/code\u003e 与 \u003ccode\u003eMap\u003c/code\u003e 的区别有两点:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003eWeakMap\u003c/code\u003e 只接受对象作为键名（\u003ccode\u003enull\u003c/code\u003e 除外），不接受其他类型的值作为键名。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003eWeakMap\u003c/code\u003e 的键名所指向的对象，不计入垃圾回收机制。\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e利用第 2 点便不用担心当我们要拷贝的对象非常庞大时，使用 Map 会对内存造成非常大的额外消耗，而且我们需要手动清除 Map 的属性才能释放这块内存，而 WeakMap 会帮我们巧妙化解这个问题。\u003c/p\u003e\n\u003cp\u003e测试代码地址: \u003ca href=\"https://github.com/LZS911/vue3-ts-vite2-ly-component/tree/master/src/utils/deepClone\"\u003ehttps://github.com/LZS911/vue3-ts-vite2-ly-component/tree/master/src/utils/deepClone\u003c/a\u003e\u003c/p\u003e","ogImage":{"url":"/assets/blog/image/cover.jpg"},"coverImage":"/assets/blog/image/cover.jpg","theme":"vuepress","tag":["javascript"]}},"__N_SSG":true},"page":"/posts/[slug]","query":{"slug":"如何实现一个深拷贝"},"buildId":"49fLkzfs_HcmweSHi3iJW","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>