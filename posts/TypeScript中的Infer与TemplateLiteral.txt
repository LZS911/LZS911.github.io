1:"$Sreact.fragment"
2:I[996,["874","static/chunks/874-0197bf8342d89979.js","766","static/chunks/766-45f65761a5dfbf2c.js","177","static/chunks/app/layout-bb1da1aafb2c343b.js"],"default"]
3:I[7555,[],""]
4:I[1901,["874","static/chunks/874-0197bf8342d89979.js","39","static/chunks/app/error-d036ecfd03716e30.js"],"default"]
5:I[1295,[],""]
6:I[9543,["874","static/chunks/874-0197bf8342d89979.js","345","static/chunks/app/not-found-2113bbd7a2f55e8f.js"],"default"]
8:I[9665,[],"MetadataBoundary"]
a:I[9665,[],"OutletBoundary"]
d:I[4911,[],"AsyncMetadataOutlet"]
f:I[8460,["209","static/chunks/app/loading-b73dd9bd22c3caa2.js"],"default"]
10:I[9665,[],"ViewportBoundary"]
12:I[6614,[],""]
:HL["/_next/static/media/569ce4b8f30dc480-s.p.woff2","font",{"crossOrigin":"","type":"font/woff2"}]
:HL["/_next/static/media/93f479601ee12b01-s.p.woff2","font",{"crossOrigin":"","type":"font/woff2"}]
:HL["/_next/static/css/aa504e0140d1beb9.css","style"]
:HL["/_next/static/css/36a97ca7ae61047e.css","style"]
:HL["/_next/static/css/cb28a8db79c7a247.css","style"]
:HL["/_next/static/css/90e48aee015d076a.css","style"]
0:{"P":null,"b":"Z9yB1QKJUCFVUxF_8PaeN","p":"","c":["","posts","TypeScript%E4%B8%AD%E7%9A%84Infer%E4%B8%8ETemplateLiteral"],"i":false,"f":[[["",{"children":["posts",{"children":[["slug","TypeScript%E4%B8%AD%E7%9A%84Infer%E4%B8%8ETemplateLiteral","d"],{"children":["__PAGE__",{}]}]}]},"$undefined","$undefined",true],["",["$","$1","c",{"children":[[["$","link","0",{"rel":"stylesheet","href":"/_next/static/css/aa504e0140d1beb9.css","precedence":"next","crossOrigin":"$undefined","nonce":"$undefined"}]],["$","html",null,{"lang":"en","children":["$","body",null,{"className":"__variable_4d318d __variable_ea5f4b antialiased","children":["$","div",null,{"className":"min-h-screen","children":[["$","$L2",null,{}],["$","main",null,{"className":"p-6 flex justify-center","children":["$","$L3",null,{"parallelRouterKey":"children","error":"$4","errorStyles":[],"errorScripts":[],"template":["$","$L5",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":[["$","$L6",null,{}],[]],"forbidden":"$undefined","unauthorized":"$undefined"}]}],["$","footer",null,{"className":"bg-neutral-50 border-t border-neutral-200 text-center text-xs opacity-50 py-4","children":["© 2022 - ",2025,["$","a",null,{"rel":"noopener noreferrer","className":"hover:underline hover:bg-indigo","href":"https://github.com/LZS911","target":"_blank","children":", LZS_911"}],", build with"," ",["$","a",null,{"rel":"noopener noreferrer","className":"underline hover:bg-indigo","href":"https://nextjs.org/","target":"_blank","children":"Next.js"}]," ","and"," ",["$","a",null,{"rel":"noopener noreferrer","className":"underline hover:bg-indigo","href":"https://pages.github.com/?(null)","target":"_blank","children":"GitHub Pages"}]]}]]}]}]}]]}],{"children":["posts",["$","$1","c",{"children":[null,["$","$L3",null,{"parallelRouterKey":"children","error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L5",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","forbidden":"$undefined","unauthorized":"$undefined"}]]}],{"children":[["slug","TypeScript%E4%B8%AD%E7%9A%84Infer%E4%B8%8ETemplateLiteral","d"],["$","$1","c",{"children":[null,["$","$L3",null,{"parallelRouterKey":"children","error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L5",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","forbidden":"$undefined","unauthorized":"$undefined"}]]}],{"children":["__PAGE__",["$","$1","c",{"children":["$L7",["$","$L8",null,{"children":"$L9"}],[["$","link","0",{"rel":"stylesheet","href":"/_next/static/css/36a97ca7ae61047e.css","precedence":"next","crossOrigin":"$undefined","nonce":"$undefined"}],["$","link","1",{"rel":"stylesheet","href":"/_next/static/css/cb28a8db79c7a247.css","precedence":"next","crossOrigin":"$undefined","nonce":"$undefined"}],["$","link","2",{"rel":"stylesheet","href":"/_next/static/css/90e48aee015d076a.css","precedence":"next","crossOrigin":"$undefined","nonce":"$undefined"}]],["$","$La",null,{"children":["$Lb","$Lc",["$","$Ld",null,{"promise":"$@e"}]]}]]}],{},null,false]},null,false]},null,false]},[["$","$Lf","l",{}],[],[]],false],["$","$1","h",{"children":[null,["$","$1","EIz4ToRtmgpkI52KPdCwS",{"children":[["$","$L10",null,{"children":"$L11"}],["$","meta",null,{"name":"next-size-adjust","content":""}]]}],null]}],false]],"m":"$undefined","G":["$12","$undefined"],"s":false,"S":true}
13:"$Sreact.suspense"
14:I[4911,[],"AsyncMetadata"]
9:["$","$13",null,{"fallback":null,"children":["$","$L14",null,{"promise":"$@15"}]}]
c:null
17:I[3924,["766","static/chunks/766-45f65761a5dfbf2c.js","858","static/chunks/app/posts/%5Bslug%5D/page-032d0aa1acece2a1.js"],"default"]
16:T1e77,<h2 id="infer"><a aria-hidden="true" tabindex="-1" href="#infer"><span class="icon icon-link"></span></a>infer</h2>
<p>在介绍 infer 之前, 我们需要先了解一个前置知识点: extends, 也就是条件类型.</p>
<p>来自 Typescript 官网的介绍:</p>
<blockquote>
<p>大多数有效程序的核心是，我们必须依据输入做出一些决定。 JavaScript 程序也是如此，但是由于值可以很容易地被内省，这些决定也是基于输入的类型。 条件类型 有助于描述输入和输出类型之间的关系。</p>
</blockquote>
<pre><code class="hljs language-Typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Animal</span> {
  <span class="hljs-title function_">live</span>(): <span class="hljs-built_in">void</span>;
}
<span class="hljs-keyword">interface</span> <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span> {
  <span class="hljs-title function_">woof</span>(): <span class="hljs-built_in">void</span>;
}
 
<span class="hljs-keyword">type</span> <span class="hljs-title class_">Example1</span> = <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span> ? <span class="hljs-built_in">number</span> : <span class="hljs-built_in">string</span>;
        
<span class="hljs-comment">// type Example1 = number</span>
 
<span class="hljs-keyword">type</span> <span class="hljs-title class_">Example2</span> = <span class="hljs-title class_">RegExp</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span> ? <span class="hljs-built_in">number</span> : <span class="hljs-built_in">string</span>;
        
<span class="hljs-comment">// type Example2 = string</span>
</code></pre>
<p>可以看到 extends 的用法与 javascript 中的三元表达式没有太多的区别. 接下来, 回到文章的主题 --- infer 关键字.</p>
<p>首先, 我们先来实现一个工具类型: <em>判断接受的泛型是否为一个函数, 如果是, 则返回函数的返回值类型, 否则返回它自己</em></p>
<pre><code class="hljs language-Typescript"><span class="hljs-keyword">type</span> f1 = <span class="hljs-function">() =></span> <span class="hljs-built_in">void</span>;
<span class="hljs-keyword">type</span> f2 = <span class="hljs-function">(<span class="hljs-params"><span class="hljs-attr">arg</span>: <span class="hljs-built_in">string</span>, <span class="hljs-attr">arg2</span>: <span class="hljs-built_in">number</span></span>) =></span> <span class="hljs-built_in">number</span>;
<span class="hljs-keyword">type</span> f3 = <span class="hljs-function">(<span class="hljs-params"><span class="hljs-attr">arg</span>: <span class="hljs-built_in">number</span></span>) =></span> <span class="hljs-built_in">string</span>;
<span class="hljs-keyword">type</span> t4 = { <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span> };

<span class="hljs-keyword">type</span> <span class="hljs-title class_">Example1</span>&#x3C;T> = T <span class="hljs-title function_">extends</span> (<span class="hljs-function">(<span class="hljs-params">...<span class="hljs-attr">arg</span>: infer params</span>) =></span> infer <span class="hljs-title class_">ResultType</span>) ? <span class="hljs-title class_">ResultType</span> : T;
</code></pre>
<p><img src="/assets/infer_templateLiteral/example-1.png" alt="alt">
<img src="/assets/infer_templateLiteral/example-2.png" alt="alt">
<img src="/assets/infer_templateLiteral/example-3.png" alt="alt">
<img src="/assets/infer_templateLiteral/example-4.png" alt="alt"></p>
<p>在这里, 我们通过 infer 关键字引入了类型一个名为 ResultType 的新泛型类型变量, 或者可以理解为一个占位符, 当条件类型成立时, ResultType 会替换为满足条件类型时所需的类型, 在这个栗子中 ResultType 代表的是函数的返回类型, 也就完成了我们需要的工具类型.</p>
<p>同样, 我们也可以实现一个 <em>提取元组类型中最后一个元素的类型</em></p>
<pre><code class="hljs language-Typescript"><span class="hljs-keyword">type</span> lastArrType&#x3C;T <span class="hljs-keyword">extends</span> <span class="hljs-built_in">unknown</span>[]> = T <span class="hljs-keyword">extends</span> [
  ...infer rest,
  infer <span class="hljs-title class_">ResultType</span>
]
  ? <span class="hljs-title class_">ResultType</span>
  : <span class="hljs-built_in">never</span>;
</code></pre>
<p><img src="/assets/infer_templateLiteral/example-5.png" alt="alt"></p>
<h2 id="template-literal"><a aria-hidden="true" tabindex="-1" href="#template-literal"><span class="icon icon-link"></span></a>Template Literal</h2>
<p>我们先看下基础的字符串文字类型:</p>
<pre><code class="hljs language-Typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">Demo</span> = <span class="hljs-string">'demo'</span>;
</code></pre>
<p>模版文字类型是建立在字符串文字类型上的, 举个栗子</p>
<pre><code class="hljs language-Typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">Hello</span> = <span class="hljs-string">'hello'</span>;
<span class="hljs-keyword">type</span> <span class="hljs-title class_">HelloWorld</span> = <span class="hljs-string">`<span class="hljs-subst">${Hello}</span> world`</span>; <span class="hljs-comment">//type HelloWorld = "hello world"</span>
</code></pre>
<p>单从语法上来说, 也是和 javascript 中的模版字符串大同小异.</p>
<p>配合联合类型时, 会生成出每个联合成员可以表示的每个可能的字符串文字的集合.</p>
<pre><code class="hljs language-Typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">EmailLocaleIDs</span> = <span class="hljs-string">"welcome_email"</span> | <span class="hljs-string">"email_heading"</span>;
<span class="hljs-keyword">type</span> <span class="hljs-title class_">FooterLocaleIDs</span> = <span class="hljs-string">"footer_title"</span> | <span class="hljs-string">"footer_sendoff"</span>;
</code></pre>
<p><img src="/assets/infer_templateLiteral/example-6.png" alt="alt"></p>
<h2 id="实践"><a aria-hidden="true" tabindex="-1" href="#实践"><span class="icon icon-link"></span></a>实践</h2>
<p>结合 infer 以及 Template Literal 实现一个类似 <code>String.replace</code> 的工具类型</p>
<pre><code class="hljs language-Typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">ReplaceStr</span>&#x3C;
  <span class="hljs-title class_">Str</span> <span class="hljs-keyword">extends</span> <span class="hljs-built_in">string</span>,
  <span class="hljs-title class_">From</span> <span class="hljs-keyword">extends</span> <span class="hljs-built_in">string</span>,
  <span class="hljs-title class_">To</span> <span class="hljs-keyword">extends</span> <span class="hljs-built_in">string</span>
> = <span class="hljs-title class_">Str</span> <span class="hljs-keyword">extends</span> <span class="hljs-string">`<span class="hljs-subst">${infer Prefix}</span><span class="hljs-subst">${From}</span><span class="hljs-subst">${infer Suffix}</span>`</span>
  ? <span class="hljs-string">`<span class="hljs-subst">${Prefix}</span><span class="hljs-subst">${To}</span><span class="hljs-subst">${Suffix}</span>`</span>
  : <span class="hljs-title class_">Str</span>;
</code></pre>
<p><img src="/assets/infer_templateLiteral/example-7.png" alt="alt"></p>
<p>对更多实践感兴趣的可以转到: <a href="https://lzs911.github.io/posts/Typescript%20%E4%BD%93%E6%93%8D%E7%BB%83%E4%B9%A0">https://lzs911.github.io/posts/Typescript%20%E4%BD%93%E6%93%8D%E7%BB%83%E4%B9%A0</a></p>7:["$","article",null,{"children":[["$","div",null,{"className":"flex justify-center font-[Arial] max-w-[864px] text-center","children":["$","h1",null,{"className":"text-[2.5rem] font-bold bg-lime-300 px-5 py-2 rounded-sm text-shadow-lg leading-[1.1]","children":"TypeScript中的 infer 与 TemplateLiteral"}]}],["$","time",null,{"dateTime":"2022-11-21","className":"text-center block my-4 text-sm opacity-60","children":"November\t21, 2022"}],[null,["$","section",null,{"className":"markdown-body-fancy max-w-3xl","dangerouslySetInnerHTML":{"__html":"$16"}}]],["$","$L17",null,{"slug":"TypeScript%E4%B8%AD%E7%9A%84Infer%E4%B8%8ETemplateLiteral"}]]}]
11:[["$","meta","0",{"charSet":"utf-8"}],["$","meta","1",{"name":"viewport","content":"width=device-width, initial-scale=1"}]]
b:null
15:{"metadata":[["$","title","0",{"children":"Ai.Haibara codes"}],["$","meta","1",{"name":"description","content":"LZS Blog"}],["$","link","2",{"rel":"icon","href":"/favicon.ico","type":"image/x-icon","sizes":"96x96"}]],"error":null,"digest":"$undefined"}
e:{"metadata":"$15:metadata","error":null,"digest":"$undefined"}
