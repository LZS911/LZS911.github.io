1:"$Sreact.fragment"
2:I[7555,[],""]
3:I[1901,["874","static/chunks/874-90f68e0a3827b559.js","39","static/chunks/app/error-d036ecfd03716e30.js"],"default"]
4:I[1295,[],""]
5:I[9543,["874","static/chunks/874-90f68e0a3827b559.js","345","static/chunks/app/not-found-2113bbd7a2f55e8f.js"],"default"]
8:I[9665,[],"MetadataBoundary"]
a:I[9665,[],"OutletBoundary"]
d:I[4911,[],"AsyncMetadataOutlet"]
f:I[8460,["209","static/chunks/app/loading-b73dd9bd22c3caa2.js"],"default"]
10:I[9665,[],"ViewportBoundary"]
12:I[6614,[],""]
:HL["/_next/static/media/569ce4b8f30dc480-s.p.woff2","font",{"crossOrigin":"","type":"font/woff2"}]
:HL["/_next/static/media/93f479601ee12b01-s.p.woff2","font",{"crossOrigin":"","type":"font/woff2"}]
:HL["/_next/static/css/afd685b2833157f9.css","style"]
0:{"P":null,"b":"F63JTs1PA5XvAzvJlmBBT","p":"","c":["","posts","rust-like-match-typescript"],"i":false,"f":[[["",{"children":["(article)",{"children":["posts",{"children":[["slug","rust-like-match-typescript","d"],{"children":["__PAGE__",{}]}]}]}]},"$undefined","$undefined",true],["",["$","$1","c",{"children":[[["$","link","0",{"rel":"stylesheet","href":"/_next/static/css/afd685b2833157f9.css","precedence":"next","crossOrigin":"$undefined","nonce":"$undefined"}]],["$","html",null,{"lang":"en","children":["$","body",null,{"className":"__variable_5cfdac __variable_9a8899 antialiased","children":["$","$L2",null,{"parallelRouterKey":"children","error":"$3","errorStyles":[],"errorScripts":[],"template":["$","$L4",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":[["$","$L5",null,{}],[]],"forbidden":"$undefined","unauthorized":"$undefined"}]}]}]]}],{"children":["(article)",["$","$1","c",{"children":[null,"$L6"]}],{"children":["posts",["$","$1","c",{"children":[null,["$","$L2",null,{"parallelRouterKey":"children","error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L4",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","forbidden":"$undefined","unauthorized":"$undefined"}]]}],{"children":[["slug","rust-like-match-typescript","d"],["$","$1","c",{"children":[null,["$","$L2",null,{"parallelRouterKey":"children","error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L4",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","forbidden":"$undefined","unauthorized":"$undefined"}]]}],{"children":["__PAGE__",["$","$1","c",{"children":["$L7",["$","$L8",null,{"children":"$L9"}],null,["$","$La",null,{"children":["$Lb","$Lc",["$","$Ld",null,{"promise":"$@e"}]]}]]}],{},null,false]},null,false]},null,false]},null,false]},[["$","$Lf","l",{}],[],[]],false],["$","$1","h",{"children":[null,["$","$1","L1yE4i7Dj08z0heJ3mMFP",{"children":[["$","$L10",null,{"children":"$L11"}],["$","meta",null,{"name":"next-size-adjust","content":""}]]}],null]}],false]],"m":"$undefined","G":["$12","$undefined"],"s":false,"S":true}
13:I[4467,["874","static/chunks/874-90f68e0a3827b559.js","766","static/chunks/766-dfd76e5b111fda64.js","651","static/chunks/app/(article)/layout-120a8801c6045af4.js"],"default"]
14:"$Sreact.suspense"
15:I[4911,[],"AsyncMetadata"]
6:["$","html",null,{"lang":"en","children":["$","body",null,{"className":"__variable_5cfdac __variable_9a8899 antialiased","children":[["$","div",null,{"className":"min-h-screen","children":[["$","$L13",null,{}],["$","main",null,{"className":"p-6 flex justify-center","children":["$","$L2",null,{"parallelRouterKey":"children","error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L4",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","forbidden":"$undefined","unauthorized":"$undefined"}]}],["$","footer",null,{"className":"bg-neutral-50 border-t border-neutral-200 text-center text-xs opacity-50 py-4","children":["© 2022 - ",2025,["$","a",null,{"rel":"noopener noreferrer","className":"hover:underline hover:bg-indigo","href":"https://github.com/LZS911","target":"_blank","children":", LZS_911"}],", build with"," ",["$","a",null,{"rel":"noopener noreferrer","className":"underline hover:bg-indigo","href":"https://nextjs.org/","target":"_blank","children":"Next.js"}]," ","and"," ",["$","a",null,{"rel":"noopener noreferrer","className":"underline hover:bg-indigo","href":"https://pages.github.com/?(null)","target":"_blank","children":"GitHub Pages"}]]}]]}],false]}]}]
9:["$","$14",null,{"fallback":null,"children":["$","$L15",null,{"promise":"$@16"}]}]
c:null
17:I[5099,["766","static/chunks/766-dfd76e5b111fda64.js","62","static/chunks/62-abd5adcc4de2f71a.js","520","static/chunks/app/(article)/posts/%5Bslug%5D/page-3df7d22b1edb27cc.js"],"ThemeLoader"]
18:T809a,<h2 id="简介"><a aria-hidden="true" tabindex="-1" href="#简介"><span class="icon icon-link"></span></a>简介</h2>
<p><code>rust-like-match</code> 提供了在 javascript 或 typescript 中使用 <code>Rust-Like</code> 的模式匹配. 并且在 typescript 环境下, <code>rust-like-match</code> 能够利用类型校验来实现 rust 中 <code>match</code> 的穷尽匹配以及提供优秀的类型提示.</p>
<h2 id="什么是-rust-like-的模式匹配"><a aria-hidden="true" tabindex="-1" href="#什么是-rust-like-的模式匹配"><span class="icon icon-link"></span></a>什么是 <code>Rust-Like</code> 的模式匹配?</h2>
<p>在说到模式匹配之前, 我们先来看下 rust 中的枚举功能.</p>
<pre><code class="hljs language-rust"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Message</span> {
    Quit,
    Move { x: <span class="hljs-type">i32</span>, y: <span class="hljs-type">i32</span> },
    <span class="hljs-title function_ invoke__">Write</span>(<span class="hljs-type">String</span>),
    <span class="hljs-title function_ invoke__">ChangeColor</span>(<span class="hljs-type">i32</span>, <span class="hljs-type">i32</span>, <span class="hljs-type">i32</span>),
}
</code></pre>
<p>这里定义了一个名为 <code>Message</code> 的枚举类型, 包含了四个成员. 成员后的 <code>{}</code> 或者 <code>()</code> 代表着可以将什么类型的数据附加到该枚举成员上.</p>
<p>初始化枚举成员:</p>
<pre><code class="hljs language-rust"> <span class="hljs-keyword">let</span> <span class="hljs-variable">msg1</span> = Message::Quit;
 <span class="hljs-keyword">let</span> <span class="hljs-variable">msg2</span> = Message::Move { x: <span class="hljs-number">10</span>, y: <span class="hljs-number">20</span> };
 <span class="hljs-keyword">let</span> <span class="hljs-variable">msg3</span> = Message::<span class="hljs-title function_ invoke__">Write</span>(<span class="hljs-string">"hello rust"</span>.<span class="hljs-title function_ invoke__">to_string</span>());
 <span class="hljs-keyword">let</span> <span class="hljs-variable">mgs3</span> = Message::<span class="hljs-title function_ invoke__">ChangeColor</span>(<span class="hljs-number">255</span>, <span class="hljs-number">255</span>, <span class="hljs-number">255</span>);
</code></pre>
<p>接下来回到主题, 来看下 rust 中的 <code>match</code> 关键字.</p>
<pre><code class="hljs language-rust"> <span class="hljs-keyword">match</span> msg1 {
   Message::Quit => <span class="hljs-title function_ invoke__">quit</span>(),
   Message::Move { x, y } => <span class="hljs-title function_ invoke__">move_item</span>(x, y),
   Message::<span class="hljs-title function_ invoke__">Write</span>(msg) => <span class="hljs-built_in">println!</span>(<span class="hljs-string">"{}"</span>, msg),
   Message::<span class="hljs-title function_ invoke__">ChangeColor</span>(r, g, b) => <span class="hljs-title function_ invoke__">change_color</span>(r, g, b),
 }
</code></pre>
<p><code>match</code> 关键字后跟一个表达式, 在这个栗子中是变量 <code>msg1</code> 的值. 接下来是一对大括号, 里面包含了 <code>match</code> 的分支. 一个分支由两部分组成: 一个模式和一些代码. 第一个分支的模式是枚举成员 <code>Message::Quit</code>, 之后的 <code>=></code> 运算符将模式和需要执行的代码分开, 这里的代码是执行函数 <code>quit</code>. 同时, 在匹配上附加了额外数据的枚举成员时, 可以将其作为参数传递给后续需要执行的代码. 这里的代码结构有点类型 javascript 中的箭头函数.</p>
<p><code>match</code> 也支持通配模式:</p>
<pre><code class="hljs language-rust"> <span class="hljs-keyword">match</span> msg1 {
   Message::Quit => <span class="hljs-title function_ invoke__">quit</span>(),
   _ => <span class="hljs-title function_ invoke__">other</span>()
 }
</code></pre>
<p>上述代码中当匹配上 <code>Message::Quit</code> 之外的成员时, 都将执行 <code>other</code> 函数, 其中 <code>_</code> 为 rust 特定的占位符.</p>
<h2 id="typescript-中的模式匹配"><a aria-hidden="true" tabindex="-1" href="#typescript-中的模式匹配"><span class="icon icon-link"></span></a>Typescript 中的模式匹配</h2>
<p>接下来我们使用 <code>switch</code> 来模仿下 <code>match</code>:</p>
<pre><code class="hljs language-typescript">
<span class="hljs-keyword">type</span> <span class="hljs-title class_">Message</span> =
  | {
      <span class="hljs-attr">key</span>: <span class="hljs-string">'Quit'</span>;
    }
  | { <span class="hljs-attr">key</span>: <span class="hljs-string">'Move'</span>; <span class="hljs-attr">value</span>: { <span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span>; <span class="hljs-attr">y</span>: <span class="hljs-built_in">number</span> } }
  | { <span class="hljs-attr">key</span>: <span class="hljs-string">'Write'</span>; <span class="hljs-attr">message</span>: <span class="hljs-built_in">string</span> }
  | { <span class="hljs-attr">key</span>: <span class="hljs-string">'ChangeColor'</span>; <span class="hljs-attr">r</span>: <span class="hljs-built_in">number</span>; <span class="hljs-attr">g</span>: <span class="hljs-built_in">number</span>; <span class="hljs-attr">b</span>: <span class="hljs-built_in">number</span> };



<span class="hljs-keyword">let</span> msg!: <span class="hljs-title class_">Message</span>;

<span class="hljs-keyword">switch</span> (msg.<span class="hljs-property">key</span>) {
  <span class="hljs-keyword">case</span> <span class="hljs-string">'Quit'</span>: {
    <span class="hljs-title function_">quit</span>();
    <span class="hljs-keyword">break</span>;
  }
  <span class="hljs-keyword">case</span> <span class="hljs-string">'Move'</span>: {
    <span class="hljs-title function_">move</span>(msg.<span class="hljs-property">value</span>);
    <span class="hljs-keyword">break</span>;
  }
  <span class="hljs-keyword">case</span> <span class="hljs-string">'Write'</span>: {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(msg.<span class="hljs-property">message</span>);
    <span class="hljs-keyword">break</span>;
  }

  <span class="hljs-keyword">case</span> <span class="hljs-string">'ChangeColor'</span>: {
    <span class="hljs-title function_">change_color</span>(msg.<span class="hljs-property">r</span>, msg.<span class="hljs-property">g</span>, msg.<span class="hljs-property">b</span>);
    <span class="hljs-keyword">break</span>;
  }
}
</code></pre>
<h2 id="match-的优势"><a aria-hidden="true" tabindex="-1" href="#match-的优势"><span class="icon icon-link"></span></a>Match 的优势</h2>
<p>在我看来, <code>match</code> 主要的优势有以下三点:</p>
<ol>
<li><strong>当 <code>match</code> 中没有使用通配模式时, 其中的分支必须覆盖了所有的可能性, 否则编译将不会通过</strong>.</li>
<li><code>switch</code> 是一个语句, 而不是一个表达式, 无法使用类似 <code>const value = switch(...){...}</code> 的操作, 只能在每一个 <code>case</code> 里面去执行赋值语句, 而 <code>match</code> 为一个表达式, 其返回值为分支中执行的代码的返回值.</li>
<li>优秀的多模式匹配机制. <code>switch</code> 中的多模式匹配需要移除 <code>case</code> 中的 <code>break</code> 语句, 也就是说对于每一个独立 <code>case</code> 都需要在尾部添加 <code>break</code> 语句, 但也容易因为 <code>break</code> 的丢失导致出现一些“误会”. 而 <code>match</code> 中的多模式采用类似 <code>Message::Quit | Message::Start => doSomething()</code> 的语法, 且每一个独立的分支不需要添加任何额外的语句.</li>
</ol>
<h2 id="使用方式"><a aria-hidden="true" tabindex="-1" href="#使用方式"><span class="icon icon-link"></span></a>使用方式</h2>
<p>在了解了 <code>match</code> 的具体语法以及优势后, 我们回到主题 <code>rust-like-match</code> 中, 我们首先来看下具体的使用方式:</p>
<ol>
<li>
<p>初始化</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">import</span> { defineMatchObject, none } <span class="hljs-keyword">from</span> <span class="hljs-string">"rust-like-match"</span>;

<span class="hljs-keyword">const</span> <span class="hljs-title class_">Message</span> = <span class="hljs-title function_">defineMatchObject</span>({
  <span class="hljs-title class_">Quit</span>: none,
  <span class="hljs-title class_">Move</span>: <span class="hljs-function">(<span class="hljs-params"><span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span>, <span class="hljs-attr">y</span>: <span class="hljs-built_in">number</span></span>) =></span> ({ x, y }),
  <span class="hljs-title class_">Write</span>: <span class="hljs-function">(<span class="hljs-params"><span class="hljs-attr">msg</span>: <span class="hljs-built_in">string</span></span>) =></span> msg,
  <span class="hljs-title class_">ChangeColor</span>: <span class="hljs-function">(<span class="hljs-params"><span class="hljs-attr">r</span>: <span class="hljs-built_in">number</span>, <span class="hljs-attr">g</span>: <span class="hljs-built_in">number</span>, <span class="hljs-attr">b</span>: <span class="hljs-built_in">number</span></span>) =></span> ({ r, g, b }),
});
<span class="hljs-comment">//or</span>
<span class="hljs-keyword">const</span> obj = {
  <span class="hljs-title class_">Quit</span>: none,
  <span class="hljs-title class_">Move</span>: <span class="hljs-function">(<span class="hljs-params"><span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span>, <span class="hljs-attr">y</span>: <span class="hljs-built_in">number</span></span>) =></span> ({ x, y }),
  <span class="hljs-title class_">Write</span>: <span class="hljs-function">(<span class="hljs-params"><span class="hljs-attr">msg</span>: <span class="hljs-built_in">string</span></span>) =></span> msg,
  <span class="hljs-title class_">ChangeColor</span>: <span class="hljs-function">(<span class="hljs-params"><span class="hljs-attr">r</span>: <span class="hljs-built_in">number</span>, <span class="hljs-attr">g</span>: <span class="hljs-built_in">number</span>, <span class="hljs-attr">b</span>: <span class="hljs-built_in">number</span></span>) =></span> ({ r, g, b }),
} <span class="hljs-keyword">as</span> <span class="hljs-keyword">const</span>;
<span class="hljs-keyword">const</span> <span class="hljs-title class_">Message</span> = <span class="hljs-title function_">defineMatchObject</span>(msg);
</code></pre>
<p>首先从 <code>rust-like-match</code> 中导出函数 <code>defineMatchObject</code> 以及变量 <code>none</code>. 由于 typescript 中已经存在 <code>enum</code> 的概念. 所以, 这里将初始化过程命名为 <strong>定义一个具有Match功能的对象</strong>, 也就是 <code>defineMatchObject</code>. 该函数接收一个字面量类型的对象, <code>key</code> 值对应 <code>rust</code> 中的枚举成员名, <code>value</code> 值的类型为 <code>None (typeof none)</code> 或者为一个函数. <code>None</code> 的情况对应着未给枚举成员附加额外数据, 相应的, 值为函数即代表着附加额外数据的情况.</p>
</li>
<li>
<p>赋值</p>
<p>我们来看下得到的 <code>Message</code> 的具体格式:</p>
<p><img src="/assets/rust-like-match/example-1.png" alt="alt"></p>
<p><img src="/assets/rust-like-match/example-2.png" alt="alt"></p>
<p><img src="/assets/rust-like-match/example-3.png" alt="alt"></p>
<p><img src="/assets/rust-like-match/example-4.png" alt="alt"></p>
<p>可以看到, 当初始值为 <code>none</code> 时, <code>Message</code> 的成员值(<code>Quit</code>)为一个拥有 <code>match</code> 属性的对象. 当初始值为函数时, <code>Message</code> 的成员值同样也是一个函数, 且该函数的入参类型与初始的函数入参类型一致. 该函数的返回值为一个拥有 <code>match</code> 属性的对象.</p>
<p>所以我们这样来进行赋值:</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">let</span> msg;

msg = <span class="hljs-title class_">Message</span>.<span class="hljs-property">Quit</span>;
<span class="hljs-comment">//or</span>
msg = <span class="hljs-title class_">Message</span>.<span class="hljs-title class_">Move</span>(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>);
<span class="hljs-comment">//or</span>
msg = <span class="hljs-title class_">Message</span>.<span class="hljs-title class_">Write</span>(<span class="hljs-string">"hello rust"</span>);
<span class="hljs-comment">//or</span>
msg = <span class="hljs-title class_">Message</span>.<span class="hljs-title class_">ChangeColor</span>(<span class="hljs-number">255</span>, <span class="hljs-number">255</span>, <span class="hljs-number">255</span>);
</code></pre>
</li>
<li>
<p>匹配</p>
<p><code>match</code> 函数接收一个对象作为参数, 对象的每一个 <code>key:value</code> 对应着一条分支, <code>key</code> 值为一个模式, 必须满足穷尽模式或者使用通配模式, <code>value</code> 为一个函数, 该函数能够接收到 <code>defineMatchObject</code> 时定义的函数的返回值, 并将其作为参数. 函数体为分支匹配上后执行的代码.</p>
<p>接下来主要介绍在 typescript 环境下其拥有的一些特性:</p>
<ol>
<li>
<p>支持通配模式, 当分支中存在 <code>_</code> 时, 此分支涵盖了其他可能的值, 且无需满足全匹配.</p>
<pre><code class="hljs language-typescript"> msg.<span class="hljs-title function_">match</span>({
   <span class="hljs-title class_">Quit</span>:<span class="hljs-function">() =></span> <span class="hljs-title function_">quit</span>(),
   _ :<span class="hljs-function">() =></span> <span class="hljs-title function_">other</span>(),
 })
</code></pre>
</li>
<li>
<p>穷尽匹配: 当分支中不存在 <code>_</code> 时, 分支必须覆盖所有的情况, 否则 <code>typescript</code> 将编译失败.</p>
<pre><code class="hljs language-typescript"> msg.<span class="hljs-title function_">match</span>({
   <span class="hljs-title class_">Quit</span>: <span class="hljs-function">() =></span> <span class="hljs-title function_">quit</span>(),
   <span class="hljs-title class_">Move</span>: <span class="hljs-function">(<span class="hljs-params">{ x, y }</span>) =></span> <span class="hljs-title function_">move</span>(x, y),
   <span class="hljs-title class_">Write</span>: <span class="hljs-function">(<span class="hljs-params">msg</span>) =></span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(msg),
   <span class="hljs-title class_">ChangeColor</span>: <span class="hljs-function">(<span class="hljs-params">{ r, g, b }</span>) =></span> <span class="hljs-title function_">changeColor</span>(r, g, b),
 });
</code></pre>
</li>
<li>
<p>参数类型自动推导. 每个分支中的函数的入参类型为定义时函数的返回类型.</p>
</li>
<li>
<p>支持泛型.</p>
</li>
</ol>
<pre><code class="hljs language-typescript">  <span class="hljs-comment">//此时 res 类型将自动推导为 number</span>
  <span class="hljs-keyword">const</span> res = msg.<span class="hljs-title function_">match</span>({
    <span class="hljs-title class_">Quit</span>: <span class="hljs-function">() =></span> <span class="hljs-number">1</span>,
    <span class="hljs-title class_">Move</span>: <span class="hljs-function">(<span class="hljs-params">{ x, y }</span>) =></span> <span class="hljs-number">2</span>,
    <span class="hljs-title class_">Write</span>: <span class="hljs-function">(<span class="hljs-params">msg</span>) =></span> <span class="hljs-number">3</span>,
    <span class="hljs-title class_">ChangeColor</span>: <span class="hljs-function">(<span class="hljs-params">{ r, g, b }</span>) =></span> <span class="hljs-number">4</span>,
  });

 <span class="hljs-comment">//由于未标注泛型, 且存在分支的返回类型不一致, 此时 typescript 将会报错</span>
 <span class="hljs-keyword">const</span> res = msg.<span class="hljs-title function_">match</span>({
    <span class="hljs-title class_">Quit</span>: <span class="hljs-function">() =></span> <span class="hljs-number">1</span>,
    <span class="hljs-title class_">Move</span>: <span class="hljs-function">(<span class="hljs-params">{ x, y }</span>) =></span> <span class="hljs-string">'2'</span>,
    <span class="hljs-title class_">Write</span>: <span class="hljs-function">(<span class="hljs-params">msg</span>) =></span> <span class="hljs-number">3</span>,
    <span class="hljs-title class_">ChangeColor</span>: <span class="hljs-function">(<span class="hljs-params">{ r, g, b }</span>) =></span> <span class="hljs-number">4</span>,
  });

 <span class="hljs-comment">//res 的类型为 string | number | boolean | Array&#x3C;number></span>
 <span class="hljs-keyword">const</span> res = msg.<span class="hljs-property">match</span>&#x3C;<span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span> | <span class="hljs-built_in">boolean</span> | <span class="hljs-title class_">Array</span>&#x3C;<span class="hljs-built_in">number</span>>>({
    <span class="hljs-title class_">Quit</span>: <span class="hljs-function">() =></span> <span class="hljs-number">1</span>,
    <span class="hljs-title class_">Move</span>: <span class="hljs-function">(<span class="hljs-params">{ x, y }</span>) =></span> [x, y],
    <span class="hljs-title class_">Write</span>: <span class="hljs-function">(<span class="hljs-params">msg</span>) =></span> <span class="hljs-literal">false</span>,
    <span class="hljs-title class_">ChangeColor</span>: <span class="hljs-function">(<span class="hljs-params">{ r, g, b }</span>) =></span> <span class="hljs-string">`<span class="hljs-subst">${r}</span>-<span class="hljs-subst">${g}</span>-<span class="hljs-subst">${b}</span>`</span>,
  });
</code></pre>
</li>
</ol>
<h2 id="拓展"><a aria-hidden="true" tabindex="-1" href="#拓展"><span class="icon icon-link"></span></a>拓展</h2>
<ol>
<li>
<p>在 React 项目中, 怎样在能保证支持类型校验的同时将其设置为一个 <code>state</code>?</p>
<p><code>rust-like-match</code> 现支持导出类型 <code>MatchObjectType</code>. 具体使用方式如下:</p>
<pre><code class="hljs language-tsx"> <span class="hljs-keyword">import</span> { defineMatchObject, none, <span class="hljs-title class_">MatchObjectType</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'rust-like-match'</span>;

 <span class="hljs-keyword">const</span> statusEnum = {
    <span class="hljs-title class_">Loading</span>: none,
    <span class="hljs-title class_">Success</span>: <span class="hljs-function">(<span class="hljs-params"><span class="hljs-attr">data</span>?: <span class="hljs-title class_">Item</span></span>) =></span> data,
    <span class="hljs-title class_">Error</span>: <span class="hljs-function">(<span class="hljs-params"><span class="hljs-attr">err</span>: <span class="hljs-built_in">string</span></span>) =></span> <span class="hljs-title class_">Error</span>,
 } <span class="hljs-keyword">as</span> <span class="hljs-keyword">const</span>;

 <span class="hljs-keyword">const</span> <span class="hljs-title class_">RequestStatus</span> = <span class="hljs-title function_">defineMatchObject</span>(statusEnum);

 <span class="hljs-keyword">const</span> [status, setStatus] = useState&#x3C;<span class="hljs-title class_">MatchObjectType</span>&#x3C;<span class="hljs-keyword">typeof</span> statusEnum>>();

 <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =></span> {
   <span class="hljs-title function_">setStatus</span>(<span class="hljs-title class_">RequestStatus</span>.<span class="hljs-property">Loading</span>);
   api
     .<span class="hljs-title function_">getData</span>()
     .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">res</span>) =></span> {
       <span class="hljs-keyword">if</span> (res.<span class="hljs-property">data</span>.<span class="hljs-property">code</span> === <span class="hljs-title class_">ResponseCode</span>.<span class="hljs-property">SUCCESS</span>) {
         <span class="hljs-title function_">setStatus</span>(<span class="hljs-title class_">RequestStatus</span>.<span class="hljs-title class_">Success</span>(res.<span class="hljs-property">data</span>.<span class="hljs-property">data</span>));
       }
     })
     .<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">err</span>) =></span> {
       <span class="hljs-title function_">setStatus</span>(
         <span class="hljs-title class_">RequestStatus</span>.<span class="hljs-title class_">Error</span>(err?.<span class="hljs-title function_">toString</span>() ?? <span class="hljs-string">"unknown error"</span>)
       );
     });
 }, []);


 <span class="hljs-keyword">return</span> (
   <span class="hljs-comment">//...</span>
   {
     status?.<span class="hljs-title function_">match</span>({
       <span class="hljs-title class_">Loading</span>: <span class="hljs-function">() =></span> <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">Spin</span> /></span></span>,
       <span class="hljs-title class_">Success</span>: <span class="hljs-function">(<span class="hljs-params">data</span>) =></span> <span class="hljs-title function_">renderData</span>(data),
       <span class="hljs-title class_">Error</span>: <span class="hljs-function">(<span class="hljs-params">err</span>) =></span> <span class="hljs-title function_">renderError</span>(err)
     })
   }
   <span class="hljs-comment">//...</span>
 )
</code></pre>
</li>
<li>
<p>新增函数 <code>baseTypeMatch</code>, 支持对基础类型数据进行模式匹配. 具体使用方式如下:</p>
<ol>
<li>
<p>number 类型</p>
<pre><code class="hljs language-typescript">  <span class="hljs-keyword">const</span> value1 = <span class="hljs-title function_">baseTypeMatch</span>(<span class="hljs-number">1</span>, {
    <span class="hljs-comment">//val type is 1</span>
    <span class="hljs-number">1</span>: <span class="hljs-function">(<span class="hljs-params">val</span>) =></span> val + <span class="hljs-number">2</span>,
    <span class="hljs-number">2</span>: <span class="hljs-function">(<span class="hljs-params">val</span>) =></span> val + <span class="hljs-number">3</span>,
    <span class="hljs-attr">_</span>: <span class="hljs-function">(<span class="hljs-params">val</span>) =></span> val,
  });
  <span class="hljs-title function_">expect</span>(value1).<span class="hljs-title function_">toBe</span>(<span class="hljs-number">3</span>);

  <span class="hljs-keyword">const</span> value2 = <span class="hljs-title function_">baseTypeMatch</span>(value1, {
    <span class="hljs-comment">//val type is number</span>
    <span class="hljs-number">1</span>: <span class="hljs-function">(<span class="hljs-params">val</span>) =></span> val + <span class="hljs-number">2</span>,
    <span class="hljs-number">2</span>: <span class="hljs-function">(<span class="hljs-params">val</span>) =></span> val + <span class="hljs-number">3</span>,
    <span class="hljs-string">'3 | 4'</span>: <span class="hljs-function">(<span class="hljs-params">val</span>) =></span> val + <span class="hljs-number">1</span>,
    <span class="hljs-attr">_</span>: <span class="hljs-function">(<span class="hljs-params">val</span>) =></span> val,
  });

  <span class="hljs-title function_">expect</span>(value2).<span class="hljs-title function_">toBe</span>(<span class="hljs-number">4</span>);

  <span class="hljs-keyword">const</span> <span class="hljs-attr">cases</span>: <span class="hljs-title class_">BaseTypeMatchPatternType</span>&#x3C;<span class="hljs-built_in">number</span>, <span class="hljs-built_in">number</span>> = {
    <span class="hljs-string">'1 | 2'</span>: <span class="hljs-function">(<span class="hljs-params">val</span>) =></span> val + <span class="hljs-number">1</span>,
    <span class="hljs-number">3</span>: <span class="hljs-function">(<span class="hljs-params">val</span>) =></span> val + <span class="hljs-number">1</span>,
    <span class="hljs-attr">_</span>: <span class="hljs-function">(<span class="hljs-params">val</span>) =></span> val + <span class="hljs-number">1</span>,
  };
  <span class="hljs-keyword">const</span> value3 = <span class="hljs-title function_">baseTypeMatch</span>(value2, cases);
  <span class="hljs-title function_">expect</span>(value3).<span class="hljs-title function_">toBe</span>(<span class="hljs-number">5</span>);
</code></pre>
</li>
<li>
<p>string 类型</p>
<pre><code class="hljs language-typescript"> <span class="hljs-keyword">const</span> value1 = <span class="hljs-title function_">baseTypeMatch</span>(<span class="hljs-string">'foo'</span>, {
  <span class="hljs-comment">//val type is foo</span>
  <span class="hljs-attr">foo</span>: <span class="hljs-function">(<span class="hljs-params">val</span>) =></span> val + <span class="hljs-number">2</span>,
  <span class="hljs-attr">bar</span>: <span class="hljs-function">(<span class="hljs-params">val</span>) =></span> val + <span class="hljs-number">3</span>,
  <span class="hljs-attr">_</span>: <span class="hljs-function">(<span class="hljs-params">val</span>) =></span> val,
  });

  <span class="hljs-title function_">expect</span>(value1).<span class="hljs-title function_">toBe</span>(<span class="hljs-string">'foo2'</span>);

  <span class="hljs-keyword">const</span> value2 = <span class="hljs-title function_">baseTypeMatch</span>(value1, {
    <span class="hljs-comment">//val type is string</span>
    <span class="hljs-attr">foo</span>: <span class="hljs-function">(<span class="hljs-params">val</span>) =></span> val + <span class="hljs-number">2</span>,
    <span class="hljs-attr">bar</span>: <span class="hljs-function">(<span class="hljs-params">val</span>) =></span> val + <span class="hljs-number">3</span>,
    <span class="hljs-string">'foo2 | foo1'</span>: <span class="hljs-function">(<span class="hljs-params">val</span>) =></span> val + <span class="hljs-number">1</span>,
    <span class="hljs-attr">_</span>: <span class="hljs-function">(<span class="hljs-params">val</span>) =></span> val,
  });

  <span class="hljs-title function_">expect</span>(value2).<span class="hljs-title function_">toBe</span>(<span class="hljs-string">'foo21'</span>);

  <span class="hljs-keyword">const</span> <span class="hljs-attr">cases</span>: <span class="hljs-title class_">BaseTypeMatchPatternType</span>&#x3C;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">string</span>> = {
    <span class="hljs-string">'1 | 2'</span>: <span class="hljs-function">(<span class="hljs-params">val</span>) =></span> val + <span class="hljs-number">1</span>,
    <span class="hljs-attr">bar</span>: <span class="hljs-function">(<span class="hljs-params">val</span>) =></span> val + <span class="hljs-number">1</span>,
    <span class="hljs-attr">_</span>: <span class="hljs-function">(<span class="hljs-params">val</span>) =></span> val + <span class="hljs-number">1</span>,
  };
  <span class="hljs-keyword">const</span> value3 = <span class="hljs-title function_">baseTypeMatch</span>(value2, cases);
  <span class="hljs-title function_">expect</span>(value3).<span class="hljs-title function_">toBe</span>(<span class="hljs-string">'foo211'</span>);
</code></pre>
</li>
<li>
<p>boolean 类型</p>
<pre><code class="hljs language-typescript">   <span class="hljs-keyword">const</span> value1 = baseTypeMatch&#x3C;<span class="hljs-built_in">number</span>>(<span class="hljs-literal">false</span>, {
     <span class="hljs-comment">//val type is false</span>
      <span class="hljs-attr">false</span>: <span class="hljs-function">(<span class="hljs-params">val</span>) =></span> (val ? <span class="hljs-number">1</span> : <span class="hljs-number">2</span>),
      <span class="hljs-attr">true</span>: <span class="hljs-function">(<span class="hljs-params">val</span>) =></span> (val ? <span class="hljs-number">1</span> : <span class="hljs-number">2</span>),
    });

    <span class="hljs-title function_">expect</span>(value1).<span class="hljs-title function_">toBe</span>(<span class="hljs-number">2</span>);

    <span class="hljs-keyword">const</span> value2 = <span class="hljs-title function_">baseTypeMatch</span>(value1, {
      <span class="hljs-comment">//val type is number</span>
      <span class="hljs-number">2</span>: <span class="hljs-function">(<span class="hljs-params">val</span>) =></span> <span class="hljs-literal">true</span>,
      <span class="hljs-attr">_</span>: <span class="hljs-function">(<span class="hljs-params">val</span>) =></span> <span class="hljs-literal">false</span>,
    });

    <span class="hljs-title function_">expect</span>(value2).<span class="hljs-title function_">toBeTruthy</span>();

    <span class="hljs-keyword">const</span> <span class="hljs-attr">cases</span>: <span class="hljs-title class_">BaseTypeMatchPatternType</span>&#x3C;<span class="hljs-built_in">boolean</span>, <span class="hljs-built_in">string</span>> = {
      <span class="hljs-string">'true | false'</span>: <span class="hljs-function">(<span class="hljs-params">val</span>) =></span> <span class="hljs-string">'hello'</span>,
      <span class="hljs-attr">bar</span>: <span class="hljs-function">(<span class="hljs-params">val</span>) =></span> <span class="hljs-string">'rust'</span>,
      <span class="hljs-attr">_</span>: <span class="hljs-function">(<span class="hljs-params">val</span>) =></span> <span class="hljs-string">'javascript'</span>,
    };
    <span class="hljs-keyword">const</span> value3 = <span class="hljs-title function_">baseTypeMatch</span>(value2, cases);
    <span class="hljs-title function_">expect</span>(value3).<span class="hljs-title function_">toBe</span>(<span class="hljs-string">'hello'</span>);
</code></pre>
</li>
<li>
<p>symbol 类型</p>
<pre><code class="hljs language-typescript">   <span class="hljs-keyword">const</span> <span class="hljs-built_in">symbol</span> = <span class="hljs-title class_">Symbol</span>();
   <span class="hljs-keyword">const</span> value1 = baseTypeMatch&#x3C;<span class="hljs-built_in">number</span> | <span class="hljs-built_in">symbol</span>>(<span class="hljs-title class_">Symbol</span>(), {
     <span class="hljs-attr">foo</span>: <span class="hljs-function">() =></span> <span class="hljs-number">1</span>,
     <span class="hljs-attr">bar</span>: <span class="hljs-function">() =></span> <span class="hljs-number">2</span>,
     <span class="hljs-attr">_</span>: <span class="hljs-function">() =></span> <span class="hljs-built_in">symbol</span>,
   });
   <span class="hljs-title function_">expect</span>(value1).<span class="hljs-title function_">toBe</span>(<span class="hljs-built_in">symbol</span>);

   <span class="hljs-keyword">const</span> <span class="hljs-attr">cases</span>: <span class="hljs-title class_">BaseTypeMatchPatternType</span>&#x3C;<span class="hljs-built_in">symbol</span>, <span class="hljs-built_in">string</span> | <span class="hljs-built_in">boolean</span> | <span class="hljs-built_in">number</span> | <span class="hljs-built_in">symbol</span>> = {
     [value1 <span class="hljs-keyword">as</span> <span class="hljs-built_in">symbol</span>]: <span class="hljs-function">(<span class="hljs-params">val</span>) =></span> <span class="hljs-literal">false</span>,
     <span class="hljs-string">'a | b'</span>: <span class="hljs-function">(<span class="hljs-params">val</span>) =></span> <span class="hljs-number">1</span>,
     <span class="hljs-number">1</span>: <span class="hljs-function">(<span class="hljs-params">val</span>) =></span> val,
     <span class="hljs-attr">_</span>: <span class="hljs-function">(<span class="hljs-params">val</span>) =></span> <span class="hljs-string">'hello'</span>,
   };
   <span class="hljs-keyword">const</span> value2 = <span class="hljs-title function_">baseTypeMatch</span>(value1 <span class="hljs-keyword">as</span> <span class="hljs-built_in">symbol</span>, cases);
   <span class="hljs-title function_">expect</span>(value2).<span class="hljs-title function_">toBeFalsy</span>();
</code></pre>
</li>
</ol>
</li>
</ol>
<h2 id="未来将会支持的功能"><a aria-hidden="true" tabindex="-1" href="#未来将会支持的功能"><span class="icon icon-link"></span></a>未来将会支持的功能</h2>
<ol>
<li>实现多模式匹配, 预计会以 <code>"Quit | Start": () => other()</code> 的形式来实现.</li>
<li>兼容 typescript 中的 <code>enum</code> (实现方案考虑中).</li>
</ol>7:["$","article",null,{"children":[["$","div",null,{"className":"flex justify-center font-[Arial] max-w-[864px] text-center","children":["$","h1",null,{"className":"text-[2.5rem] font-bold bg-lime-300 px-5 py-2 rounded-sm text-shadow-lg leading-[1.1]","children":"rust-like-match"}]}],["$","time",null,{"dateTime":"2023-02-24","className":"text-center block my-4 text-sm opacity-60","children":"February\t24, 2023"}],[null,["$","$L17",null,{"theme":"jzman"}],["$","section",null,{"className":"markdown-body-jzman max-w-3xl","dangerouslySetInnerHTML":{"__html":"$18"}}]],null]}]
11:[["$","meta","0",{"charSet":"utf-8"}],["$","meta","1",{"name":"viewport","content":"width=device-width, initial-scale=1"}]]
b:null
16:{"metadata":[["$","title","0",{"children":"Ai.Haibara codes"}],["$","meta","1",{"name":"description","content":"LZS Blog"}],["$","link","2",{"rel":"icon","href":"/favicon.ico","type":"image/x-icon","sizes":"96x96"}]],"error":null,"digest":"$undefined"}
e:{"metadata":"$16:metadata","error":null,"digest":"$undefined"}
