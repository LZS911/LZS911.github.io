<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><link rel="apple-touch-icon" sizes="180x180" href="/favicon/apple-touch-icon.png"/><link rel="icon" type="image/png" sizes="32x32" href="/favicon/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="16x16" href="/favicon/favicon-16x16.png"/><link rel="manifest" href="/favicon/site.webmanifest"/><link rel="mask-icon" href="/favicon/safari-pinned-tab.svg" color="#000000"/><link rel="shortcut icon" href="/favicon/favicon.ico"/><meta name="msapplication-TileColor" content="#000000"/><meta name="msapplication-config" content="/favicon/browserconfig.xml"/><meta name="theme-color" content="#000"/><link rel="alternate" type="application/rss+xml" href="/feed.xml"/><meta property="og:image" content="https://og-image.vercel.app/Next.js%20Blog%20Starter%20Example.png?theme=light&amp;md=1&amp;fontSize=100px&amp;images=https%3A%2F%2Fassets.vercel.com%2Fimage%2Fupload%2Ffront%2Fassets%2Fdesign%2Fnextjs-black-logo.svg"/><title>JavaScript 中的抽象类 | Ai.Haibara codes</title><meta name="next-head-count" content="14"/><link rel="preload" href="/_next/static/css/8681f744d5932be6.css" as="style"/><link rel="stylesheet" href="/_next/static/css/8681f744d5932be6.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-8fa1640cc84ba8fe.js" defer=""></script><script src="/_next/static/chunks/framework-3b5a00d5d7e8d93b.js" defer=""></script><script src="/_next/static/chunks/main-59a90320855f5cf5.js" defer=""></script><script src="/_next/static/chunks/pages/_app-f46e289d7ac5e197.js" defer=""></script><script src="/_next/static/chunks/799-575b46febca3af7d.js" defer=""></script><script src="/_next/static/chunks/399-cac0cd8ed02bf02a.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bslug%5D-e2afa3a98c674f72.js" defer=""></script><script src="/_next/static/Rfvy9WK71nLCZ90Ws6Jh7/_buildManifest.js" defer=""></script><script src="/_next/static/Rfvy9WK71nLCZ90Ws6Jh7/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="min-h-screen"><header class="text-white bg-black drop-shadow-2xl"><div class="mx-auto my-0 max-w-[960px] py-6 px-4 flex items-center"><div class="flex items-center"><img alt="Ai.Haibara" src="/assets/blog/authors/haibara_2.jpg" width="100" height="100" decoding="async" data-nimg="1" class=" rounded-full" loading="lazy" style="color:transparent"/></div><div class="ml-6"><a class=" font-bold text-3xl" href="/">Ai.Haibara codes</a><div class="mt-2"><a class="p-1 rounded-sm text-xl mr-2 hover:border-b-2 border-indigo" href="/">Home</a><a class="p-1 rounded-sm text-xl mr-2 hover:border-b-2 border-indigo" href="/projects">Projects</a><a class="p-1 rounded-sm text-xl mr-2 hover:border-b-2 border-indigo" href="/talks">Talks</a><a class="p-1 rounded-sm text-xl mr-2 hover:border-b-2 border-indigo" href="/blogs">Blogs</a></div></div></div></header><main class="p-6 flex justify-center"><article><div class="flex justify-center font-[Arial] max-w-[864px] text-center"><h1 class="text-5xl font-bold bg-indigo px-5 py-2 rounded-sm text-shadow-lg leading-[1.1]">JavaScript 中的抽象类</h1></div><time dateTime="2025-03-05" class="text-center block my-4 text-sm opacity-60">March	5, 2025</time><section><div class="markdown-body-condensed-night-purple max-w-3xl"><p>在 JavaScript 中，抽象类的概念并不像 Java、TypeScript 和 Python 等其他语言那样得到原生支持。然而，我们可以通过编写自定义代码来模拟 JavaScript 中抽象类的行为。</p>
<p>本文将解释什么是抽象类、抽象类与函数式编程的对比，以及如何在 JavaScript 中实现抽象类。鉴于 TypeScript 是一种基于 JavaScript 的编程语言，这里将用它来解释抽象类的概念，以便于理解。</p>
<h2 id="什么是抽象类"><a aria-hidden="true" tabindex="-1" href="#什么是抽象类"><span class="icon icon-link"></span></a>什么是抽象类？</h2>
<p>在面向对象编程（OOP）中，所有的对象都是通过类来描述的。然而，并不是所有的类都用于描述具体的对象。如果一个类中没有包含足够的信息来描述一个具体的对象，这样的类就是<strong>抽象类</strong>。</p>
<p>抽象类除了不能实例化对象之外，类的其他功能依然存在。成员变量、成员方法和构造方法的访问方式与普通类一样。</p>
<p>由于抽象类不能实例化对象，因此抽象类必须被继承才能使用。这也是为什么通常在设计阶段就要决定是否要设计抽象类。</p>
<p>父类包含了子类集合的常见方法，但由于父类本身是抽象的，因此不能直接使用这些方法。</p>
<h3 id="示例typescript中的抽象类"><a aria-hidden="true" tabindex="-1" href="#示例typescript中的抽象类"><span class="icon icon-link"></span></a>示例：TypeScript中的抽象类</h3>
<blockquote>
<p>TypeScript 中的类、方法和字段可能是抽象的。
抽象方法或抽象字段是尚未提供实现的方法或字段。这些成员必须存在于抽象类中，而抽象类不能直接实例化。
抽象类的作用是作为子类的基类，子类会实现所有抽象成员。如果一个类没有任何抽象成员，则称其为具体类。</p>
</blockquote>
<h3 id="示例typescript-中的抽象类"><a aria-hidden="true" tabindex="-1" href="#示例typescript-中的抽象类"><span class="icon icon-link"></span></a>示例：TypeScript 中的抽象类</h3>
<p>在 TypeScript 中，类、方法和字段可以是抽象的。抽象方法或抽象字段是尚未提供实现的方法或字段。这些成员必须存在于抽象类中，而抽象类不能直接实例化。</p>
<p>抽象类的作用是作为子类的基类，子类会实现所有抽象成员。如果一个类没有任何抽象成员，则称其为<strong>具体类</strong>。</p>
<p>以下是一个抽象类 <code>BaseConfigUtils</code> 的示例：</p>
<pre><code class="language-typescript">export abstract class BaseConfigUtils&#x3C;
  T extends BaseConfig,
  InitOptions extends BaseOptions,
  ResolvedOptions extends InitOptions
> {
  // ...existing code...

  constructor(options: ConfigOptions&#x3C;T, InitOptions, ResolvedOptions>) {
    // ...existing code...
  }

  async resolveConfig(opts: unknown): Promise&#x3C;T> {
    // ...existing code...
  }

  protected async handleNonInteractiveMode(
    opts: InitOptions,
    existingConfig: T | null
  ): Promise&#x3C;T> {
    // ...existing code...
  }

  protected abstract handleInteractiveMode(
    opts: InitOptions,
    existingConfig: T | null
  ): Promise&#x3C;T>;

  protected abstract mergeConfig(
    opts: InitOptions,
    existingConfig: T
  ): Promise&#x3C;T>;

  protected abstract transformToConfig(opts: ResolvedOptions): T;

  protected abstract getConfigIdentifier(opts: InitOptions): string;

  // ...existing code...
}
</code></pre>
<p>在这个示例中，<code>BaseConfigUtils</code> 定义了处理配置文件的结构。子类必须实现 <code>handleInteractiveMode</code>、<code>mergeConfig</code>、<code>transformToConfig</code> 和 <code>getConfigIdentifier</code> 等方法。</p>
<h2 id="函数式编程方法"><a aria-hidden="true" tabindex="-1" href="#函数式编程方法"><span class="icon icon-link"></span></a>函数式编程方法</h2>
<p>函数式编程（FP）是一种将计算视为数学函数求值的范式，它避免改变状态和可变数据。FP 不使用类和继承，而是依赖纯函数和高阶函数。</p>
<h3 id="示例typescript中的函数式编程"><a aria-hidden="true" tabindex="-1" href="#示例typescript中的函数式编程"><span class="icon icon-link"></span></a>示例：TypeScript中的函数式编程</h3>
<p>以下是使用函数式编程实现类似功能的示例：</p>
<pre><code class="language-typescript">type ConfigKey = 'client' | 'mocks';

interface BaseConfig {
  [key: string]: string;
}

interface BaseOptions {
  yes: boolean;
  cwd: string;
  [key: string]: unknown;
}

interface ConfigOptions&#x3C;T extends BaseConfig, InitOptions extends BaseOptions, ResolvedOptions extends InitOptions> {
  configKey: ConfigKey;
  initOptionsSchema: z.ZodSchema&#x3C;InitOptions>;
  resolvedOptionsSchema: z.ZodSchema&#x3C;ResolvedOptions>;
  defaultConfig: T;
  command: Command;
  cwd: string;
}

const resolveConfig = async &#x3C;T extends BaseConfig, InitOptions extends BaseOptions, ResolvedOptions extends InitOptions>(
  options: ConfigOptions&#x3C;T, InitOptions, ResolvedOptions>,
  opts: unknown
): Promise&#x3C;T> => {
  const validatedOpts = await options.initOptionsSchema.parseAsync(opts).catch((error) => {
    handleSchemaError(error, options.command);
  });

  const existingConfig = await getRawConfigs(options.cwd, options.configKey, getConfigIdentifier(validatedOpts));

  if (validatedOpts.yes) {
    return handleNonInteractiveMode(options, validatedOpts, existingConfig);
  }

  return handleInteractiveMode(options, validatedOpts, existingConfig);
};

const handleNonInteractiveMode = async &#x3C;T extends BaseConfig, InitOptions extends BaseOptions, ResolvedOptions extends InitOptions>(
  options: ConfigOptions&#x3C;T, InitOptions, ResolvedOptions>,
  opts: InitOptions,
  existingConfig: T | null
): Promise&#x3C;T> => {
  if (existingConfig) {
    return mergeConfig(opts, existingConfig);
  }

  try {
    const validatedOpts = await options.resolvedOptionsSchema.parseAsync(opts);
    return transformToConfig(validatedOpts);
  } catch (error) {
    handleSchemaError(error, options.command);
  }
};

// 定义其他函数，如 handleInteractiveMode、mergeConfig、transformToConfig、getConfigIdentifier 和 getRawConfigs
</code></pre>
<h2 id="抽象类与函数式编程的比较"><a aria-hidden="true" tabindex="-1" href="#抽象类与函数式编程的比较"><span class="icon icon-link"></span></a>抽象类与函数式编程的比较</h2>
<h3 id="抽象类"><a aria-hidden="true" tabindex="-1" href="#抽象类"><span class="icon icon-link"></span></a>抽象类</h3>
<ul>
<li><strong>优点</strong>：
<ul>
<li>结构清晰，组织有序。</li>
<li>强制一致的接口。</li>
<li>对于熟悉面向对象编程（OOP）的开发人员来说更容易理解。</li>
</ul>
</li>
<li><strong>缺点</strong>：
<ul>
<li>可能导致复杂的继承层次结构。</li>
<li>在组合方面灵活性较差。</li>
</ul>
</li>
</ul>
<h3 id="函数式编程"><a aria-hidden="true" tabindex="-1" href="#函数式编程"><span class="icon icon-link"></span></a>函数式编程</h3>
<ul>
<li><strong>优点</strong>：
<ul>
<li>提倡不变性和纯函数。</li>
<li>更容易组合和重用函数。</li>
<li>避免了继承的陷阱。</li>
</ul>
</li>
<li><strong>缺点</strong>：
<ul>
<li>对于习惯于 OOP 的开发人员来说可能更难理解。</li>
<li>在管理状态和依赖项时可能会导致更多的样板代码。</li>
</ul>
</li>
</ul>
<h2 id="javascript-中的抽象类"><a aria-hidden="true" tabindex="-1" href="#javascript-中的抽象类"><span class="icon icon-link"></span></a>JavaScript 中的抽象类</h2>
<pre><code>class Base {
  constructor(name) {
    if (this.constructor == Base) {
      throw new Error("Class is of abstract type and can't be instantiated");
    }

    if (this.getName == undefined) {
      throw new Error('getName method must be implemented');
    }
    this.name = name;
  }

  printName() {
    console.log('Hello, ' + this.getName());
  }
}

class Derived extends Base {
  getName() {
     return 'world';
  }
}

// const b = new Base();
const d = new Derived();

d.printName();
</code></pre>
<h2 id="结论"><a aria-hidden="true" tabindex="-1" href="#结论"><span class="icon icon-link"></span></a>结论</h2>
<p>抽象类和函数式编程各有优缺点。抽象类提供了一种清晰且结构化的方法来强制接口和共享行为，而函数式编程则提供了灵活性并提倡不变性。选择哪种方法取决于项目的具体需求和团队对每种范式的熟悉程度。</p>
<p>如果想要在 JavaScript 中创建抽象类，建议使用 TypeScript，因为它不仅提供了类型安全性，还原生支持抽象类的概念。</p></div></section></article></main><footer class="bg-neutral-50 border-t border-neutral-200 text-center text-xs opacity-50 py-4">© 2022,<!-- --> <a rel="noopener noreferrer" class="hover:underline hover:bg-indigo" href="https://github.com/LZS911" target="_blank">LZS_911</a>, build with<!-- --> <a rel="noopener noreferrer" class="underline hover:bg-indigo" href="https://nextjs.org/" target="_blank">Next.js</a> <!-- -->and<!-- --> <a rel="noopener noreferrer" class="underline hover:bg-indigo" href="https://pages.github.com/?(null)" target="_blank">GitHub Pages</a></footer></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"JavaScript 中的抽象类","date":"2025-03-05","slug":"JavaScript 中的抽象类","author":"LZS_911","content":"\u003cp\u003e在 JavaScript 中，抽象类的概念并不像 Java、TypeScript 和 Python 等其他语言那样得到原生支持。然而，我们可以通过编写自定义代码来模拟 JavaScript 中抽象类的行为。\u003c/p\u003e\n\u003cp\u003e本文将解释什么是抽象类、抽象类与函数式编程的对比，以及如何在 JavaScript 中实现抽象类。鉴于 TypeScript 是一种基于 JavaScript 的编程语言，这里将用它来解释抽象类的概念，以便于理解。\u003c/p\u003e\n\u003ch2 id=\"什么是抽象类\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#什么是抽象类\"\u003e\u003cspan class=\"icon icon-link\"\u003e\u003c/span\u003e\u003c/a\u003e什么是抽象类？\u003c/h2\u003e\n\u003cp\u003e在面向对象编程（OOP）中，所有的对象都是通过类来描述的。然而，并不是所有的类都用于描述具体的对象。如果一个类中没有包含足够的信息来描述一个具体的对象，这样的类就是\u003cstrong\u003e抽象类\u003c/strong\u003e。\u003c/p\u003e\n\u003cp\u003e抽象类除了不能实例化对象之外，类的其他功能依然存在。成员变量、成员方法和构造方法的访问方式与普通类一样。\u003c/p\u003e\n\u003cp\u003e由于抽象类不能实例化对象，因此抽象类必须被继承才能使用。这也是为什么通常在设计阶段就要决定是否要设计抽象类。\u003c/p\u003e\n\u003cp\u003e父类包含了子类集合的常见方法，但由于父类本身是抽象的，因此不能直接使用这些方法。\u003c/p\u003e\n\u003ch3 id=\"示例typescript中的抽象类\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#示例typescript中的抽象类\"\u003e\u003cspan class=\"icon icon-link\"\u003e\u003c/span\u003e\u003c/a\u003e示例：TypeScript中的抽象类\u003c/h3\u003e\n\u003cblockquote\u003e\n\u003cp\u003eTypeScript 中的类、方法和字段可能是抽象的。\n抽象方法或抽象字段是尚未提供实现的方法或字段。这些成员必须存在于抽象类中，而抽象类不能直接实例化。\n抽象类的作用是作为子类的基类，子类会实现所有抽象成员。如果一个类没有任何抽象成员，则称其为具体类。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch3 id=\"示例typescript-中的抽象类\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#示例typescript-中的抽象类\"\u003e\u003cspan class=\"icon icon-link\"\u003e\u003c/span\u003e\u003c/a\u003e示例：TypeScript 中的抽象类\u003c/h3\u003e\n\u003cp\u003e在 TypeScript 中，类、方法和字段可以是抽象的。抽象方法或抽象字段是尚未提供实现的方法或字段。这些成员必须存在于抽象类中，而抽象类不能直接实例化。\u003c/p\u003e\n\u003cp\u003e抽象类的作用是作为子类的基类，子类会实现所有抽象成员。如果一个类没有任何抽象成员，则称其为\u003cstrong\u003e具体类\u003c/strong\u003e。\u003c/p\u003e\n\u003cp\u003e以下是一个抽象类 \u003ccode\u003eBaseConfigUtils\u003c/code\u003e 的示例：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-typescript\"\u003eexport abstract class BaseConfigUtils\u0026#x3C;\n  T extends BaseConfig,\n  InitOptions extends BaseOptions,\n  ResolvedOptions extends InitOptions\n\u003e {\n  // ...existing code...\n\n  constructor(options: ConfigOptions\u0026#x3C;T, InitOptions, ResolvedOptions\u003e) {\n    // ...existing code...\n  }\n\n  async resolveConfig(opts: unknown): Promise\u0026#x3C;T\u003e {\n    // ...existing code...\n  }\n\n  protected async handleNonInteractiveMode(\n    opts: InitOptions,\n    existingConfig: T | null\n  ): Promise\u0026#x3C;T\u003e {\n    // ...existing code...\n  }\n\n  protected abstract handleInteractiveMode(\n    opts: InitOptions,\n    existingConfig: T | null\n  ): Promise\u0026#x3C;T\u003e;\n\n  protected abstract mergeConfig(\n    opts: InitOptions,\n    existingConfig: T\n  ): Promise\u0026#x3C;T\u003e;\n\n  protected abstract transformToConfig(opts: ResolvedOptions): T;\n\n  protected abstract getConfigIdentifier(opts: InitOptions): string;\n\n  // ...existing code...\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e在这个示例中，\u003ccode\u003eBaseConfigUtils\u003c/code\u003e 定义了处理配置文件的结构。子类必须实现 \u003ccode\u003ehandleInteractiveMode\u003c/code\u003e、\u003ccode\u003emergeConfig\u003c/code\u003e、\u003ccode\u003etransformToConfig\u003c/code\u003e 和 \u003ccode\u003egetConfigIdentifier\u003c/code\u003e 等方法。\u003c/p\u003e\n\u003ch2 id=\"函数式编程方法\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#函数式编程方法\"\u003e\u003cspan class=\"icon icon-link\"\u003e\u003c/span\u003e\u003c/a\u003e函数式编程方法\u003c/h2\u003e\n\u003cp\u003e函数式编程（FP）是一种将计算视为数学函数求值的范式，它避免改变状态和可变数据。FP 不使用类和继承，而是依赖纯函数和高阶函数。\u003c/p\u003e\n\u003ch3 id=\"示例typescript中的函数式编程\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#示例typescript中的函数式编程\"\u003e\u003cspan class=\"icon icon-link\"\u003e\u003c/span\u003e\u003c/a\u003e示例：TypeScript中的函数式编程\u003c/h3\u003e\n\u003cp\u003e以下是使用函数式编程实现类似功能的示例：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-typescript\"\u003etype ConfigKey = 'client' | 'mocks';\n\ninterface BaseConfig {\n  [key: string]: string;\n}\n\ninterface BaseOptions {\n  yes: boolean;\n  cwd: string;\n  [key: string]: unknown;\n}\n\ninterface ConfigOptions\u0026#x3C;T extends BaseConfig, InitOptions extends BaseOptions, ResolvedOptions extends InitOptions\u003e {\n  configKey: ConfigKey;\n  initOptionsSchema: z.ZodSchema\u0026#x3C;InitOptions\u003e;\n  resolvedOptionsSchema: z.ZodSchema\u0026#x3C;ResolvedOptions\u003e;\n  defaultConfig: T;\n  command: Command;\n  cwd: string;\n}\n\nconst resolveConfig = async \u0026#x3C;T extends BaseConfig, InitOptions extends BaseOptions, ResolvedOptions extends InitOptions\u003e(\n  options: ConfigOptions\u0026#x3C;T, InitOptions, ResolvedOptions\u003e,\n  opts: unknown\n): Promise\u0026#x3C;T\u003e =\u003e {\n  const validatedOpts = await options.initOptionsSchema.parseAsync(opts).catch((error) =\u003e {\n    handleSchemaError(error, options.command);\n  });\n\n  const existingConfig = await getRawConfigs(options.cwd, options.configKey, getConfigIdentifier(validatedOpts));\n\n  if (validatedOpts.yes) {\n    return handleNonInteractiveMode(options, validatedOpts, existingConfig);\n  }\n\n  return handleInteractiveMode(options, validatedOpts, existingConfig);\n};\n\nconst handleNonInteractiveMode = async \u0026#x3C;T extends BaseConfig, InitOptions extends BaseOptions, ResolvedOptions extends InitOptions\u003e(\n  options: ConfigOptions\u0026#x3C;T, InitOptions, ResolvedOptions\u003e,\n  opts: InitOptions,\n  existingConfig: T | null\n): Promise\u0026#x3C;T\u003e =\u003e {\n  if (existingConfig) {\n    return mergeConfig(opts, existingConfig);\n  }\n\n  try {\n    const validatedOpts = await options.resolvedOptionsSchema.parseAsync(opts);\n    return transformToConfig(validatedOpts);\n  } catch (error) {\n    handleSchemaError(error, options.command);\n  }\n};\n\n// 定义其他函数，如 handleInteractiveMode、mergeConfig、transformToConfig、getConfigIdentifier 和 getRawConfigs\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"抽象类与函数式编程的比较\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#抽象类与函数式编程的比较\"\u003e\u003cspan class=\"icon icon-link\"\u003e\u003c/span\u003e\u003c/a\u003e抽象类与函数式编程的比较\u003c/h2\u003e\n\u003ch3 id=\"抽象类\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#抽象类\"\u003e\u003cspan class=\"icon icon-link\"\u003e\u003c/span\u003e\u003c/a\u003e抽象类\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e优点\u003c/strong\u003e：\n\u003cul\u003e\n\u003cli\u003e结构清晰，组织有序。\u003c/li\u003e\n\u003cli\u003e强制一致的接口。\u003c/li\u003e\n\u003cli\u003e对于熟悉面向对象编程（OOP）的开发人员来说更容易理解。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e缺点\u003c/strong\u003e：\n\u003cul\u003e\n\u003cli\u003e可能导致复杂的继承层次结构。\u003c/li\u003e\n\u003cli\u003e在组合方面灵活性较差。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"函数式编程\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#函数式编程\"\u003e\u003cspan class=\"icon icon-link\"\u003e\u003c/span\u003e\u003c/a\u003e函数式编程\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e优点\u003c/strong\u003e：\n\u003cul\u003e\n\u003cli\u003e提倡不变性和纯函数。\u003c/li\u003e\n\u003cli\u003e更容易组合和重用函数。\u003c/li\u003e\n\u003cli\u003e避免了继承的陷阱。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e缺点\u003c/strong\u003e：\n\u003cul\u003e\n\u003cli\u003e对于习惯于 OOP 的开发人员来说可能更难理解。\u003c/li\u003e\n\u003cli\u003e在管理状态和依赖项时可能会导致更多的样板代码。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"javascript-中的抽象类\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#javascript-中的抽象类\"\u003e\u003cspan class=\"icon icon-link\"\u003e\u003c/span\u003e\u003c/a\u003eJavaScript 中的抽象类\u003c/h2\u003e\n\u003cpre\u003e\u003ccode\u003eclass Base {\n  constructor(name) {\n    if (this.constructor == Base) {\n      throw new Error(\"Class is of abstract type and can't be instantiated\");\n    }\n\n    if (this.getName == undefined) {\n      throw new Error('getName method must be implemented');\n    }\n    this.name = name;\n  }\n\n  printName() {\n    console.log('Hello, ' + this.getName());\n  }\n}\n\nclass Derived extends Base {\n  getName() {\n     return 'world';\n  }\n}\n\n// const b = new Base();\nconst d = new Derived();\n\nd.printName();\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"结论\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#结论\"\u003e\u003cspan class=\"icon icon-link\"\u003e\u003c/span\u003e\u003c/a\u003e结论\u003c/h2\u003e\n\u003cp\u003e抽象类和函数式编程各有优缺点。抽象类提供了一种清晰且结构化的方法来强制接口和共享行为，而函数式编程则提供了灵活性并提倡不变性。选择哪种方法取决于项目的具体需求和团队对每种范式的熟悉程度。\u003c/p\u003e\n\u003cp\u003e如果想要在 JavaScript 中创建抽象类，建议使用 TypeScript，因为它不仅提供了类型安全性，还原生支持抽象类的概念。\u003c/p\u003e","theme":"condensed-night-purple","tag":["next.js","react"]}},"__N_SSG":true},"page":"/posts/[slug]","query":{"slug":"JavaScript 中的抽象类"},"buildId":"Rfvy9WK71nLCZ90Ws6Jh7","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>