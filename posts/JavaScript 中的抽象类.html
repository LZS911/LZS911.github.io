<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="preload" href="/_next/static/media/569ce4b8f30dc480-s.p.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="preload" href="/_next/static/media/93f479601ee12b01-s.p.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="stylesheet" href="/_next/static/css/afd685b2833157f9.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-6281654836ffc620.js"/><script src="/_next/static/chunks/4bd1b696-66c7c23a79af63cb.js" async=""></script><script src="/_next/static/chunks/684-2dd5576fde2f1aef.js" async=""></script><script src="/_next/static/chunks/main-app-8a63285bca825cb3.js" async=""></script><script src="/_next/static/chunks/874-90f68e0a3827b559.js" async=""></script><script src="/_next/static/chunks/app/error-d036ecfd03716e30.js" async=""></script><script src="/_next/static/chunks/app/not-found-2113bbd7a2f55e8f.js" async=""></script><script src="/_next/static/chunks/app/loading-b73dd9bd22c3caa2.js" async=""></script><script src="/_next/static/chunks/766-dfd76e5b111fda64.js" async=""></script><script src="/_next/static/chunks/app/(article)/layout-120a8801c6045af4.js" async=""></script><script src="/_next/static/chunks/62-abd5adcc4de2f71a.js" async=""></script><script src="/_next/static/chunks/app/(article)/posts/%5Bslug%5D/page-3df7d22b1edb27cc.js" async=""></script><meta name="next-size-adjust" content=""/><title>Ai.Haibara codes</title><meta name="description" content="LZS Blog"/><link rel="icon" href="/favicon.ico" type="image/x-icon" sizes="96x96"/><script>document.querySelectorAll('body link[rel="icon"], body link[rel="apple-touch-icon"]').forEach(el => document.head.appendChild(el))</script><script src="/_next/static/chunks/polyfills-42372ed130431b0a.js" noModule=""></script></head><body class="__variable_5cfdac __variable_9a8899 antialiased"><!--$--><html lang="en"><body class="__variable_5cfdac __variable_9a8899 antialiased"><div class="min-h-screen"><header class="text-white bg-black drop-shadow-2xl"><div class="mx-auto my-0 max-w-[960px] py-6 px-4 flex items-center"><div class="flex items-center"><img alt="Ai.Haibara" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class=" rounded-full" style="color:transparent" srcSet="/_next/image?url=%2Fassets%2Fblog%2Fauthors%2Fhaibara_2.jpg&amp;w=128&amp;q=75 1x, /_next/image?url=%2Fassets%2Fblog%2Fauthors%2Fhaibara_2.jpg&amp;w=256&amp;q=75 2x" src="/_next/image?url=%2Fassets%2Fblog%2Fauthors%2Fhaibara_2.jpg&amp;w=256&amp;q=75"/></div><div class="ml-6"><a class=" font-bold text-3xl" href="/">Ai.Haibara codes</a><div class="mt-2"><a class="p-1 rounded-sm text-xl mr-2 hover:border-b-2 border-lime-300" href="/">Home</a><a class="p-1 rounded-sm text-xl mr-2 hover:border-b-2 border-lime-300" href="/projects">Projects</a><a class="p-1 rounded-sm text-xl mr-2 hover:border-b-2 border-lime-300" href="/talks">Talks</a><a class="p-1 rounded-sm text-xl mr-2 hover:border-b-2 border-lime-300" href="/blogs">Blogs</a></div></div></div></header><main class="p-6 flex justify-center"><article><div class="flex justify-center font-[Arial] max-w-[864px] text-center"><h1 class="text-[2.5rem] font-bold bg-lime-300 px-5 py-2 rounded-sm text-shadow-lg leading-[1.1]">JavaScript 中的抽象类</h1></div><time dateTime="2025-03-05" class="text-center block my-4 text-sm opacity-60">March	5, 2025</time><section class="markdown-body-condensed-night-purple max-w-3xl"><p>在 JavaScript 中，抽象类的概念并不像 Java、TypeScript 和 Python 等其他语言那样得到原生支持。然而，我们可以通过编写自定义代码来模拟 JavaScript 中抽象类的行为。</p>
<p>本文将解释什么是抽象类、抽象类与函数式编程的对比，以及如何在 JavaScript 中实现抽象类。鉴于 TypeScript 是一种基于 JavaScript 的编程语言，这里将用它来解释抽象类的概念，以便于理解。</p>
<h2 id="什么是抽象类"><a aria-hidden="true" tabindex="-1" href="#什么是抽象类"><span class="icon icon-link"></span></a>什么是抽象类？</h2>
<p>在面向对象编程（OOP）中，所有的对象都是通过类来描述的。然而，并不是所有的类都用于描述具体的对象。如果一个类中没有包含足够的信息来描述一个具体的对象，这样的类就是<strong>抽象类</strong>。</p>
<p>抽象类除了不能实例化对象之外，类的其他功能依然存在。成员变量、成员方法和构造方法的访问方式与普通类一样。</p>
<p>由于抽象类不能实例化对象，因此抽象类必须被继承才能使用。这也是为什么通常在设计阶段就要决定是否要设计抽象类。</p>
<p>父类包含了子类集合的常见方法，但由于父类本身是抽象的，因此不能直接使用这些方法。</p>
<h3 id="示例typescript-中的抽象类"><a aria-hidden="true" tabindex="-1" href="#示例typescript-中的抽象类"><span class="icon icon-link"></span></a>示例：TypeScript 中的抽象类</h3>
<p>在 TypeScript 中，类、方法和字段可以是抽象的。抽象方法或抽象字段是尚未提供实现的方法或字段。这些成员必须存在于抽象类中，而抽象类不能直接实例化。</p>
<p>抽象类的作用是作为子类的基类，子类会实现所有抽象成员。如果一个类没有任何抽象成员，则称其为<strong>具体类</strong>。</p>
<p>以下是一个抽象类 <code>BaseConfigUtils</code> 的示例：</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BaseConfigUtils</span>&#x3C;
  T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">BaseConfig</span>,
  <span class="hljs-title class_">InitOptions</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">BaseOptions</span>,
  <span class="hljs-title class_">ResolvedOptions</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">InitOptions</span>
> {
  <span class="hljs-comment">// ...existing code...</span>

  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-attr">options</span>: <span class="hljs-title class_">ConfigOptions</span>&#x3C;T, <span class="hljs-title class_">InitOptions</span>, <span class="hljs-title class_">ResolvedOptions</span>></span>) {
    <span class="hljs-comment">// ...existing code...</span>
  }

  <span class="hljs-keyword">async</span> <span class="hljs-title function_">resolveConfig</span>(<span class="hljs-attr">opts</span>: <span class="hljs-built_in">unknown</span>): <span class="hljs-title class_">Promise</span>&#x3C;T> {
    <span class="hljs-comment">// ...existing code...</span>
  }

  <span class="hljs-keyword">protected</span> <span class="hljs-keyword">async</span> <span class="hljs-title function_">handleNonInteractiveMode</span>(
    <span class="hljs-attr">opts</span>: <span class="hljs-title class_">InitOptions</span>,
    <span class="hljs-attr">existingConfig</span>: T | <span class="hljs-literal">null</span>
  ): <span class="hljs-title class_">Promise</span>&#x3C;T> {
    <span class="hljs-comment">// ...existing code...</span>
  }

  <span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> <span class="hljs-title function_">handleInteractiveMode</span>(
    <span class="hljs-attr">opts</span>: <span class="hljs-title class_">InitOptions</span>,
    <span class="hljs-attr">existingConfig</span>: T | <span class="hljs-literal">null</span>
  ): <span class="hljs-title class_">Promise</span>&#x3C;T>;

  <span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> <span class="hljs-title function_">mergeConfig</span>(
    <span class="hljs-attr">opts</span>: <span class="hljs-title class_">InitOptions</span>,
    <span class="hljs-attr">existingConfig</span>: T
  ): <span class="hljs-title class_">Promise</span>&#x3C;T>;

  <span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> <span class="hljs-title function_">transformToConfig</span>(<span class="hljs-attr">opts</span>: <span class="hljs-title class_">ResolvedOptions</span>): T;

  <span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> <span class="hljs-title function_">getConfigIdentifier</span>(<span class="hljs-attr">opts</span>: <span class="hljs-title class_">InitOptions</span>): <span class="hljs-built_in">string</span>;

  <span class="hljs-comment">// ...existing code...</span>
}
</code></pre>
<p>在这个示例中，<code>BaseConfigUtils</code> 定义了处理配置文件的结构。子类必须实现 <code>handleInteractiveMode</code>、<code>mergeConfig</code>、<code>transformToConfig</code> 和 <code>getConfigIdentifier</code> 等方法。</p>
<h2 id="函数式编程方法"><a aria-hidden="true" tabindex="-1" href="#函数式编程方法"><span class="icon icon-link"></span></a>函数式编程方法</h2>
<p>函数式编程（FP）是一种将计算视为数学函数求值的范式，它避免改变状态和可变数据。FP 不使用类和继承，而是依赖纯函数和高阶函数。</p>
<h3 id="示例typescript中的函数式编程"><a aria-hidden="true" tabindex="-1" href="#示例typescript中的函数式编程"><span class="icon icon-link"></span></a>示例：TypeScript中的函数式编程</h3>
<p>以下是使用函数式编程实现类似功能的示例：</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">ConfigKey</span> = <span class="hljs-string">'client'</span> | <span class="hljs-string">'mocks'</span>;

<span class="hljs-keyword">interface</span> <span class="hljs-title class_">BaseConfig</span> {
  [<span class="hljs-attr">key</span>: <span class="hljs-built_in">string</span>]: <span class="hljs-built_in">string</span>;
}

<span class="hljs-keyword">interface</span> <span class="hljs-title class_">BaseOptions</span> {
  <span class="hljs-attr">yes</span>: <span class="hljs-built_in">boolean</span>;
  <span class="hljs-attr">cwd</span>: <span class="hljs-built_in">string</span>;
  [<span class="hljs-attr">key</span>: <span class="hljs-built_in">string</span>]: <span class="hljs-built_in">unknown</span>;
}

<span class="hljs-keyword">interface</span> <span class="hljs-title class_">ConfigOptions</span>&#x3C;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">BaseConfig</span>, <span class="hljs-title class_">InitOptions</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">BaseOptions</span>, <span class="hljs-title class_">ResolvedOptions</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">InitOptions</span>> {
  <span class="hljs-attr">configKey</span>: <span class="hljs-title class_">ConfigKey</span>;
  <span class="hljs-attr">initOptionsSchema</span>: z.<span class="hljs-property">ZodSchema</span>&#x3C;<span class="hljs-title class_">InitOptions</span>>;
  <span class="hljs-attr">resolvedOptionsSchema</span>: z.<span class="hljs-property">ZodSchema</span>&#x3C;<span class="hljs-title class_">ResolvedOptions</span>>;
  <span class="hljs-attr">defaultConfig</span>: T;
  <span class="hljs-attr">command</span>: <span class="hljs-title class_">Command</span>;
  <span class="hljs-attr">cwd</span>: <span class="hljs-built_in">string</span>;
  <span class="hljs-title function_">handleInteractiveMode</span>(
    <span class="hljs-attr">opts</span>: <span class="hljs-title class_">InitOptions</span>,
    <span class="hljs-attr">existingConfig</span>: T | <span class="hljs-literal">null</span>
  ): <span class="hljs-title class_">Promise</span>&#x3C;T>;
  <span class="hljs-title function_">transformToConfig</span>(<span class="hljs-attr">opts</span>: <span class="hljs-title class_">ResolvedOptions</span>): T;
  <span class="hljs-title function_">getConfigIdentifier</span>(<span class="hljs-attr">opts</span>: <span class="hljs-title class_">InitOptions</span>): <span class="hljs-built_in">string</span>;
  <span class="hljs-title function_">mergeConfig</span>(
    <span class="hljs-attr">opts</span>: <span class="hljs-title class_">InitOptions</span>,
    <span class="hljs-attr">existingConfig</span>: T
  ): <span class="hljs-title class_">Promise</span>&#x3C;T>;
}

<span class="hljs-keyword">const</span> resolveConfig = <span class="hljs-keyword">async</span> &#x3C;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">BaseConfig</span>, <span class="hljs-title class_">InitOptions</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">BaseOptions</span>, <span class="hljs-title class_">ResolvedOptions</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">InitOptions</span>>(
  <span class="hljs-attr">options</span>: <span class="hljs-title class_">ConfigOptions</span>&#x3C;T, <span class="hljs-title class_">InitOptions</span>, <span class="hljs-title class_">ResolvedOptions</span>>,
  <span class="hljs-attr">opts</span>: <span class="hljs-built_in">unknown</span>
): <span class="hljs-title class_">Promise</span>&#x3C;T> => {
  <span class="hljs-keyword">const</span> { transformToConfig, getConfigIdentifier, mergeConfig, handleInteractiveMode } = options;
  <span class="hljs-keyword">const</span> validatedOpts = <span class="hljs-keyword">await</span> options.<span class="hljs-property">initOptionsSchema</span>.<span class="hljs-title function_">parseAsync</span>(opts).<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">error</span>) =></span> {
    <span class="hljs-title function_">handleSchemaError</span>(error, options.<span class="hljs-property">command</span>);
  });

  <span class="hljs-keyword">const</span> existingConfig = <span class="hljs-keyword">await</span> <span class="hljs-title function_">getRawConfigs</span>(options.<span class="hljs-property">cwd</span>, options.<span class="hljs-property">configKey</span>, <span class="hljs-title function_">getConfigIdentifier</span>(validatedOpts));

  <span class="hljs-keyword">if</span> (validatedOpts.<span class="hljs-property">yes</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-title function_">handleNonInteractiveMode</span>(options, validatedOpts, existingConfig);
  }

  <span class="hljs-keyword">return</span> <span class="hljs-title function_">handleInteractiveMode</span>(options, validatedOpts, existingConfig);
};

<span class="hljs-keyword">const</span> handleNonInteractiveMode = <span class="hljs-keyword">async</span> &#x3C;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">BaseConfig</span>, <span class="hljs-title class_">InitOptions</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">BaseOptions</span>, <span class="hljs-title class_">ResolvedOptions</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">InitOptions</span>>(
  <span class="hljs-attr">options</span>: <span class="hljs-title class_">ConfigOptions</span>&#x3C;T, <span class="hljs-title class_">InitOptions</span>, <span class="hljs-title class_">ResolvedOptions</span>>,
  <span class="hljs-attr">opts</span>: <span class="hljs-title class_">InitOptions</span>,
  <span class="hljs-attr">existingConfig</span>: T | <span class="hljs-literal">null</span>
): <span class="hljs-title class_">Promise</span>&#x3C;T> => {
  <span class="hljs-keyword">if</span> (existingConfig) {
    <span class="hljs-keyword">return</span> <span class="hljs-title function_">mergeConfig</span>(opts, existingConfig);
  }

  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">const</span> validatedOpts = <span class="hljs-keyword">await</span> options.<span class="hljs-property">resolvedOptionsSchema</span>.<span class="hljs-title function_">parseAsync</span>(opts);
    <span class="hljs-keyword">return</span> <span class="hljs-title function_">transformToConfig</span>(validatedOpts);
  } <span class="hljs-keyword">catch</span> (error) {
    <span class="hljs-title function_">handleSchemaError</span>(error, options.<span class="hljs-property">command</span>);
  }
};

<span class="hljs-comment">// 定义其他函数，如 getRawConfigs</span>
</code></pre>
<h2 id="抽象类与函数式编程的比较"><a aria-hidden="true" tabindex="-1" href="#抽象类与函数式编程的比较"><span class="icon icon-link"></span></a>抽象类与函数式编程的比较</h2>
<h3 id="抽象类"><a aria-hidden="true" tabindex="-1" href="#抽象类"><span class="icon icon-link"></span></a>抽象类</h3>
<ul>
<li><strong>优点</strong>：
<ul>
<li>结构清晰，组织有序。</li>
<li>强制一致的接口。</li>
<li>对于熟悉面向对象编程（OOP）的开发人员来说更容易理解。</li>
</ul>
</li>
<li><strong>缺点</strong>：
<ul>
<li>可能导致复杂的继承层次结构。</li>
<li>在组合方面灵活性较差。</li>
</ul>
</li>
</ul>
<h3 id="函数式编程"><a aria-hidden="true" tabindex="-1" href="#函数式编程"><span class="icon icon-link"></span></a>函数式编程</h3>
<ul>
<li><strong>优点</strong>：
<ul>
<li>提倡不变性和纯函数。</li>
<li>更容易组合和重用函数。</li>
<li>避免了继承的陷阱。</li>
</ul>
</li>
<li><strong>缺点</strong>：
<ul>
<li>对于习惯于 OOP 的开发人员来说可能更难理解。</li>
<li>在管理状态和依赖项时可能会导致更多的样板代码。</li>
</ul>
</li>
</ul>
<h2 id="javascript-中的抽象类"><a aria-hidden="true" tabindex="-1" href="#javascript-中的抽象类"><span class="icon icon-link"></span></a>JavaScript 中的抽象类</h2>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name</span>) {
    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">constructor</span> == <span class="hljs-title class_">Base</span>) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">"Class is of abstract type and can't be instantiated"</span>);
    }

    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">getName</span> == <span class="hljs-literal">undefined</span>) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">'getName method must be implemented'</span>);
    }
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;
  }

  <span class="hljs-title function_">printName</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'Hello, '</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getName</span>());
  }
}

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Base</span> {
  <span class="hljs-title function_">getName</span>(<span class="hljs-params"></span>) {
     <span class="hljs-keyword">return</span> <span class="hljs-string">'world'</span>;
  }
}

<span class="hljs-comment">// const b = new Base();</span>
<span class="hljs-keyword">const</span> d = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Derived</span>();

d.<span class="hljs-title function_">printName</span>();
</code></pre>
<h2 id="结论"><a aria-hidden="true" tabindex="-1" href="#结论"><span class="icon icon-link"></span></a>结论</h2>
<p>抽象类和函数式编程各有优缺点。抽象类提供了一种清晰且结构化的方法来强制接口和共享行为，而函数式编程则提供了灵活性并提倡不变性。选择哪种方法取决于项目的具体需求和团队对每种范式的熟悉程度。</p>
<p>如果想要在 JavaScript 中创建抽象类，建议使用 TypeScript，因为它不仅提供了类型安全性，还原生支持抽象类的概念。</p></section></article><!--$--><!--/$--><!--$--><!--/$--></main><footer class="bg-neutral-50 border-t border-neutral-200 text-center text-xs opacity-50 py-4">© 2022 - <!-- -->2025<a rel="noopener noreferrer" class="hover:underline hover:bg-indigo" href="https://github.com/LZS911" target="_blank">, LZS_911</a>, build with<!-- --> <a rel="noopener noreferrer" class="underline hover:bg-indigo" href="https://nextjs.org/" target="_blank">Next.js</a> <!-- -->and<!-- --> <a rel="noopener noreferrer" class="underline hover:bg-indigo" href="https://pages.github.com/?(null)" target="_blank">GitHub Pages</a></footer></div><!--/$--><script src="/_next/static/chunks/webpack-6281654836ffc620.js" async=""></script></body></html><script>(self.__next_f=self.__next_f||[]).push([0])</script><script>self.__next_f.push([1,"1:\"$Sreact.fragment\"\n2:I[7555,[],\"\"]\n3:I[1901,[\"874\",\"static/chunks/874-90f68e0a3827b559.js\",\"39\",\"static/chunks/app/error-d036ecfd03716e30.js\"],\"default\"]\n4:I[1295,[],\"\"]\n5:I[9543,[\"874\",\"static/chunks/874-90f68e0a3827b559.js\",\"345\",\"static/chunks/app/not-found-2113bbd7a2f55e8f.js\"],\"default\"]\n8:I[9665,[],\"MetadataBoundary\"]\na:I[9665,[],\"OutletBoundary\"]\nd:I[4911,[],\"AsyncMetadataOutlet\"]\nf:I[8460,[\"209\",\"static/chunks/app/loading-b73dd9bd22c3caa2.js\"],\"default\"]\n10:I[9665,[],\"ViewportBoundary\"]\n12:I[6614,[],\"\"]\n:HL[\"/_next/static/media/569ce4b8f30dc480-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n:HL[\"/_next/static/media/93f479601ee12b01-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n:HL[\"/_next/static/css/afd685b2833157f9.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"0:{\"P\":null,\"b\":\"F63JTs1PA5XvAzvJlmBBT\",\"p\":\"\",\"c\":[\"\",\"posts\",\"JavaScript%20%E4%B8%AD%E7%9A%84%E6%8A%BD%E8%B1%A1%E7%B1%BB\"],\"i\":false,\"f\":[[[\"\",{\"children\":[\"(article)\",{\"children\":[\"posts\",{\"children\":[[\"slug\",\"JavaScript%20%E4%B8%AD%E7%9A%84%E6%8A%BD%E8%B1%A1%E7%B1%BB\",\"d\"],{\"children\":[\"__PAGE__\",{}]}]}]}]},\"$undefined\",\"$undefined\",true],[\"\",[\"$\",\"$1\",\"c\",{\"children\":[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/afd685b2833157f9.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}]],[\"$\",\"html\",null,{\"lang\":\"en\",\"children\":[\"$\",\"body\",null,{\"className\":\"__variable_5cfdac __variable_9a8899 antialiased\",\"children\":[\"$\",\"$L2\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$3\",\"errorStyles\":[],\"errorScripts\":[],\"template\":[\"$\",\"$L4\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[[\"$\",\"$L5\",null,{}],[]],\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]}]}]]}],{\"children\":[\"(article)\",[\"$\",\"$1\",\"c\",{\"children\":[null,\"$L6\"]}],{\"children\":[\"posts\",[\"$\",\"$1\",\"c\",{\"children\":[null,[\"$\",\"$L2\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L4\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]]}],{\"children\":[[\"slug\",\"JavaScript%20%E4%B8%AD%E7%9A%84%E6%8A%BD%E8%B1%A1%E7%B1%BB\",\"d\"],[\"$\",\"$1\",\"c\",{\"children\":[null,[\"$\",\"$L2\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L4\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]]}],{\"children\":[\"__PAGE__\",[\"$\",\"$1\",\"c\",{\"children\":[\"$L7\",[\"$\",\"$L8\",null,{\"children\":\"$L9\"}],null,[\"$\",\"$La\",null,{\"children\":[\"$Lb\",\"$Lc\",[\"$\",\"$Ld\",null,{\"promise\":\"$@e\"}]]}]]}],{},null,false]},null,false]},null,false]},null,false]},[[\"$\",\"$Lf\",\"l\",{}],[],[]],false],[\"$\",\"$1\",\"h\",{\"children\":[null,[\"$\",\"$1\",\"dr9BU7cNfaycODngJJXP2\",{\"children\":[[\"$\",\"$L10\",null,{\"children\":\"$L11\"}],[\"$\",\"meta\",null,{\"name\":\"next-size-adjust\",\"content\":\"\"}]]}],null]}],false]],\"m\":\"$undefined\",\"G\":[\"$12\",\"$undefined\"],\"s\":false,\"S\":true}\n"])</script><script>self.__next_f.push([1,"13:I[4467,[\"874\",\"static/chunks/874-90f68e0a3827b559.js\",\"766\",\"static/chunks/766-dfd76e5b111fda64.js\",\"651\",\"static/chunks/app/(article)/layout-120a8801c6045af4.js\"],\"default\"]\n14:\"$Sreact.suspense\"\n15:I[4911,[],\"AsyncMetadata\"]\n6:[\"$\",\"html\",null,{\"lang\":\"en\",\"children\":[\"$\",\"body\",null,{\"className\":\"__variable_5cfdac __variable_9a8899 antialiased\",\"children\":[[\"$\",\"div\",null,{\"className\":\"min-h-screen\",\"children\":[[\"$\",\"$L13\",null,{}],[\"$\",\"main\",null,{\"className\":\"p-6 flex justify-center\",\"children\":[\"$\",\"$L2\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L4\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]}],[\"$\",\"footer\",null,{\"className\":\"bg-neutral-50 border-t border-neutral-200 text-center text-xs opacity-50 py-4\",\"children\":[\"© 2022 - \",2025,[\"$\",\"a\",null,{\"rel\":\"noopener noreferrer\",\"className\":\"hover:underline hover:bg-indigo\",\"href\":\"https://github.com/LZS911\",\"target\":\"_blank\",\"children\":\", LZS_911\"}],\", build with\",\" \",[\"$\",\"a\",null,{\"rel\":\"noopener noreferrer\",\"className\":\"underline hover:bg-indigo\",\"href\":\"https://nextjs.org/\",\"target\":\"_blank\",\"children\":\"Next.js\"}],\" \",\"and\",\" \",[\"$\",\"a\",null,{\"rel\":\"noopener noreferrer\",\"className\":\"underline hover:bg-indigo\",\"href\":\"https://pages.github.com/?(null)\",\"target\":\"_blank\",\"children\":\"GitHub Pages\"}]]}]]}],false]}]}]\n9:[\"$\",\"$14\",null,{\"fallback\":null,\"children\":[\"$\",\"$L15\",null,{\"promise\":\"$@16\"}]}]\n"])</script><script>self.__next_f.push([1,"c:null\n"])</script><script>self.__next_f.push([1,"17:I[5099,[\"766\",\"static/chunks/766-dfd76e5b111fda64.js\",\"62\",\"static/chunks/62-abd5adcc4de2f71a.js\",\"520\",\"static/chunks/app/(article)/posts/%5Bslug%5D/page-3df7d22b1edb27cc.js\"],\"ThemeLoader\"]\n18:T42ee,"])</script><script>self.__next_f.push([1,"\u003cp\u003e在 JavaScript 中，抽象类的概念并不像 Java、TypeScript 和 Python 等其他语言那样得到原生支持。然而，我们可以通过编写自定义代码来模拟 JavaScript 中抽象类的行为。\u003c/p\u003e\n\u003cp\u003e本文将解释什么是抽象类、抽象类与函数式编程的对比，以及如何在 JavaScript 中实现抽象类。鉴于 TypeScript 是一种基于 JavaScript 的编程语言，这里将用它来解释抽象类的概念，以便于理解。\u003c/p\u003e\n\u003ch2 id=\"什么是抽象类\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#什么是抽象类\"\u003e\u003cspan class=\"icon icon-link\"\u003e\u003c/span\u003e\u003c/a\u003e什么是抽象类？\u003c/h2\u003e\n\u003cp\u003e在面向对象编程（OOP）中，所有的对象都是通过类来描述的。然而，并不是所有的类都用于描述具体的对象。如果一个类中没有包含足够的信息来描述一个具体的对象，这样的类就是\u003cstrong\u003e抽象类\u003c/strong\u003e。\u003c/p\u003e\n\u003cp\u003e抽象类除了不能实例化对象之外，类的其他功能依然存在。成员变量、成员方法和构造方法的访问方式与普通类一样。\u003c/p\u003e\n\u003cp\u003e由于抽象类不能实例化对象，因此抽象类必须被继承才能使用。这也是为什么通常在设计阶段就要决定是否要设计抽象类。\u003c/p\u003e\n\u003cp\u003e父类包含了子类集合的常见方法，但由于父类本身是抽象的，因此不能直接使用这些方法。\u003c/p\u003e\n\u003ch3 id=\"示例typescript-中的抽象类\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#示例typescript-中的抽象类\"\u003e\u003cspan class=\"icon icon-link\"\u003e\u003c/span\u003e\u003c/a\u003e示例：TypeScript 中的抽象类\u003c/h3\u003e\n\u003cp\u003e在 TypeScript 中，类、方法和字段可以是抽象的。抽象方法或抽象字段是尚未提供实现的方法或字段。这些成员必须存在于抽象类中，而抽象类不能直接实例化。\u003c/p\u003e\n\u003cp\u003e抽象类的作用是作为子类的基类，子类会实现所有抽象成员。如果一个类没有任何抽象成员，则称其为\u003cstrong\u003e具体类\u003c/strong\u003e。\u003c/p\u003e\n\u003cp\u003e以下是一个抽象类 \u003ccode\u003eBaseConfigUtils\u003c/code\u003e 的示例：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-typescript\"\u003e\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eabstract\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eBaseConfigUtils\u003c/span\u003e\u0026#x3C;\n  T \u003cspan class=\"hljs-keyword\"\u003eextends\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eBaseConfig\u003c/span\u003e,\n  \u003cspan class=\"hljs-title class_\"\u003eInitOptions\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eextends\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eBaseOptions\u003c/span\u003e,\n  \u003cspan class=\"hljs-title class_\"\u003eResolvedOptions\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eextends\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eInitOptions\u003c/span\u003e\n\u003e {\n  \u003cspan class=\"hljs-comment\"\u003e// ...existing code...\u003c/span\u003e\n\n  \u003cspan class=\"hljs-title function_\"\u003econstructor\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003cspan class=\"hljs-attr\"\u003eoptions\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eConfigOptions\u003c/span\u003e\u0026#x3C;T, \u003cspan class=\"hljs-title class_\"\u003eInitOptions\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003eResolvedOptions\u003c/span\u003e\u003e\u003c/span\u003e) {\n    \u003cspan class=\"hljs-comment\"\u003e// ...existing code...\u003c/span\u003e\n  }\n\n  \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eresolveConfig\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003eopts\u003c/span\u003e: \u003cspan class=\"hljs-built_in\"\u003eunknown\u003c/span\u003e): \u003cspan class=\"hljs-title class_\"\u003ePromise\u003c/span\u003e\u0026#x3C;T\u003e {\n    \u003cspan class=\"hljs-comment\"\u003e// ...existing code...\u003c/span\u003e\n  }\n\n  \u003cspan class=\"hljs-keyword\"\u003eprotected\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ehandleNonInteractiveMode\u003c/span\u003e(\n    \u003cspan class=\"hljs-attr\"\u003eopts\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eInitOptions\u003c/span\u003e,\n    \u003cspan class=\"hljs-attr\"\u003eexistingConfig\u003c/span\u003e: T | \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e\n  ): \u003cspan class=\"hljs-title class_\"\u003ePromise\u003c/span\u003e\u0026#x3C;T\u003e {\n    \u003cspan class=\"hljs-comment\"\u003e// ...existing code...\u003c/span\u003e\n  }\n\n  \u003cspan class=\"hljs-keyword\"\u003eprotected\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eabstract\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ehandleInteractiveMode\u003c/span\u003e(\n    \u003cspan class=\"hljs-attr\"\u003eopts\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eInitOptions\u003c/span\u003e,\n    \u003cspan class=\"hljs-attr\"\u003eexistingConfig\u003c/span\u003e: T | \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e\n  ): \u003cspan class=\"hljs-title class_\"\u003ePromise\u003c/span\u003e\u0026#x3C;T\u003e;\n\n  \u003cspan class=\"hljs-keyword\"\u003eprotected\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eabstract\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003emergeConfig\u003c/span\u003e(\n    \u003cspan class=\"hljs-attr\"\u003eopts\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eInitOptions\u003c/span\u003e,\n    \u003cspan class=\"hljs-attr\"\u003eexistingConfig\u003c/span\u003e: T\n  ): \u003cspan class=\"hljs-title class_\"\u003ePromise\u003c/span\u003e\u0026#x3C;T\u003e;\n\n  \u003cspan class=\"hljs-keyword\"\u003eprotected\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eabstract\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003etransformToConfig\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003eopts\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eResolvedOptions\u003c/span\u003e): T;\n\n  \u003cspan class=\"hljs-keyword\"\u003eprotected\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eabstract\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003egetConfigIdentifier\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003eopts\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eInitOptions\u003c/span\u003e): \u003cspan class=\"hljs-built_in\"\u003estring\u003c/span\u003e;\n\n  \u003cspan class=\"hljs-comment\"\u003e// ...existing code...\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e在这个示例中，\u003ccode\u003eBaseConfigUtils\u003c/code\u003e 定义了处理配置文件的结构。子类必须实现 \u003ccode\u003ehandleInteractiveMode\u003c/code\u003e、\u003ccode\u003emergeConfig\u003c/code\u003e、\u003ccode\u003etransformToConfig\u003c/code\u003e 和 \u003ccode\u003egetConfigIdentifier\u003c/code\u003e 等方法。\u003c/p\u003e\n\u003ch2 id=\"函数式编程方法\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#函数式编程方法\"\u003e\u003cspan class=\"icon icon-link\"\u003e\u003c/span\u003e\u003c/a\u003e函数式编程方法\u003c/h2\u003e\n\u003cp\u003e函数式编程（FP）是一种将计算视为数学函数求值的范式，它避免改变状态和可变数据。FP 不使用类和继承，而是依赖纯函数和高阶函数。\u003c/p\u003e\n\u003ch3 id=\"示例typescript中的函数式编程\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#示例typescript中的函数式编程\"\u003e\u003cspan class=\"icon icon-link\"\u003e\u003c/span\u003e\u003c/a\u003e示例：TypeScript中的函数式编程\u003c/h3\u003e\n\u003cp\u003e以下是使用函数式编程实现类似功能的示例：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-typescript\"\u003e\u003cspan class=\"hljs-keyword\"\u003etype\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eConfigKey\u003c/span\u003e = \u003cspan class=\"hljs-string\"\u003e'client'\u003c/span\u003e | \u003cspan class=\"hljs-string\"\u003e'mocks'\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003einterface\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eBaseConfig\u003c/span\u003e {\n  [\u003cspan class=\"hljs-attr\"\u003ekey\u003c/span\u003e: \u003cspan class=\"hljs-built_in\"\u003estring\u003c/span\u003e]: \u003cspan class=\"hljs-built_in\"\u003estring\u003c/span\u003e;\n}\n\n\u003cspan class=\"hljs-keyword\"\u003einterface\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eBaseOptions\u003c/span\u003e {\n  \u003cspan class=\"hljs-attr\"\u003eyes\u003c/span\u003e: \u003cspan class=\"hljs-built_in\"\u003eboolean\u003c/span\u003e;\n  \u003cspan class=\"hljs-attr\"\u003ecwd\u003c/span\u003e: \u003cspan class=\"hljs-built_in\"\u003estring\u003c/span\u003e;\n  [\u003cspan class=\"hljs-attr\"\u003ekey\u003c/span\u003e: \u003cspan class=\"hljs-built_in\"\u003estring\u003c/span\u003e]: \u003cspan class=\"hljs-built_in\"\u003eunknown\u003c/span\u003e;\n}\n\n\u003cspan class=\"hljs-keyword\"\u003einterface\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eConfigOptions\u003c/span\u003e\u0026#x3C;T \u003cspan class=\"hljs-keyword\"\u003eextends\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eBaseConfig\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003eInitOptions\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eextends\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eBaseOptions\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003eResolvedOptions\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eextends\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eInitOptions\u003c/span\u003e\u003e {\n  \u003cspan class=\"hljs-attr\"\u003econfigKey\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eConfigKey\u003c/span\u003e;\n  \u003cspan class=\"hljs-attr\"\u003einitOptionsSchema\u003c/span\u003e: z.\u003cspan class=\"hljs-property\"\u003eZodSchema\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-title class_\"\u003eInitOptions\u003c/span\u003e\u003e;\n  \u003cspan class=\"hljs-attr\"\u003eresolvedOptionsSchema\u003c/span\u003e: z.\u003cspan class=\"hljs-property\"\u003eZodSchema\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-title class_\"\u003eResolvedOptions\u003c/span\u003e\u003e;\n  \u003cspan class=\"hljs-attr\"\u003edefaultConfig\u003c/span\u003e: T;\n  \u003cspan class=\"hljs-attr\"\u003ecommand\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eCommand\u003c/span\u003e;\n  \u003cspan class=\"hljs-attr\"\u003ecwd\u003c/span\u003e: \u003cspan class=\"hljs-built_in\"\u003estring\u003c/span\u003e;\n  \u003cspan class=\"hljs-title function_\"\u003ehandleInteractiveMode\u003c/span\u003e(\n    \u003cspan class=\"hljs-attr\"\u003eopts\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eInitOptions\u003c/span\u003e,\n    \u003cspan class=\"hljs-attr\"\u003eexistingConfig\u003c/span\u003e: T | \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e\n  ): \u003cspan class=\"hljs-title class_\"\u003ePromise\u003c/span\u003e\u0026#x3C;T\u003e;\n  \u003cspan class=\"hljs-title function_\"\u003etransformToConfig\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003eopts\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eResolvedOptions\u003c/span\u003e): T;\n  \u003cspan class=\"hljs-title function_\"\u003egetConfigIdentifier\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003eopts\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eInitOptions\u003c/span\u003e): \u003cspan class=\"hljs-built_in\"\u003estring\u003c/span\u003e;\n  \u003cspan class=\"hljs-title function_\"\u003emergeConfig\u003c/span\u003e(\n    \u003cspan class=\"hljs-attr\"\u003eopts\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eInitOptions\u003c/span\u003e,\n    \u003cspan class=\"hljs-attr\"\u003eexistingConfig\u003c/span\u003e: T\n  ): \u003cspan class=\"hljs-title class_\"\u003ePromise\u003c/span\u003e\u0026#x3C;T\u003e;\n}\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e resolveConfig = \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e \u0026#x3C;T \u003cspan class=\"hljs-keyword\"\u003eextends\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eBaseConfig\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003eInitOptions\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eextends\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eBaseOptions\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003eResolvedOptions\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eextends\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eInitOptions\u003c/span\u003e\u003e(\n  \u003cspan class=\"hljs-attr\"\u003eoptions\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eConfigOptions\u003c/span\u003e\u0026#x3C;T, \u003cspan class=\"hljs-title class_\"\u003eInitOptions\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003eResolvedOptions\u003c/span\u003e\u003e,\n  \u003cspan class=\"hljs-attr\"\u003eopts\u003c/span\u003e: \u003cspan class=\"hljs-built_in\"\u003eunknown\u003c/span\u003e\n): \u003cspan class=\"hljs-title class_\"\u003ePromise\u003c/span\u003e\u0026#x3C;T\u003e =\u003e {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e { transformToConfig, getConfigIdentifier, mergeConfig, handleInteractiveMode } = options;\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e validatedOpts = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e options.\u003cspan class=\"hljs-property\"\u003einitOptionsSchema\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eparseAsync\u003c/span\u003e(opts).\u003cspan class=\"hljs-title function_\"\u003ecatch\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003eerror\u003c/span\u003e) =\u003e\u003c/span\u003e {\n    \u003cspan class=\"hljs-title function_\"\u003ehandleSchemaError\u003c/span\u003e(error, options.\u003cspan class=\"hljs-property\"\u003ecommand\u003c/span\u003e);\n  });\n\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e existingConfig = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003egetRawConfigs\u003c/span\u003e(options.\u003cspan class=\"hljs-property\"\u003ecwd\u003c/span\u003e, options.\u003cspan class=\"hljs-property\"\u003econfigKey\u003c/span\u003e, \u003cspan class=\"hljs-title function_\"\u003egetConfigIdentifier\u003c/span\u003e(validatedOpts));\n\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (validatedOpts.\u003cspan class=\"hljs-property\"\u003eyes\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ehandleNonInteractiveMode\u003c/span\u003e(options, validatedOpts, existingConfig);\n  }\n\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ehandleInteractiveMode\u003c/span\u003e(options, validatedOpts, existingConfig);\n};\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e handleNonInteractiveMode = \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e \u0026#x3C;T \u003cspan class=\"hljs-keyword\"\u003eextends\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eBaseConfig\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003eInitOptions\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eextends\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eBaseOptions\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003eResolvedOptions\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eextends\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eInitOptions\u003c/span\u003e\u003e(\n  \u003cspan class=\"hljs-attr\"\u003eoptions\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eConfigOptions\u003c/span\u003e\u0026#x3C;T, \u003cspan class=\"hljs-title class_\"\u003eInitOptions\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003eResolvedOptions\u003c/span\u003e\u003e,\n  \u003cspan class=\"hljs-attr\"\u003eopts\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eInitOptions\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003eexistingConfig\u003c/span\u003e: T | \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e\n): \u003cspan class=\"hljs-title class_\"\u003ePromise\u003c/span\u003e\u0026#x3C;T\u003e =\u003e {\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (existingConfig) {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003emergeConfig\u003c/span\u003e(opts, existingConfig);\n  }\n\n  \u003cspan class=\"hljs-keyword\"\u003etry\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e validatedOpts = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e options.\u003cspan class=\"hljs-property\"\u003eresolvedOptionsSchema\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eparseAsync\u003c/span\u003e(opts);\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003etransformToConfig\u003c/span\u003e(validatedOpts);\n  } \u003cspan class=\"hljs-keyword\"\u003ecatch\u003c/span\u003e (error) {\n    \u003cspan class=\"hljs-title function_\"\u003ehandleSchemaError\u003c/span\u003e(error, options.\u003cspan class=\"hljs-property\"\u003ecommand\u003c/span\u003e);\n  }\n};\n\n\u003cspan class=\"hljs-comment\"\u003e// 定义其他函数，如 getRawConfigs\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"抽象类与函数式编程的比较\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#抽象类与函数式编程的比较\"\u003e\u003cspan class=\"icon icon-link\"\u003e\u003c/span\u003e\u003c/a\u003e抽象类与函数式编程的比较\u003c/h2\u003e\n\u003ch3 id=\"抽象类\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#抽象类\"\u003e\u003cspan class=\"icon icon-link\"\u003e\u003c/span\u003e\u003c/a\u003e抽象类\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e优点\u003c/strong\u003e：\n\u003cul\u003e\n\u003cli\u003e结构清晰，组织有序。\u003c/li\u003e\n\u003cli\u003e强制一致的接口。\u003c/li\u003e\n\u003cli\u003e对于熟悉面向对象编程（OOP）的开发人员来说更容易理解。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e缺点\u003c/strong\u003e：\n\u003cul\u003e\n\u003cli\u003e可能导致复杂的继承层次结构。\u003c/li\u003e\n\u003cli\u003e在组合方面灵活性较差。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"函数式编程\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#函数式编程\"\u003e\u003cspan class=\"icon icon-link\"\u003e\u003c/span\u003e\u003c/a\u003e函数式编程\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e优点\u003c/strong\u003e：\n\u003cul\u003e\n\u003cli\u003e提倡不变性和纯函数。\u003c/li\u003e\n\u003cli\u003e更容易组合和重用函数。\u003c/li\u003e\n\u003cli\u003e避免了继承的陷阱。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e缺点\u003c/strong\u003e：\n\u003cul\u003e\n\u003cli\u003e对于习惯于 OOP 的开发人员来说可能更难理解。\u003c/li\u003e\n\u003cli\u003e在管理状态和依赖项时可能会导致更多的样板代码。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"javascript-中的抽象类\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#javascript-中的抽象类\"\u003e\u003cspan class=\"icon icon-link\"\u003e\u003c/span\u003e\u003c/a\u003eJavaScript 中的抽象类\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-typescript\"\u003e\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eBase\u003c/span\u003e {\n  \u003cspan class=\"hljs-title function_\"\u003econstructor\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003ename\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (\u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003econstructor\u003c/span\u003e == \u003cspan class=\"hljs-title class_\"\u003eBase\u003c/span\u003e) {\n      \u003cspan class=\"hljs-keyword\"\u003ethrow\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eError\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"Class is of abstract type and can't be instantiated\"\u003c/span\u003e);\n    }\n\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (\u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003egetName\u003c/span\u003e == \u003cspan class=\"hljs-literal\"\u003eundefined\u003c/span\u003e) {\n      \u003cspan class=\"hljs-keyword\"\u003ethrow\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eError\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'getName method must be implemented'\u003c/span\u003e);\n    }\n    \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ename\u003c/span\u003e = name;\n  }\n\n  \u003cspan class=\"hljs-title function_\"\u003eprintName\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n    \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'Hello, '\u003c/span\u003e + \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003egetName\u003c/span\u003e());\n  }\n}\n\n\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eDerived\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eextends\u003c/span\u003e \u003cspan class=\"hljs-title class_ inherited__\"\u003eBase\u003c/span\u003e {\n  \u003cspan class=\"hljs-title function_\"\u003egetName\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n     \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'world'\u003c/span\u003e;\n  }\n}\n\n\u003cspan class=\"hljs-comment\"\u003e// const b = new Base();\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e d = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eDerived\u003c/span\u003e();\n\nd.\u003cspan class=\"hljs-title function_\"\u003eprintName\u003c/span\u003e();\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"结论\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#结论\"\u003e\u003cspan class=\"icon icon-link\"\u003e\u003c/span\u003e\u003c/a\u003e结论\u003c/h2\u003e\n\u003cp\u003e抽象类和函数式编程各有优缺点。抽象类提供了一种清晰且结构化的方法来强制接口和共享行为，而函数式编程则提供了灵活性并提倡不变性。选择哪种方法取决于项目的具体需求和团队对每种范式的熟悉程度。\u003c/p\u003e\n\u003cp\u003e如果想要在 JavaScript 中创建抽象类，建议使用 TypeScript，因为它不仅提供了类型安全性，还原生支持抽象类的概念。\u003c/p\u003e"])</script><script>self.__next_f.push([1,"7:[\"$\",\"article\",null,{\"children\":[[\"$\",\"div\",null,{\"className\":\"flex justify-center font-[Arial] max-w-[864px] text-center\",\"children\":[\"$\",\"h1\",null,{\"className\":\"text-[2.5rem] font-bold bg-lime-300 px-5 py-2 rounded-sm text-shadow-lg leading-[1.1]\",\"children\":\"JavaScript 中的抽象类\"}]}],[\"$\",\"time\",null,{\"dateTime\":\"2025-03-05\",\"className\":\"text-center block my-4 text-sm opacity-60\",\"children\":\"March\\t5, 2025\"}],[null,[\"$\",\"$L17\",null,{\"theme\":\"condensed-night-purple\"}],[\"$\",\"section\",null,{\"className\":\"markdown-body-condensed-night-purple max-w-3xl\",\"dangerouslySetInnerHTML\":{\"__html\":\"$18\"}}]],null]}]\n"])</script><script>self.__next_f.push([1,"11:[[\"$\",\"meta\",\"0\",{\"charSet\":\"utf-8\"}],[\"$\",\"meta\",\"1\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}]]\nb:null\n"])</script><script>self.__next_f.push([1,"16:{\"metadata\":[[\"$\",\"title\",\"0\",{\"children\":\"Ai.Haibara codes\"}],[\"$\",\"meta\",\"1\",{\"name\":\"description\",\"content\":\"LZS Blog\"}],[\"$\",\"link\",\"2\",{\"rel\":\"icon\",\"href\":\"/favicon.ico\",\"type\":\"image/x-icon\",\"sizes\":\"96x96\"}]],\"error\":null,\"digest\":\"$undefined\"}\ne:{\"metadata\":\"$16:metadata\",\"error\":null,\"digest\":\"$undefined\"}\n"])</script></body></html>