<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><link rel="apple-touch-icon" sizes="180x180" href="/favicon/apple-touch-icon.png"/><link rel="icon" type="image/png" sizes="32x32" href="/favicon/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="16x16" href="/favicon/favicon-16x16.png"/><link rel="manifest" href="/favicon/site.webmanifest"/><link rel="mask-icon" href="/favicon/safari-pinned-tab.svg" color="#000000"/><link rel="shortcut icon" href="/favicon/favicon.ico"/><meta name="msapplication-TileColor" content="#000000"/><meta name="msapplication-config" content="/favicon/browserconfig.xml"/><meta name="theme-color" content="#000"/><link rel="alternate" type="application/rss+xml" href="/feed.xml"/><meta property="og:image" content="https://og-image.vercel.app/Next.js%20Blog%20Starter%20Example.png?theme=light&amp;md=1&amp;fontSize=100px&amp;images=https%3A%2F%2Fassets.vercel.com%2Fimage%2Fupload%2Ffront%2Fassets%2Fdesign%2Fnextjs-black-logo.svg"/><title>大文件分片上传实践 | Ai.Haibara codes</title><meta name="next-head-count" content="14"/><link rel="preload" href="/_next/static/css/8681f744d5932be6.css" as="style"/><link rel="stylesheet" href="/_next/static/css/8681f744d5932be6.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-8fa1640cc84ba8fe.js" defer=""></script><script src="/_next/static/chunks/framework-3b5a00d5d7e8d93b.js" defer=""></script><script src="/_next/static/chunks/main-59a90320855f5cf5.js" defer=""></script><script src="/_next/static/chunks/pages/_app-f46e289d7ac5e197.js" defer=""></script><script src="/_next/static/chunks/799-575b46febca3af7d.js" defer=""></script><script src="/_next/static/chunks/399-cac0cd8ed02bf02a.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bslug%5D-e2afa3a98c674f72.js" defer=""></script><script src="/_next/static/YJP6rl8scvGOq7wuL0OEb/_buildManifest.js" defer=""></script><script src="/_next/static/YJP6rl8scvGOq7wuL0OEb/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="min-h-screen"><header class="text-white bg-black drop-shadow-2xl"><div class="mx-auto my-0 max-w-[960px] py-6 px-4 flex items-center"><div class="flex items-center"><img alt="Ai.Haibara" src="/assets/blog/authors/haibara_2.jpg" width="100" height="100" decoding="async" data-nimg="1" class=" rounded-full" loading="lazy" style="color:transparent"/></div><div class="ml-6"><a class=" font-bold text-3xl" href="/">Ai.Haibara codes</a><div class="mt-2"><a class="p-1 rounded-sm text-xl mr-2 hover:border-b-2 border-indigo" href="/">Home</a><a class="p-1 rounded-sm text-xl mr-2 hover:border-b-2 border-indigo" href="/projects">Projects</a><a class="p-1 rounded-sm text-xl mr-2 hover:border-b-2 border-indigo" href="/talks">Talks</a><a class="p-1 rounded-sm text-xl mr-2 hover:border-b-2 border-indigo" href="/blogs">Blogs</a></div></div></div></header><main class="p-6 flex justify-center"><article><div class="flex justify-center font-[Arial] max-w-[864px] text-center"><h1 class="text-5xl font-bold bg-indigo px-5 py-2 rounded-sm text-shadow-lg leading-[1.1]">大文件分片上传实践</h1></div><time dateTime="2024-08-20" class="text-center block my-4 text-sm opacity-60">August	20, 2024</time><section><div class="markdown-body-orange max-w-3xl"><h2 id="需求分析"><a aria-hidden="true" tabindex="-1" href="#需求分析"><span class="icon icon-link"></span></a>需求分析</h2>
<ul>
<li>大文件切割分片上传</li>
<li>断点续传</li>
<li>文件上传进度展示</li>
<li>暂停以及继续上传文件</li>
<li>已上传文件秒传</li>
</ul>
<h2 id="技术选型"><a aria-hidden="true" tabindex="-1" href="#技术选型"><span class="icon icon-link"></span></a>技术选型</h2>
<ul>
<li>前端：React.js</li>
<li>服务端：Golang</li>
<li>数据库：MySQL</li>
<li>oss：minio</li>
</ul>
<h2 id="性能优化"><a aria-hidden="true" tabindex="-1" href="#性能优化"><span class="icon icon-link"></span></a>性能优化</h2>
<ul>
<li>可控制 Promise 并发数量的 PromisePool</li>
<li>基于 WebWorker 的 WorkerPool / ThreadPool</li>
<li>解决了前端计算大文件 hash 速度过慢的痛点</li>
</ul>
<h2 id="整体流程"><a aria-hidden="true" tabindex="-1" href="#整体流程"><span class="icon icon-link"></span></a>整体流程</h2>
<ol>
<li>对文件进行分片处理</li>
<li>计算各分片 Hash 以及文件 Hash</li>
<li>文件上传状态检查</li>
</ol>
<ul>
<li>新文件上传：
<ol>
<li>调用服务端API创建新的上传记录。</li>
<li>上传所有分片。</li>
<li>所有分片上传完成后，调用服务端完成接口。</li>
</ol>
</li>
<li>断点续传
<ol>
<li>只上传未完成的分片。</li>
<li>所有分片上传完成后，调用服务端完成接口。</li>
</ol>
</li>
<li>已上传文件
<ol>
<li>直接展示上传完成状态，无需重新上传。</li>
</ol>
</li>
</ul>
<h2 id="前端part"><a aria-hidden="true" tabindex="-1" href="#前端part"><span class="icon icon-link"></span></a>前端Part</h2>
<h3 id="1-文件分片"><a aria-hidden="true" tabindex="-1" href="#1-文件分片"><span class="icon icon-link"></span></a>1. 文件分片</h3>
<h4 id="11-目标"><a aria-hidden="true" tabindex="-1" href="#11-目标"><span class="icon icon-link"></span></a>1.1 目标</h4>
<p>将文件按指定的分片大小进行分片, 最终拿到文件的 ArrayBuffer 数组用于上传和分片 Hash 计算</p>
<h4 id="12-实现"><a aria-hidden="true" tabindex="-1" href="#12-实现"><span class="icon icon-link"></span></a>1.2 实现</h4>
<p>利用 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Blob/slice">File.API</a>对文件进行切割</p>
<pre><code class="language-typescript">export function sliceFile(file: File, baseSize = 1): Blob[] {
  const chunkSize = baseSize * 1024 * 1024;
  const chunks: Blob[] = [];
  let startPos = 0;
  while (startPos &#x3C; file.size) {
    chunks.push(file.slice(startPos, startPos + chunkSize));
    startPos += chunkSize;
  }
  return chunks;
}
</code></pre>
<p>获取到文件分片后的 Blob 数组后并不能直接用于计算分片 hash, 还需要将它们转成 ArrayBuffer 数组。</p>
<p>可以通过以下两种方式进行转换：</p>
<ol>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/FileReader">FileReader</a></li>
</ol>
<pre><code class="language-typescript">export async function getArrayBufFromBlobs(chunks: Blob[]): Promise&#x3C;ArrayBuffer[]> {
  async function readAsArrayBuffer(file: Blob) {
    return new Promise&#x3C;ArrayBuffer>((rs) => {
      const fileReader = new FileReader()
      fileReader.onload = (e) => rs(e.target!.result as ArrayBuffer)
      fileReader.readAsArrayBuffer(file)
    })
  }
  return await Promise.all(chunks.map((chunk: Blob) => readAsArrayBuffer(chunk)))
}
</code></pre>
<ol start="2">
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Blob/arrayBuffer">Blob.ArrayBuff</a></li>
</ol>
<pre><code class="language-typescript">export async function getArrayBufFromBlobs(chunks: Blob[]): Promise&#x3C;ArrayBuffer[]> {
  return Promise.all(chunks.map(chunk => chunk.arrayBuffer()))
}
</code></pre>
<blockquote>
<p>遗留：是否需要将分片过程放到 WebWorker 中, 以避免阻塞主线程</p>
<p>Tips: <a href="https://www.cnblogs.com/penghuwan/p/12053775.html">前端的二进制家族：Blob 与 ArrayBuffer</a></p>
</blockquote>
<h3 id="2-计算分片-hash"><a aria-hidden="true" tabindex="-1" href="#2-计算分片-hash"><span class="icon icon-link"></span></a>2. 计算分片 Hash</h3>
<h4 id="21-目标"><a aria-hidden="true" tabindex="-1" href="#21-目标"><span class="icon icon-link"></span></a>2.1 目标</h4>
<p>使用文件分片的 Hash 来标识文件分片, 用来判断这个分片是否已经上传过了</p>
<h4 id="22-使用-promiseall-处理"><a aria-hidden="true" tabindex="-1" href="#22-使用-promiseall-处理"><span class="icon icon-link"></span></a>2.2 使用 Promise.all 处理</h4>
<p>使用 <a href="https://www.npmjs.com/package/hash-wasm">hash-wasm</a> 对分片进行 Hash 计算</p>
<pre><code class="language-typescript">import { crc32, md5 } from 'hash-wasm';

export async function singleChunkProcessor(
  chunkBlob: Blob,
  strategy: Strategy
) {
  const arrayBuffer = await chunkBlob.arrayBuffer();
  const unit8Array = new Uint8Array(arrayBuffer);
  return strategy === Strategy.md5 || strategy === Strategy.mixed
    ? [await md5(unit8Array)]
    : [await crc32(unit8Array)];
}

export async function getChunksHashWithPromise(chunksBlob: Blob[]) {
  let chunksHash: string[] = [];

  await Promise.all(
    chunksBlob.map((v) => {
      return singleChunkProcessor(v, Strategy.crc32);
    })
  ).then((res) => {
    chunksHash = res.flat();
  });

  return chunksHash;
}
</code></pre>
<h4 id="23-使用-web-workers"><a aria-hidden="true" tabindex="-1" href="#23-使用-web-workers"><span class="icon icon-link"></span></a>2.3 使用 Web Workers</h4>
<p>由于计算文件分片 Hash 是一个 CPU 密集型任务, 直接在主线程中计算 hash 必定会导致 UI 卡死, 考虑做以下几点优化：</p>
<ol>
<li>放到 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Web_Workers_API/Using_web_workers">WebWorker</a> 中计算 Hash。并且，ArrayBuffer 是可 Transfer 的对象, 在主线程与 Worker 线程通信时, 可以通过移交控制权的方式通信, 避免线程通信引起的结构化克隆</li>
<li>分片之间的 Hash 计算没有关联, 而 WebWorker 可以用来开额外的计算线程, 考虑基于 WebWorker 实现线程池(WorkerPool)来加速计算分片 Hash</li>
<li>当文件较大时计算使用分片的 MD5值作为 Hash 计算速度仍然较慢, 但分片的 hash 其实只是为了标识分片, 对于唯一性要求并不高, 考虑在文件较大的场景下使用 CRC32 值作为分片的 Hash。CRC32的十六进制表示只有8位(MD5有32位), 且 CPU 对计算 CRC32 有硬件加速, 速度会比计算 MD5 快得多</li>
</ol>
<h3 id="3-计算文件-hash"><a aria-hidden="true" tabindex="-1" href="#3-计算文件-hash"><span class="icon icon-link"></span></a>3. 计算文件 Hash</h3>
<h4 id="31-目标"><a aria-hidden="true" tabindex="-1" href="#31-目标"><span class="icon icon-link"></span></a>3.1 目标</h4>
<p>计算文件的 Hash 用来标识这个文件是否已上传</p>
<h4 id="32-存在的问题与解决思路"><a aria-hidden="true" tabindex="-1" href="#32-存在的问题与解决思路"><span class="icon icon-link"></span></a>3.2 存在的问题与解决思路</h4>
<p>计算全部文件的 hash 效率过低，考虑使用以下两种方案之一</p>
<ul>
<li>使用 <a href="https://www.infoq.cn/article/lwlcldgjyc7lye95ewl8">wasm</a>: <a href="https://juejin.cn/post/7129446744080777224">https://juejin.cn/post/7129446744080777224</a></li>
<li>使用 MerkleTree(默克尔树) 的树根 hash 作为文件的 hash: <a href="https://juejin.cn/post/7354362021428117519#heading-6">https://juejin.cn/post/7354362021428117519#heading-6</a></li>
</ul>
<h3 id="4上传文件分片"><a aria-hidden="true" tabindex="-1" href="#4上传文件分片"><span class="icon icon-link"></span></a>4.上传文件分片</h3>
<h4 id="41-目标"><a aria-hidden="true" tabindex="-1" href="#41-目标"><span class="icon icon-link"></span></a>4.1 目标</h4>
<ul>
<li>实现文件分片的并发上传</li>
<li>实现中止以及继续上传文件分片</li>
<li>实时展示文件上传进度</li>
</ul>
<h4 id="42-实现文件分片的并发上传"><a aria-hidden="true" tabindex="-1" href="#42-实现文件分片的并发上传"><span class="icon icon-link"></span></a>4.2 实现文件分片的并发上传</h4>
<p>实现 PromisePool 来控制请求的发送：<a href="https://juejin.cn/post/7353106546827624463#heading-23">https://juejin.cn/post/7353106546827624463#heading-23</a></p>
<h3 id="展示上传进度"><a aria-hidden="true" tabindex="-1" href="#展示上传进度"><span class="icon icon-link"></span></a>展示上传进度</h3>
<p>todo...</p>
<h2 id="服务端-part"><a aria-hidden="true" tabindex="-1" href="#服务端-part"><span class="icon icon-link"></span></a>服务端 Part</h2>
<h3 id="getsuccesschunks"><a aria-hidden="true" tabindex="-1" href="#getsuccesschunks"><span class="icon icon-link"></span></a>GetSuccessChunks</h3>
<p>通过文件 hash 判断当前文件是否存在上传记录</p>
<ul>
<li>未上传</li>
<li>部分上传：通过 minio client 提供的接口判断当前文件上传过的 chunks</li>
<li>上传完成</li>
</ul>
<h3 id="newmultipart"><a aria-hidden="true" tabindex="-1" href="#newmultipart"><span class="icon icon-link"></span></a>NewMultipart</h3>
<p>文件未上传的情况下调用该请求，向数据库中插入一条记录</p>
<h3 id="getmultipartuploadurl"><a aria-hidden="true" tabindex="-1" href="#getmultipartuploadurl"><span class="icon icon-link"></span></a>GetMultipartUploadUrl</h3>
<p>通过 minio client 生成上传部分 chunks 的 url</p>
<h3 id="updatefilechunk"><a aria-hidden="true" tabindex="-1" href="#updatefilechunk"><span class="icon icon-link"></span></a>UpdateFileChunk</h3>
<p>更新 MySQL 记录中的 completed_parts 字段</p>
<h3 id="completemultipart"><a aria-hidden="true" tabindex="-1" href="#completemultipart"><span class="icon icon-link"></span></a>CompleteMultipart</h3>
<p>通过 minio client 提供的接口合并之前上传过的文件分片并标记数据库中记录为上传成功</p>
<h2 id="todo"><a aria-hidden="true" tabindex="-1" href="#todo"><span class="icon icon-link"></span></a>Todo</h2>
<ol>
<li>暂停上传功能</li>
<li>关闭应用后重启保留上传进度</li>
<li>分布式服务</li>
<li>分片 Hash 判断文件分片是否上传</li>
<li>多文件同时上传</li>
<li></li>
</ol>
<blockquote>
<p>参考至:</p>
<ol>
<li><a href="https://juejin.cn/post/7353106546827624463">https://juejin.cn/post/7353106546827624463</a></li>
<li><a href="https://www.cnblogs.com/xiahj/p/vue-simple-uploader.html">https://www.cnblogs.com/xiahj/p/vue-simple-uploader.html</a></li>
<li><a href="https://juejin.cn/post/6844904046436843527">https://juejin.cn/post/6844904046436843527</a></li>
<li><a href="https://www.infoq.cn/article/lwlcldgjyc7lye95ewl8">https://www.infoq.cn/article/lwlcldgjyc7lye95ewl8</a></li>
<li><a href="https://juejin.cn/post/7129446744080777224">https://juejin.cn/post/7129446744080777224</a></li>
<li><a href="https://juejin.cn/post/7354362021428117519">https://juejin.cn/post/7354362021428117519</a></li>
</ol>
</blockquote></div></section></article></main><footer class="bg-neutral-50 border-t border-neutral-200 text-center text-xs opacity-50 py-4">© 2022,<!-- --> <a rel="noopener noreferrer" class="hover:underline hover:bg-indigo" href="https://github.com/LZS911" target="_blank">LZS_911</a>, build with<!-- --> <a rel="noopener noreferrer" class="underline hover:bg-indigo" href="https://nextjs.org/" target="_blank">Next.js</a> <!-- -->and<!-- --> <a rel="noopener noreferrer" class="underline hover:bg-indigo" href="https://pages.github.com/?(null)" target="_blank">GitHub Pages</a></footer></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"大文件分片上传实践","date":"2024-08-20","slug":"大文件分片上传实践","author":"Ai.Haibara","content":"\u003ch2 id=\"需求分析\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#需求分析\"\u003e\u003cspan class=\"icon icon-link\"\u003e\u003c/span\u003e\u003c/a\u003e需求分析\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e大文件切割分片上传\u003c/li\u003e\n\u003cli\u003e断点续传\u003c/li\u003e\n\u003cli\u003e文件上传进度展示\u003c/li\u003e\n\u003cli\u003e暂停以及继续上传文件\u003c/li\u003e\n\u003cli\u003e已上传文件秒传\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"技术选型\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#技术选型\"\u003e\u003cspan class=\"icon icon-link\"\u003e\u003c/span\u003e\u003c/a\u003e技术选型\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e前端：React.js\u003c/li\u003e\n\u003cli\u003e服务端：Golang\u003c/li\u003e\n\u003cli\u003e数据库：MySQL\u003c/li\u003e\n\u003cli\u003eoss：minio\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"性能优化\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#性能优化\"\u003e\u003cspan class=\"icon icon-link\"\u003e\u003c/span\u003e\u003c/a\u003e性能优化\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e可控制 Promise 并发数量的 PromisePool\u003c/li\u003e\n\u003cli\u003e基于 WebWorker 的 WorkerPool / ThreadPool\u003c/li\u003e\n\u003cli\u003e解决了前端计算大文件 hash 速度过慢的痛点\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"整体流程\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#整体流程\"\u003e\u003cspan class=\"icon icon-link\"\u003e\u003c/span\u003e\u003c/a\u003e整体流程\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003e对文件进行分片处理\u003c/li\u003e\n\u003cli\u003e计算各分片 Hash 以及文件 Hash\u003c/li\u003e\n\u003cli\u003e文件上传状态检查\u003c/li\u003e\n\u003c/ol\u003e\n\u003cul\u003e\n\u003cli\u003e新文件上传：\n\u003col\u003e\n\u003cli\u003e调用服务端API创建新的上传记录。\u003c/li\u003e\n\u003cli\u003e上传所有分片。\u003c/li\u003e\n\u003cli\u003e所有分片上传完成后，调用服务端完成接口。\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/li\u003e\n\u003cli\u003e断点续传\n\u003col\u003e\n\u003cli\u003e只上传未完成的分片。\u003c/li\u003e\n\u003cli\u003e所有分片上传完成后，调用服务端完成接口。\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/li\u003e\n\u003cli\u003e已上传文件\n\u003col\u003e\n\u003cli\u003e直接展示上传完成状态，无需重新上传。\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"前端part\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#前端part\"\u003e\u003cspan class=\"icon icon-link\"\u003e\u003c/span\u003e\u003c/a\u003e前端Part\u003c/h2\u003e\n\u003ch3 id=\"1-文件分片\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#1-文件分片\"\u003e\u003cspan class=\"icon icon-link\"\u003e\u003c/span\u003e\u003c/a\u003e1. 文件分片\u003c/h3\u003e\n\u003ch4 id=\"11-目标\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#11-目标\"\u003e\u003cspan class=\"icon icon-link\"\u003e\u003c/span\u003e\u003c/a\u003e1.1 目标\u003c/h4\u003e\n\u003cp\u003e将文件按指定的分片大小进行分片, 最终拿到文件的 ArrayBuffer 数组用于上传和分片 Hash 计算\u003c/p\u003e\n\u003ch4 id=\"12-实现\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#12-实现\"\u003e\u003cspan class=\"icon icon-link\"\u003e\u003c/span\u003e\u003c/a\u003e1.2 实现\u003c/h4\u003e\n\u003cp\u003e利用 \u003ca href=\"https://developer.mozilla.org/en-US/docs/Web/API/Blob/slice\"\u003eFile.API\u003c/a\u003e对文件进行切割\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-typescript\"\u003eexport function sliceFile(file: File, baseSize = 1): Blob[] {\n  const chunkSize = baseSize * 1024 * 1024;\n  const chunks: Blob[] = [];\n  let startPos = 0;\n  while (startPos \u0026#x3C; file.size) {\n    chunks.push(file.slice(startPos, startPos + chunkSize));\n    startPos += chunkSize;\n  }\n  return chunks;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e获取到文件分片后的 Blob 数组后并不能直接用于计算分片 hash, 还需要将它们转成 ArrayBuffer 数组。\u003c/p\u003e\n\u003cp\u003e可以通过以下两种方式进行转换：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003ca href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/FileReader\"\u003eFileReader\u003c/a\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\u003cpre\u003e\u003ccode class=\"language-typescript\"\u003eexport async function getArrayBufFromBlobs(chunks: Blob[]): Promise\u0026#x3C;ArrayBuffer[]\u003e {\n  async function readAsArrayBuffer(file: Blob) {\n    return new Promise\u0026#x3C;ArrayBuffer\u003e((rs) =\u003e {\n      const fileReader = new FileReader()\n      fileReader.onload = (e) =\u003e rs(e.target!.result as ArrayBuffer)\n      fileReader.readAsArrayBuffer(file)\n    })\n  }\n  return await Promise.all(chunks.map((chunk: Blob) =\u003e readAsArrayBuffer(chunk)))\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003col start=\"2\"\u003e\n\u003cli\u003e\u003ca href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Blob/arrayBuffer\"\u003eBlob.ArrayBuff\u003c/a\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\u003cpre\u003e\u003ccode class=\"language-typescript\"\u003eexport async function getArrayBufFromBlobs(chunks: Blob[]): Promise\u0026#x3C;ArrayBuffer[]\u003e {\n  return Promise.all(chunks.map(chunk =\u003e chunk.arrayBuffer()))\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cblockquote\u003e\n\u003cp\u003e遗留：是否需要将分片过程放到 WebWorker 中, 以避免阻塞主线程\u003c/p\u003e\n\u003cp\u003eTips: \u003ca href=\"https://www.cnblogs.com/penghuwan/p/12053775.html\"\u003e前端的二进制家族：Blob 与 ArrayBuffer\u003c/a\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch3 id=\"2-计算分片-hash\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#2-计算分片-hash\"\u003e\u003cspan class=\"icon icon-link\"\u003e\u003c/span\u003e\u003c/a\u003e2. 计算分片 Hash\u003c/h3\u003e\n\u003ch4 id=\"21-目标\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#21-目标\"\u003e\u003cspan class=\"icon icon-link\"\u003e\u003c/span\u003e\u003c/a\u003e2.1 目标\u003c/h4\u003e\n\u003cp\u003e使用文件分片的 Hash 来标识文件分片, 用来判断这个分片是否已经上传过了\u003c/p\u003e\n\u003ch4 id=\"22-使用-promiseall-处理\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#22-使用-promiseall-处理\"\u003e\u003cspan class=\"icon icon-link\"\u003e\u003c/span\u003e\u003c/a\u003e2.2 使用 Promise.all 处理\u003c/h4\u003e\n\u003cp\u003e使用 \u003ca href=\"https://www.npmjs.com/package/hash-wasm\"\u003ehash-wasm\u003c/a\u003e 对分片进行 Hash 计算\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-typescript\"\u003eimport { crc32, md5 } from 'hash-wasm';\n\nexport async function singleChunkProcessor(\n  chunkBlob: Blob,\n  strategy: Strategy\n) {\n  const arrayBuffer = await chunkBlob.arrayBuffer();\n  const unit8Array = new Uint8Array(arrayBuffer);\n  return strategy === Strategy.md5 || strategy === Strategy.mixed\n    ? [await md5(unit8Array)]\n    : [await crc32(unit8Array)];\n}\n\nexport async function getChunksHashWithPromise(chunksBlob: Blob[]) {\n  let chunksHash: string[] = [];\n\n  await Promise.all(\n    chunksBlob.map((v) =\u003e {\n      return singleChunkProcessor(v, Strategy.crc32);\n    })\n  ).then((res) =\u003e {\n    chunksHash = res.flat();\n  });\n\n  return chunksHash;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch4 id=\"23-使用-web-workers\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#23-使用-web-workers\"\u003e\u003cspan class=\"icon icon-link\"\u003e\u003c/span\u003e\u003c/a\u003e2.3 使用 Web Workers\u003c/h4\u003e\n\u003cp\u003e由于计算文件分片 Hash 是一个 CPU 密集型任务, 直接在主线程中计算 hash 必定会导致 UI 卡死, 考虑做以下几点优化：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e放到 \u003ca href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Web_Workers_API/Using_web_workers\"\u003eWebWorker\u003c/a\u003e 中计算 Hash。并且，ArrayBuffer 是可 Transfer 的对象, 在主线程与 Worker 线程通信时, 可以通过移交控制权的方式通信, 避免线程通信引起的结构化克隆\u003c/li\u003e\n\u003cli\u003e分片之间的 Hash 计算没有关联, 而 WebWorker 可以用来开额外的计算线程, 考虑基于 WebWorker 实现线程池(WorkerPool)来加速计算分片 Hash\u003c/li\u003e\n\u003cli\u003e当文件较大时计算使用分片的 MD5值作为 Hash 计算速度仍然较慢, 但分片的 hash 其实只是为了标识分片, 对于唯一性要求并不高, 考虑在文件较大的场景下使用 CRC32 值作为分片的 Hash。CRC32的十六进制表示只有8位(MD5有32位), 且 CPU 对计算 CRC32 有硬件加速, 速度会比计算 MD5 快得多\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3 id=\"3-计算文件-hash\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#3-计算文件-hash\"\u003e\u003cspan class=\"icon icon-link\"\u003e\u003c/span\u003e\u003c/a\u003e3. 计算文件 Hash\u003c/h3\u003e\n\u003ch4 id=\"31-目标\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#31-目标\"\u003e\u003cspan class=\"icon icon-link\"\u003e\u003c/span\u003e\u003c/a\u003e3.1 目标\u003c/h4\u003e\n\u003cp\u003e计算文件的 Hash 用来标识这个文件是否已上传\u003c/p\u003e\n\u003ch4 id=\"32-存在的问题与解决思路\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#32-存在的问题与解决思路\"\u003e\u003cspan class=\"icon icon-link\"\u003e\u003c/span\u003e\u003c/a\u003e3.2 存在的问题与解决思路\u003c/h4\u003e\n\u003cp\u003e计算全部文件的 hash 效率过低，考虑使用以下两种方案之一\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e使用 \u003ca href=\"https://www.infoq.cn/article/lwlcldgjyc7lye95ewl8\"\u003ewasm\u003c/a\u003e: \u003ca href=\"https://juejin.cn/post/7129446744080777224\"\u003ehttps://juejin.cn/post/7129446744080777224\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e使用 MerkleTree(默克尔树) 的树根 hash 作为文件的 hash: \u003ca href=\"https://juejin.cn/post/7354362021428117519#heading-6\"\u003ehttps://juejin.cn/post/7354362021428117519#heading-6\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"4上传文件分片\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#4上传文件分片\"\u003e\u003cspan class=\"icon icon-link\"\u003e\u003c/span\u003e\u003c/a\u003e4.上传文件分片\u003c/h3\u003e\n\u003ch4 id=\"41-目标\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#41-目标\"\u003e\u003cspan class=\"icon icon-link\"\u003e\u003c/span\u003e\u003c/a\u003e4.1 目标\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e实现文件分片的并发上传\u003c/li\u003e\n\u003cli\u003e实现中止以及继续上传文件分片\u003c/li\u003e\n\u003cli\u003e实时展示文件上传进度\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4 id=\"42-实现文件分片的并发上传\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#42-实现文件分片的并发上传\"\u003e\u003cspan class=\"icon icon-link\"\u003e\u003c/span\u003e\u003c/a\u003e4.2 实现文件分片的并发上传\u003c/h4\u003e\n\u003cp\u003e实现 PromisePool 来控制请求的发送：\u003ca href=\"https://juejin.cn/post/7353106546827624463#heading-23\"\u003ehttps://juejin.cn/post/7353106546827624463#heading-23\u003c/a\u003e\u003c/p\u003e\n\u003ch3 id=\"展示上传进度\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#展示上传进度\"\u003e\u003cspan class=\"icon icon-link\"\u003e\u003c/span\u003e\u003c/a\u003e展示上传进度\u003c/h3\u003e\n\u003cp\u003etodo...\u003c/p\u003e\n\u003ch2 id=\"服务端-part\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#服务端-part\"\u003e\u003cspan class=\"icon icon-link\"\u003e\u003c/span\u003e\u003c/a\u003e服务端 Part\u003c/h2\u003e\n\u003ch3 id=\"getsuccesschunks\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#getsuccesschunks\"\u003e\u003cspan class=\"icon icon-link\"\u003e\u003c/span\u003e\u003c/a\u003eGetSuccessChunks\u003c/h3\u003e\n\u003cp\u003e通过文件 hash 判断当前文件是否存在上传记录\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e未上传\u003c/li\u003e\n\u003cli\u003e部分上传：通过 minio client 提供的接口判断当前文件上传过的 chunks\u003c/li\u003e\n\u003cli\u003e上传完成\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"newmultipart\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#newmultipart\"\u003e\u003cspan class=\"icon icon-link\"\u003e\u003c/span\u003e\u003c/a\u003eNewMultipart\u003c/h3\u003e\n\u003cp\u003e文件未上传的情况下调用该请求，向数据库中插入一条记录\u003c/p\u003e\n\u003ch3 id=\"getmultipartuploadurl\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#getmultipartuploadurl\"\u003e\u003cspan class=\"icon icon-link\"\u003e\u003c/span\u003e\u003c/a\u003eGetMultipartUploadUrl\u003c/h3\u003e\n\u003cp\u003e通过 minio client 生成上传部分 chunks 的 url\u003c/p\u003e\n\u003ch3 id=\"updatefilechunk\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#updatefilechunk\"\u003e\u003cspan class=\"icon icon-link\"\u003e\u003c/span\u003e\u003c/a\u003eUpdateFileChunk\u003c/h3\u003e\n\u003cp\u003e更新 MySQL 记录中的 completed_parts 字段\u003c/p\u003e\n\u003ch3 id=\"completemultipart\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#completemultipart\"\u003e\u003cspan class=\"icon icon-link\"\u003e\u003c/span\u003e\u003c/a\u003eCompleteMultipart\u003c/h3\u003e\n\u003cp\u003e通过 minio client 提供的接口合并之前上传过的文件分片并标记数据库中记录为上传成功\u003c/p\u003e\n\u003ch2 id=\"todo\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#todo\"\u003e\u003cspan class=\"icon icon-link\"\u003e\u003c/span\u003e\u003c/a\u003eTodo\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003e暂停上传功能\u003c/li\u003e\n\u003cli\u003e关闭应用后重启保留上传进度\u003c/li\u003e\n\u003cli\u003e分布式服务\u003c/li\u003e\n\u003cli\u003e分片 Hash 判断文件分片是否上传\u003c/li\u003e\n\u003cli\u003e多文件同时上传\u003c/li\u003e\n\u003cli\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\u003cblockquote\u003e\n\u003cp\u003e参考至:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003ca href=\"https://juejin.cn/post/7353106546827624463\"\u003ehttps://juejin.cn/post/7353106546827624463\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://www.cnblogs.com/xiahj/p/vue-simple-uploader.html\"\u003ehttps://www.cnblogs.com/xiahj/p/vue-simple-uploader.html\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://juejin.cn/post/6844904046436843527\"\u003ehttps://juejin.cn/post/6844904046436843527\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://www.infoq.cn/article/lwlcldgjyc7lye95ewl8\"\u003ehttps://www.infoq.cn/article/lwlcldgjyc7lye95ewl8\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://juejin.cn/post/7129446744080777224\"\u003ehttps://juejin.cn/post/7129446744080777224\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://juejin.cn/post/7354362021428117519\"\u003ehttps://juejin.cn/post/7354362021428117519\u003c/a\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/blockquote\u003e","theme":"orange","tag":null}},"__N_SSG":true},"page":"/posts/[slug]","query":{"slug":"大文件分片上传实践"},"buildId":"YJP6rl8scvGOq7wuL0OEb","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>