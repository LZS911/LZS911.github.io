<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><link rel="apple-touch-icon" sizes="180x180" href="/favicon/apple-touch-icon.png"/><link rel="icon" type="image/png" sizes="32x32" href="/favicon/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="16x16" href="/favicon/favicon-16x16.png"/><link rel="manifest" href="/favicon/site.webmanifest"/><link rel="mask-icon" href="/favicon/safari-pinned-tab.svg" color="#000000"/><link rel="shortcut icon" href="/favicon/favicon.ico"/><meta name="msapplication-TileColor" content="#000000"/><meta name="msapplication-config" content="/favicon/browserconfig.xml"/><meta name="theme-color" content="#000"/><link rel="alternate" type="application/rss+xml" href="/feed.xml"/><meta property="og:image" content="https://og-image.vercel.app/Next.js%20Blog%20Starter%20Example.png?theme=light&amp;md=1&amp;fontSize=100px&amp;images=https%3A%2F%2Fassets.vercel.com%2Fimage%2Fupload%2Ffront%2Fassets%2Fdesign%2Fnextjs-black-logo.svg"/><title>work review | Ai.Haibara codes</title><meta name="next-head-count" content="14"/><link rel="preload" href="/_next/static/css/8681f744d5932be6.css" as="style"/><link rel="stylesheet" href="/_next/static/css/8681f744d5932be6.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-8fa1640cc84ba8fe.js" defer=""></script><script src="/_next/static/chunks/framework-3b5a00d5d7e8d93b.js" defer=""></script><script src="/_next/static/chunks/main-59a90320855f5cf5.js" defer=""></script><script src="/_next/static/chunks/pages/_app-f46e289d7ac5e197.js" defer=""></script><script src="/_next/static/chunks/799-575b46febca3af7d.js" defer=""></script><script src="/_next/static/chunks/399-cac0cd8ed02bf02a.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bslug%5D-e2afa3a98c674f72.js" defer=""></script><script src="/_next/static/S9qTAxmYJZjk95IvOmcu0/_buildManifest.js" defer=""></script><script src="/_next/static/S9qTAxmYJZjk95IvOmcu0/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="min-h-screen"><header class="text-white bg-black drop-shadow-2xl"><div class="mx-auto my-0 max-w-[960px] py-6 px-4 flex items-center"><div class="flex items-center"><img alt="Ai.Haibara" src="/assets/blog/authors/haibara_2.jpg" width="100" height="100" decoding="async" data-nimg="1" class=" rounded-full" loading="lazy" style="color:transparent"/></div><div class="ml-6"><a class=" font-bold text-3xl" href="/">Ai.Haibara codes</a><div class="mt-2"><a class="p-1 rounded-sm text-xl mr-2 hover:border-b-2 border-indigo" href="/">Home</a><a class="p-1 rounded-sm text-xl mr-2 hover:border-b-2 border-indigo" href="/projects">Projects</a><a class="p-1 rounded-sm text-xl mr-2 hover:border-b-2 border-indigo" href="/talks">Talks</a><a class="p-1 rounded-sm text-xl mr-2 hover:border-b-2 border-indigo" href="/blogs">Blogs</a></div></div></div></header><main class="p-6 flex justify-center"><article><div class="flex justify-center font-[Arial] max-w-[864px] text-center"><h1 class="text-5xl font-bold bg-indigo px-5 py-2 rounded-sm text-shadow-lg leading-[1.1]">work review</h1></div><time dateTime="2022-06-16" class="text-center block my-4 text-sm opacity-60">June	16, 2022</time><section><div class="markdown-body-qklhk-chocolate max-w-3xl"><h2 id="前端代码覆盖率"><a aria-hidden="true" tabindex="-1" href="#前端代码覆盖率"><span class="icon icon-link"></span></a><a href="https://juejin.cn/post/7022928631756226591">前端代码覆盖率</a></h2>
<p>实现代码插桩插件: <code>babel-plugin-istanbul</code></p>
<h3 id="具体方案"><a aria-hidden="true" tabindex="-1" href="#具体方案"><span class="icon icon-link"></span></a>具体方案</h3>
<ol>
<li>
<p>确定当前环境是否需要收集代码覆盖率</p>
</li>
<li>
<p>加载 <code>babel-plugin-istanbul</code> 插件, 获得覆盖率(一般保存在 <code>window.__coverage__</code> 中)</p>
</li>
<li>
<p>上传覆盖率到服务端</p>
</li>
<li>
<p>服务端展示</p>
</li>
</ol>
<p>这里重点主要放在前三步, 实现方案</p>
<h3 id="webpack-项目方案"><a aria-hidden="true" tabindex="-1" href="#webpack-项目方案"><span class="icon icon-link"></span></a><code>webpack</code> 项目方案</h3>
<ol>
<li>
<p>在启动服务或者打包时(<code>start、build</code>)时添加自定义 <code>options</code>, 然后再通过 <code>process.argv</code> 判断是否存在该 <code>options</code></p>
<pre><code class="language-json">"scripts": {
   "coverage-build": "node scripts/build.js --coverageReport=true",
}
</code></pre>
</li>
<li>
<p>正常的加载 <code>babel</code> 插件模式, 需要判断当前环境是否为收集覆盖率环境</p>
<pre><code class="language-javascript">if (isCoverageReport) {
  babelPlugins.push([
    'istanbul',
    {
      exclude: ['./node_modules/*'],
    },
  ]);
}
</code></pre>
</li>
<li>
<p>轮询调用接口上传 <code>window.__coverage__</code> 中的内容, 同样需要注意的是只有在收集覆盖率环境中才会执行这段代码</p>
<pre><code class="language-javascript">module.exports = {
  entry: [
    isCoverageReport &#x26;&#x26; require.resolve('../coverageScript'), //上传覆盖率代码
    appIndexJs, //项目入口文件
  ],
};
</code></pre>
</li>
</ol>
<h3 id="vite-项目方案"><a aria-hidden="true" tabindex="-1" href="#vite-项目方案"><span class="icon icon-link"></span></a><code>vite</code> 项目方案</h3>
<ol>
<li>
<p>利用 <code>vite</code> 的 <a href="https://cn.vitejs.dev/guide/env-and-mode.html">mode options</a>, 指定当前环境的 <code>mode</code>, 在 <code>vite.config.js</code> 中判断当前 <code>mode</code>.</p>
<pre><code class="language-javascript">export default defineConfig((config) => {
  var isCoverage = config.mode === 'coverage';
  var isDebug = config.mode === 'development';
  var isProduction = config.mode === 'production';

  return {
    //....
  }
}
</code></pre>
</li>
<li>
<p>同样是正常的加载 <code>babel</code> 插件</p>
<pre><code class="language-javascript">//....
return {
  //...
  plugins: [
    react({
      babel: {
        plugins: isCoverage ? ['istanbul'] : [],
      },
    }),
  ],
};
</code></pre>
</li>
<li>
<p>虽然 <code>vite.config</code> 中也提供了 <code>rollupOptions</code> , 能够类似 <code>webpack</code> 中自定义指定入口文件, 但是 <code>vite</code> 的开发服务器使用的 <code>esBuild</code>, 这样便没法使用开发环境测试在不同的环境中是否有加载上传覆盖率的代码. 所以, 这里可以换个思路使用条件编译来实现该需求.</p>
<p>一个简单的 <code>vite</code> 实现条件编译的插件 <a href="https://www.npmjs.com/package/vite-plugin-conditional-compile">https://www.npmjs.com/package/vite-plugin-conditional-compile</a></p>
<p>最后只需要在项目入口文件中添加该段代码即可</p>
<pre><code class="language-javascript">/* IFTRUE_isCoverage */
import '../scripts/coverageScript';
/*FITRUE_isCoverage*/
</code></pre>
</li>
</ol>
<h2 id="鼠标移到表格的操作列的更多按钮的下拉时依然保持-hover-效果"><a aria-hidden="true" tabindex="-1" href="#鼠标移到表格的操作列的更多按钮的下拉时依然保持-hover-效果"><span class="icon icon-link"></span></a>鼠标移到表格的操作列的更多按钮的下拉时依然保持 hover 效果</h2>
<p>主要思路: 将下拉菜单与表格当前行绑定, 下拉菜单打开时给当前行设置 class, 让其具有 hover 效果.</p>
<p>第一个思路:</p>
<p>设置一个 <code>currentHoverData</code> 的状态, 当 <code>dropdown</code> 打开时设置成当前行数据, 关闭时置成 <code>null</code>, 再通过表格的 <code>rowClassName</code> 来给每一行数据设置一个 <code>class</code>, 若当前行数据与 <code>currentHoverData</code> 能匹配上则给其具有 <code>hover</code> 效果的 <code>class</code>, 来实现鼠标移走后也能有 <code>hover</code> 效果.</p>
<p>弊端:</p>
<ol>
<li>显而易见的缺陷是当表格数据量过大时, 每一行数据都要去进行计算, 造成性能问题.</li>
<li>因为下拉菜单的组件中并没有办法获取当前行数据, 只能去修改所有页面的 <code>tableHeader.tsx</code>文件, 这也太蠢了...</li>
</ol>
<p>第二个思路:</p>
<p>主题思路没有发生变化, 主要的变化是怎样将当前打开的这个下拉菜单与当前行绑定. 这里使用的是通过 <code>element</code> 之间的联系来进行绑定.</p>
<p>找到下拉菜单与表格行的公共元素, 即触发下拉菜单显示的按钮, 它是存在于表格行中的. 通过找该元素的第一个节点类型是 <code>TR</code> 的父节点, 该元素即为需要显示 <code>hover</code> 效果的当前列, 后续给其添加 <code>class</code> 即可.</p>
<p>在处理这个需求一直想的是怎样通过 <strong>数据</strong> 来将下拉菜单与表格行数据进行绑定, 并没有去考虑使用 <code>javascript</code> 的一些操作元素的原生方法来进行处理, 于是陷入了一个死胡同...</p></div></section></article></main><footer class="bg-neutral-50 border-t border-neutral-200 text-center text-xs opacity-50 py-4">© 2022,<!-- --> <a rel="noopener noreferrer" class="hover:underline hover:bg-indigo" href="https://github.com/LZS911" target="_blank">LZS_911</a>, build with<!-- --> <a rel="noopener noreferrer" class="underline hover:bg-indigo" href="https://nextjs.org/" target="_blank">Next.js</a> <!-- -->and<!-- --> <a rel="noopener noreferrer" class="underline hover:bg-indigo" href="https://pages.github.com/?(null)" target="_blank">GitHub Pages</a></footer></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"work review","date":"2022-06-16","slug":"work-review","author":"LZS_911","content":"\u003ch2 id=\"前端代码覆盖率\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#前端代码覆盖率\"\u003e\u003cspan class=\"icon icon-link\"\u003e\u003c/span\u003e\u003c/a\u003e\u003ca href=\"https://juejin.cn/post/7022928631756226591\"\u003e前端代码覆盖率\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003e实现代码插桩插件: \u003ccode\u003ebabel-plugin-istanbul\u003c/code\u003e\u003c/p\u003e\n\u003ch3 id=\"具体方案\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#具体方案\"\u003e\u003cspan class=\"icon icon-link\"\u003e\u003c/span\u003e\u003c/a\u003e具体方案\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e确定当前环境是否需要收集代码覆盖率\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e加载 \u003ccode\u003ebabel-plugin-istanbul\u003c/code\u003e 插件, 获得覆盖率(一般保存在 \u003ccode\u003ewindow.__coverage__\u003c/code\u003e 中)\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e上传覆盖率到服务端\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e服务端展示\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e这里重点主要放在前三步, 实现方案\u003c/p\u003e\n\u003ch3 id=\"webpack-项目方案\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#webpack-项目方案\"\u003e\u003cspan class=\"icon icon-link\"\u003e\u003c/span\u003e\u003c/a\u003e\u003ccode\u003ewebpack\u003c/code\u003e 项目方案\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e在启动服务或者打包时(\u003ccode\u003estart、build\u003c/code\u003e)时添加自定义 \u003ccode\u003eoptions\u003c/code\u003e, 然后再通过 \u003ccode\u003eprocess.argv\u003c/code\u003e 判断是否存在该 \u003ccode\u003eoptions\u003c/code\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-json\"\u003e\"scripts\": {\n   \"coverage-build\": \"node scripts/build.js --coverageReport=true\",\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e正常的加载 \u003ccode\u003ebabel\u003c/code\u003e 插件模式, 需要判断当前环境是否为收集覆盖率环境\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003eif (isCoverageReport) {\n  babelPlugins.push([\n    'istanbul',\n    {\n      exclude: ['./node_modules/*'],\n    },\n  ]);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e轮询调用接口上传 \u003ccode\u003ewindow.__coverage__\u003c/code\u003e 中的内容, 同样需要注意的是只有在收集覆盖率环境中才会执行这段代码\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003emodule.exports = {\n  entry: [\n    isCoverageReport \u0026#x26;\u0026#x26; require.resolve('../coverageScript'), //上传覆盖率代码\n    appIndexJs, //项目入口文件\n  ],\n};\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3 id=\"vite-项目方案\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#vite-项目方案\"\u003e\u003cspan class=\"icon icon-link\"\u003e\u003c/span\u003e\u003c/a\u003e\u003ccode\u003evite\u003c/code\u003e 项目方案\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e利用 \u003ccode\u003evite\u003c/code\u003e 的 \u003ca href=\"https://cn.vitejs.dev/guide/env-and-mode.html\"\u003emode options\u003c/a\u003e, 指定当前环境的 \u003ccode\u003emode\u003c/code\u003e, 在 \u003ccode\u003evite.config.js\u003c/code\u003e 中判断当前 \u003ccode\u003emode\u003c/code\u003e.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003eexport default defineConfig((config) =\u003e {\n  var isCoverage = config.mode === 'coverage';\n  var isDebug = config.mode === 'development';\n  var isProduction = config.mode === 'production';\n\n  return {\n    //....\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e同样是正常的加载 \u003ccode\u003ebabel\u003c/code\u003e 插件\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003e//....\nreturn {\n  //...\n  plugins: [\n    react({\n      babel: {\n        plugins: isCoverage ? ['istanbul'] : [],\n      },\n    }),\n  ],\n};\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e虽然 \u003ccode\u003evite.config\u003c/code\u003e 中也提供了 \u003ccode\u003erollupOptions\u003c/code\u003e , 能够类似 \u003ccode\u003ewebpack\u003c/code\u003e 中自定义指定入口文件, 但是 \u003ccode\u003evite\u003c/code\u003e 的开发服务器使用的 \u003ccode\u003eesBuild\u003c/code\u003e, 这样便没法使用开发环境测试在不同的环境中是否有加载上传覆盖率的代码. 所以, 这里可以换个思路使用条件编译来实现该需求.\u003c/p\u003e\n\u003cp\u003e一个简单的 \u003ccode\u003evite\u003c/code\u003e 实现条件编译的插件 \u003ca href=\"https://www.npmjs.com/package/vite-plugin-conditional-compile\"\u003ehttps://www.npmjs.com/package/vite-plugin-conditional-compile\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e最后只需要在项目入口文件中添加该段代码即可\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003e/* IFTRUE_isCoverage */\nimport '../scripts/coverageScript';\n/*FITRUE_isCoverage*/\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2 id=\"鼠标移到表格的操作列的更多按钮的下拉时依然保持-hover-效果\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#鼠标移到表格的操作列的更多按钮的下拉时依然保持-hover-效果\"\u003e\u003cspan class=\"icon icon-link\"\u003e\u003c/span\u003e\u003c/a\u003e鼠标移到表格的操作列的更多按钮的下拉时依然保持 hover 效果\u003c/h2\u003e\n\u003cp\u003e主要思路: 将下拉菜单与表格当前行绑定, 下拉菜单打开时给当前行设置 class, 让其具有 hover 效果.\u003c/p\u003e\n\u003cp\u003e第一个思路:\u003c/p\u003e\n\u003cp\u003e设置一个 \u003ccode\u003ecurrentHoverData\u003c/code\u003e 的状态, 当 \u003ccode\u003edropdown\u003c/code\u003e 打开时设置成当前行数据, 关闭时置成 \u003ccode\u003enull\u003c/code\u003e, 再通过表格的 \u003ccode\u003erowClassName\u003c/code\u003e 来给每一行数据设置一个 \u003ccode\u003eclass\u003c/code\u003e, 若当前行数据与 \u003ccode\u003ecurrentHoverData\u003c/code\u003e 能匹配上则给其具有 \u003ccode\u003ehover\u003c/code\u003e 效果的 \u003ccode\u003eclass\u003c/code\u003e, 来实现鼠标移走后也能有 \u003ccode\u003ehover\u003c/code\u003e 效果.\u003c/p\u003e\n\u003cp\u003e弊端:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e显而易见的缺陷是当表格数据量过大时, 每一行数据都要去进行计算, 造成性能问题.\u003c/li\u003e\n\u003cli\u003e因为下拉菜单的组件中并没有办法获取当前行数据, 只能去修改所有页面的 \u003ccode\u003etableHeader.tsx\u003c/code\u003e文件, 这也太蠢了...\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e第二个思路:\u003c/p\u003e\n\u003cp\u003e主题思路没有发生变化, 主要的变化是怎样将当前打开的这个下拉菜单与当前行绑定. 这里使用的是通过 \u003ccode\u003eelement\u003c/code\u003e 之间的联系来进行绑定.\u003c/p\u003e\n\u003cp\u003e找到下拉菜单与表格行的公共元素, 即触发下拉菜单显示的按钮, 它是存在于表格行中的. 通过找该元素的第一个节点类型是 \u003ccode\u003eTR\u003c/code\u003e 的父节点, 该元素即为需要显示 \u003ccode\u003ehover\u003c/code\u003e 效果的当前列, 后续给其添加 \u003ccode\u003eclass\u003c/code\u003e 即可.\u003c/p\u003e\n\u003cp\u003e在处理这个需求一直想的是怎样通过 \u003cstrong\u003e数据\u003c/strong\u003e 来将下拉菜单与表格行数据进行绑定, 并没有去考虑使用 \u003ccode\u003ejavascript\u003c/code\u003e 的一些操作元素的原生方法来进行处理, 于是陷入了一个死胡同...\u003c/p\u003e","ogImage":{"url":"/assets/blog/image/cover.jpg"},"coverImage":"/assets/blog/image/cover.jpg","theme":"qklhk-chocolate","tag":["istanbul","babel","javascript"]}},"__N_SSG":true},"page":"/posts/[slug]","query":{"slug":"work-review"},"buildId":"S9qTAxmYJZjk95IvOmcu0","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>