<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><link rel="apple-touch-icon" sizes="180x180" href="/favicon/apple-touch-icon.png"/><link rel="icon" type="image/png" sizes="32x32" href="/favicon/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="16x16" href="/favicon/favicon-16x16.png"/><link rel="manifest" href="/favicon/site.webmanifest"/><link rel="mask-icon" href="/favicon/safari-pinned-tab.svg" color="#000000"/><link rel="shortcut icon" href="/favicon/favicon.ico"/><meta name="msapplication-TileColor" content="#000000"/><meta name="msapplication-config" content="/favicon/browserconfig.xml"/><meta name="theme-color" content="#000"/><link rel="alternate" type="application/rss+xml" href="/feed.xml"/><meta property="og:image" content="https://og-image.vercel.app/Next.js%20Blog%20Starter%20Example.png?theme=light&amp;md=1&amp;fontSize=100px&amp;images=https%3A%2F%2Fassets.vercel.com%2Fimage%2Fupload%2Ffront%2Fassets%2Fdesign%2Fnextjs-black-logo.svg"/><title>Node.js-Stream学习记录 | Ai.Haibara codes</title><meta name="next-head-count" content="14"/><link rel="preload" href="/_next/static/css/a5eda337cc81d9ab.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a5eda337cc81d9ab.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee7e63bc15b31913.js" defer=""></script><script src="/_next/static/chunks/framework-3b5a00d5d7e8d93b.js" defer=""></script><script src="/_next/static/chunks/main-319e858aa81ca629.js" defer=""></script><script src="/_next/static/chunks/pages/_app-91d7f786791773ad.js" defer=""></script><script src="/_next/static/chunks/799-575b46febca3af7d.js" defer=""></script><script src="/_next/static/chunks/642-f55f53346f993b53.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bslug%5D-23138caee0f75470.js" defer=""></script><script src="/_next/static/yIbYpMrVODDFyEXyLGSSq/_buildManifest.js" defer=""></script><script src="/_next/static/yIbYpMrVODDFyEXyLGSSq/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="min-h-screen"><header class="text-white bg-black drop-shadow-2xl"><div class="mx-auto my-0 max-w-[960px] py-6 px-4 flex items-center"><div class="flex items-center"><img alt="Ai.Haibara" src="/assets/blog/authors/haibara_2.jpg" width="100" height="100" decoding="async" data-nimg="1" class=" rounded-full" loading="lazy" style="color:transparent"/></div><div class="ml-6"><a class=" font-bold text-3xl" href="/">Ai.Haibara codes</a><div class="mt-2"><a class="p-1 rounded-sm text-xl mr-2 hover:border-b-2 border-indigo" href="/">Home</a><a class="p-1 rounded-sm text-xl mr-2 hover:border-b-2 border-indigo" href="/projects">Projects</a><a class="p-1 rounded-sm text-xl mr-2 hover:border-b-2 border-indigo" href="/talks">Talks</a><a class="p-1 rounded-sm text-xl mr-2 hover:border-b-2 border-indigo" href="/blogs">Blogs</a></div></div></div></header><main class="p-6 flex justify-center"><article><div class="flex justify-center font-[Arial] max-w-[864px] text-center"><h1 class="text-5xl font-bold bg-indigo px-5 py-2 rounded-sm text-shadow-lg leading-[1.1]">Node.js-Stream学习记录</h1></div><time dateTime="2024-12-20" class="text-center block my-4 text-sm opacity-60">December	20, 2024</time><section><div class="markdown-body-fancy max-w-3xl"><h2 id="什么是-stream流"><a aria-hidden="true" tabindex="-1" href="#什么是-stream流"><span class="icon icon-link"></span></a>什么是 Stream（流）</h2>
<p>先看一下 Node 官网中对于 Stream 的介绍</p>
<blockquote>
<p>A stream is an abstract interface for working with streaming data in Node.js.</p>
</blockquote>
<p>其实我们写的 Node.js 代码经常会用到流。</p>
<p>来看一段代码</p>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// src/test.mjs</span>
<span class="hljs-keyword">import</span> http <span class="hljs-keyword">from</span> <span class="hljs-string">'node:http'</span>;
<span class="hljs-keyword">import</span> fs <span class="hljs-keyword">from</span> <span class="hljs-string">'node:fs'</span>;
<span class="hljs-keyword">import</span> path <span class="hljs-keyword">from</span> <span class="hljs-string">'node:path'</span>;

<span class="hljs-keyword">const</span> server = http.<span class="hljs-title function_">createServer</span>(<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">req, res</span>) {
  <span class="hljs-keyword">const</span> data = fs.<span class="hljs-title function_">readFileSync</span>(
    path.<span class="hljs-title function_">join</span>(<span class="hljs-keyword">import</span>.<span class="hljs-property">meta</span>.<span class="hljs-property">dirname</span>, <span class="hljs-string">'..'</span>, <span class="hljs-string">'package.json'</span>),
    <span class="hljs-string">'utf-8'</span>
  );
  res.<span class="hljs-title function_">end</span>(data);
});

server.<span class="hljs-title function_">listen</span>(<span class="hljs-number">8000</span>);
</code></pre>
<p>我们跑了个 http 服务。</p>
<p>用 fs.readFileSync 读取项目中 package.json 的内容返回。</p>
<p>启动服务后使用 curl 访问下</p>
<pre><code class="hljs language-shell">curl -i http://localhost:8000
</code></pre>
<p><img src="https://github.com/user-attachments/assets/775ccae6-26e8-4149-abbe-8244ce84b035" alt="image"></p>
<p>因为是全部读完返回的，所以可以知道 Content-Length，也就是响应体的长度。</p>
<p>当文件比较小的时候，这样读取、返回没啥问题。</p>
<p>那如果文件非常大呢？</p>
<p>比如有好几百 M，这时候全部读取完再返回是不是就合适了？</p>
<p>因为要等好久才能读取完文件，之后才有响应。</p>
<p>这就需要用到流了：</p>
<pre><code class="hljs language-typescript"><span class="hljs-comment">//更新 src/test.mjs</span>
<span class="hljs-keyword">import</span> http <span class="hljs-keyword">from</span> <span class="hljs-string">'node:http'</span>;
<span class="hljs-keyword">import</span> fs <span class="hljs-keyword">from</span> <span class="hljs-string">'node:fs'</span>;
<span class="hljs-keyword">import</span> path <span class="hljs-keyword">from</span> <span class="hljs-string">'node:path'</span>;

<span class="hljs-keyword">const</span> server = http.<span class="hljs-title function_">createServer</span>(<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">req, res</span>) {
  <span class="hljs-keyword">const</span> readStream = fs.<span class="hljs-title function_">createReadStream</span>(
    path.<span class="hljs-title function_">join</span>(<span class="hljs-keyword">import</span>.<span class="hljs-property">meta</span>.<span class="hljs-property">dirname</span>, <span class="hljs-string">'..'</span>, <span class="hljs-string">'package.json'</span>),
    <span class="hljs-string">'utf-8'</span>
  );
  readStream.<span class="hljs-title function_">pipe</span>(res);
});

server.<span class="hljs-title function_">listen</span>(<span class="hljs-number">8000</span>);
</code></pre>
<p><img src="https://github.com/user-attachments/assets/7d9096be-3d6b-4640-ac7d-09a3700b32b2" alt="image"></p>
<p>结果一样，但是因为现在是流式返回的，并不知道响应体的 Content-Length。</p>
<p>所以是用 Transfer-Encoding: chunked 的方式返回流式内容。</p>
<p>从服务器下载一个文件的时候，如何知道文件下载完了呢？</p>
<p>有两种方式：</p>
<p>一种是 header 里带上 Content-Length，浏览器下载到这个长度就结束。</p>
<p><img src="https://github.com/user-attachments/assets/05f39e48-2f39-4fdd-9c51-2a1f4736991e" alt="image"></p>
<p>另一种是设置 transfer-encoding:chunked，它是不固定长度的，服务器不断返回内容，直到返回一个空的内容代表结束。</p>
<p>比如这样：</p>
<pre><code class="hljs language-shell">5
Hello
1
,
5
World
1
!
0
</code></pre>
<p>这里分了 “Hello” “,” “World”“!” 这 4 个块，长度分别为 5、1、5、1</p>
<p>最后以一个长度为 0 的块代表传输结束。</p>
<p>这样，不管内容多少都可以分块返回，就不用指定 Content-Length 了。</p>
<p>这就是大文件的流式传输的原理，就是 transfer-encoding:chunked。</p>
<p>当然，这是 http 传输时的流，在用 shell 命令的时候，也经常会用到流：</p>
<p>比如</p>
<pre><code class="hljs language-shell">ls | grep pack
</code></pre>
<p><img src="https://github.com/user-attachments/assets/e7d69e47-5a8a-4717-b3e7-7251d5924dc6" alt="image"></p>
<p>ls 命令的输出流，作为 grep 命令的输入流。</p>
<p>当然，我们也可以把 grep 命令的输出流，作为 node 脚本的输入流。</p>
<pre><code class="hljs language-javascript"><span class="hljs-comment">//src/read.mjs</span>
process.<span class="hljs-property">stdin</span>.<span class="hljs-title function_">on</span>(<span class="hljs-string">'readable'</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
    <span class="hljs-keyword">const</span> buf = process.<span class="hljs-property">stdin</span>.<span class="hljs-title function_">read</span>();
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(buf?.<span class="hljs-title function_">toString</span>(<span class="hljs-string">'utf-8'</span>));
});
</code></pre>
<p>process.stdin 就是输入流，监听 readable 事件，用 read 读取数据。</p>
<p>执行一下</p>
<pre><code class="hljs language-shell">ls | grep pack | node src/read.mjs
</code></pre>
<p><img src="https://github.com/user-attachments/assets/e51ce88c-f842-4e5c-8758-4d203085a0ac" alt="image"></p>
<p>可以看到，我们的 node 脚本接收到了 grep 的输出流作为输入流。</p>
<p>这就是管道 pipe 的含义。</p>
<p>综上，可以小结下我们对流的认识：</p>
<p><strong>流就是分段的传输内容，比如从服务端像浏览器返回响应数据的流，读取文件的流等。</strong></p>
<p><strong>流和流之间可以通过管道 pipe 连接，上个流的输出作为下个流的输入。</strong></p>
<h2 id="流的类型"><a aria-hidden="true" tabindex="-1" href="#流的类型"><span class="icon icon-link"></span></a>流的类型</h2>
<p>在 node 里，流一共有 4 种：可读流 Readable、可写流 Writable、双工流 Duplex、转换流 Transform。</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">import</span> stream <span class="hljs-keyword">from</span> <span class="hljs-string">'node:stream'</span>;

<span class="hljs-comment">// 可读流</span>
<span class="hljs-keyword">const</span> <span class="hljs-title class_">Readable</span> = stream.<span class="hljs-property">Readable</span>;
<span class="hljs-comment">// 可写流</span>
<span class="hljs-keyword">const</span> <span class="hljs-title class_">Writable</span> = stream.<span class="hljs-property">Writable</span>;
<span class="hljs-comment">// 双工流</span>
<span class="hljs-keyword">const</span> <span class="hljs-title class_">Duplex</span> = stream.<span class="hljs-property">Duplex</span>;
<span class="hljs-comment">// 转换流</span>
<span class="hljs-keyword">const</span> <span class="hljs-title class_">Transform</span> = stream.<span class="hljs-property">Transform</span>;
</code></pre>
<p>其余的流都是基于这 4 种流封装出来的。</p>
<h3 id="readable"><a aria-hidden="true" tabindex="-1" href="#readable"><span class="icon icon-link"></span></a>Readable</h3>
<p>Readable 要实现 _read 方法，通过 push 返回具体的数据。</p>
<pre><code class="hljs language-javascript"><span class="hljs-comment">//readable.mjs</span>
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">Readable</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'node:stream'</span>;

<span class="hljs-keyword">const</span> readableStream = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Readable</span>();

readableStream.<span class="hljs-property">_read</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">push</span>(<span class="hljs-string">'阿门阿前一棵葡萄树，'</span>);
    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">push</span>(<span class="hljs-string">'阿东阿东绿的刚发芽，'</span>);
    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">push</span>(<span class="hljs-string">'阿东背着那重重的的壳呀，'</span>);
    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">push</span>(<span class="hljs-string">'一步一步地往上爬。'</span>)
    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">push</span>(<span class="hljs-literal">null</span>);
}

readableStream.<span class="hljs-title function_">on</span>(<span class="hljs-string">'data'</span>, <span class="hljs-function">(<span class="hljs-params">data</span>)=></span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data.<span class="hljs-title function_">toString</span>())
});

readableStream.<span class="hljs-title function_">on</span>(<span class="hljs-string">'end'</span>, <span class="hljs-function">() =></span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'done'</span>);
});
</code></pre>
<p>当 push 一个 null 时，就代表结束流。</p>
<p>执行一下</p>
<pre><code class="hljs language-shell">node src/readable.mjs
</code></pre>
<p><img src="https://github.com/user-attachments/assets/184fe685-1a0b-4a88-b846-c4ebe37a705c" alt="image"></p>
<p>创建 Readable 流也可以通过继承的方式：</p>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// src/readable2.mjs</span>
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">Readable</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'node:stream'</span>;

<span class="hljs-keyword">class</span> <span class="hljs-title class_">ReadableDong</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Readable</span> {

    <span class="hljs-title function_">_read</span>(<span class="hljs-params"></span>) {
        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">push</span>(<span class="hljs-string">'阿门阿前一棵葡萄树，'</span>);
        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">push</span>(<span class="hljs-string">'阿东阿东绿的刚发芽，'</span>);
        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">push</span>(<span class="hljs-string">'阿东背着那重重的的壳呀，'</span>);
        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">push</span>(<span class="hljs-string">'一步一步地往上爬。'</span>)
        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">push</span>(<span class="hljs-literal">null</span>);
    }

}

<span class="hljs-keyword">const</span> readableStream = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReadableDong</span>();

readableStream.<span class="hljs-title function_">on</span>(<span class="hljs-string">'data'</span>, <span class="hljs-function">(<span class="hljs-params">data</span>)=></span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data.<span class="hljs-title function_">toString</span>())
});

readableStream.<span class="hljs-title function_">on</span>(<span class="hljs-string">'end'</span>, <span class="hljs-function">() =></span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'done'</span>);
});

</code></pre>
<p><img src="https://github.com/user-attachments/assets/267137eb-e992-4c71-9bd3-3325e05a74a7" alt="image"></p>
<p>可读流是生成内容的，那么很自然可以和生成器结合：</p>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// src/readable3.mjs</span>

<span class="hljs-keyword">import</span> { <span class="hljs-title class_">Readable</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'node:stream'</span>;

<span class="hljs-keyword">class</span> <span class="hljs-title class_">ReadableDong</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Readable</span> {

    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">iterator</span>) {
        <span class="hljs-variable language_">super</span>();
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">iterator</span> = iterator;
    }

    <span class="hljs-title function_">_read</span>(<span class="hljs-params"></span>) {
        <span class="hljs-keyword">const</span> next = <span class="hljs-variable language_">this</span>.<span class="hljs-property">iterator</span>.<span class="hljs-title function_">next</span>();
        <span class="hljs-keyword">if</span>(next.<span class="hljs-property">done</span>) {
            <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">push</span>(<span class="hljs-literal">null</span>);
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">push</span>(next.<span class="hljs-property">value</span>)
        }
    }

}

<span class="hljs-keyword">function</span> *<span class="hljs-title function_">songGenerator</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">yield</span> <span class="hljs-string">'阿门阿前一棵葡萄树，'</span>;
    <span class="hljs-keyword">yield</span> <span class="hljs-string">'阿东阿东绿的刚发芽，'</span>;
    <span class="hljs-keyword">yield</span> <span class="hljs-string">'阿东背着那重重的的壳呀，'</span>;
    <span class="hljs-keyword">yield</span> <span class="hljs-string">'一步一步地往上爬。'</span>;
}

<span class="hljs-keyword">const</span> songIterator = <span class="hljs-title function_">songGenerator</span>();

<span class="hljs-keyword">const</span> readableStream = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReadableDong</span>(songIterator);

readableStream.<span class="hljs-title function_">on</span>(<span class="hljs-string">'data'</span>, <span class="hljs-function">(<span class="hljs-params">data</span>)=></span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data.<span class="hljs-title function_">toString</span>())
});

readableStream.<span class="hljs-title function_">on</span>(<span class="hljs-string">'end'</span>, <span class="hljs-function">() =></span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'done'</span>);
});
</code></pre>
<ul>
<li>和 yield 是 js 的 generator 的语法，它是异步返回 yield 后的内容，通过 iterator 的 next 来取下一个。</li>
</ul>
<p><img src="https://github.com/user-attachments/assets/c2290823-cc7b-45b7-b2d6-cbcd5febfaaf" alt="image"></p>
<p>我们封装个工厂方法：</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">createReadStream</span>(<span class="hljs-params">iterator</span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReadableDong</span>(iterator);
}

<span class="hljs-keyword">const</span> readableStream = <span class="hljs-title function_">createReadStream</span>(songIterator);

readableStream.<span class="hljs-title function_">on</span>(<span class="hljs-string">'data'</span>, <span class="hljs-function">(<span class="hljs-params">data</span>) =></span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data.<span class="hljs-title function_">toString</span>());
});

readableStream.<span class="hljs-title function_">on</span>(<span class="hljs-string">'end'</span>, <span class="hljs-function">() =></span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'done'</span>);
});
</code></pre>
<p>是不是就和 fs.createReadStream 很像了？</p>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// 创建 src/fsReadStream.mjs</span>
<span class="hljs-keyword">import</span> fs <span class="hljs-keyword">from</span> <span class="hljs-string">'node:fs'</span>;
<span class="hljs-keyword">import</span> path <span class="hljs-keyword">from</span> <span class="hljs-string">'node:path'</span>;

<span class="hljs-keyword">const</span> readStream = fs.<span class="hljs-title function_">createReadStream</span>(
  path.<span class="hljs-title function_">join</span>(<span class="hljs-keyword">import</span>.<span class="hljs-property">meta</span>.<span class="hljs-property">dirname</span>, <span class="hljs-string">'..'</span>, <span class="hljs-string">'package.json'</span>),
  <span class="hljs-string">'utf-8'</span>
);

readStream.<span class="hljs-title function_">on</span>(<span class="hljs-string">'data'</span>, <span class="hljs-function">(<span class="hljs-params">data</span>) =></span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data.<span class="hljs-title function_">toString</span>());
});

readStream.<span class="hljs-title function_">on</span>(<span class="hljs-string">'end'</span>, <span class="hljs-function">() =></span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'done'</span>);
});
</code></pre>
<p><img src="https://github.com/user-attachments/assets/1e7bb2ed-6be6-479f-a4fe-f3318766f17d" alt="image"></p>
<p>其实文件的 ReadStream 就是基于 stream 的 Readable 封装出来的。</p>
<p>这就是可读流。</p>
<p>http 服务的 request 就是 Readable 的实例：</p>
<p><img src="https://github.com/user-attachments/assets/bca3ed3c-fd44-4ff4-974e-7e5830ae21b7" alt="image"></p>
<p>所以我们可以这样写：</p>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// src/test2.mjs</span>
<span class="hljs-keyword">import</span> http <span class="hljs-keyword">from</span> <span class="hljs-string">'node:http'</span>;
<span class="hljs-keyword">import</span> fs <span class="hljs-keyword">from</span> <span class="hljs-string">'node:fs'</span>;

<span class="hljs-keyword">const</span> server = http.<span class="hljs-title function_">createServer</span>(<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">req, res</span>) {
    <span class="hljs-keyword">const</span> writeStream = fs.<span class="hljs-title function_">createWriteStream</span>(<span class="hljs-string">'aaa.txt'</span>, <span class="hljs-string">'utf-8'</span>);
    req.<span class="hljs-title function_">pipe</span>(writeStream);
    res.<span class="hljs-title function_">end</span>(<span class="hljs-string">'done'</span>);
});

server.<span class="hljs-title function_">listen</span>(<span class="hljs-number">8000</span>);
</code></pre>
<p>启动服务后访问一下</p>
<pre><code>curl -X POST -d "a=1&#x26;b=2" http://localhost:8000
</code></pre>
<p><img src="https://github.com/user-attachments/assets/df08f683-77d2-4252-84fe-742c42d5c230" alt="image"></p>
<p>可以看到，从 request 的流中读出的内容写入了文件的 WriteStream</p>
<h3 id="writable"><a aria-hidden="true" tabindex="-1" href="#writable"><span class="icon icon-link"></span></a>Writable</h3></div></section><div class="mt-10 max-w-3xl"><h3 class="text-2xl font-bold mb-4">评论</h3><p>加载评论中...</p></div></article></main><footer class="bg-neutral-50 border-t border-neutral-200 text-center text-xs opacity-50 py-4">© 2022,<!-- --> <a rel="noopener noreferrer" class="hover:underline hover:bg-indigo" href="https://github.com/LZS911" target="_blank">LZS_911</a>, build with<!-- --> <a rel="noopener noreferrer" class="underline hover:bg-indigo" href="https://nextjs.org/" target="_blank">Next.js</a> <!-- -->and<!-- --> <a rel="noopener noreferrer" class="underline hover:bg-indigo" href="https://pages.github.com/?(null)" target="_blank">GitHub Pages</a></footer></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"Node.js-Stream学习记录","date":"2024-12-20","slug":"Node.js-Stream学习记录","author":"Ai.Haibara","content":"\u003ch2 id=\"什么是-stream流\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#什么是-stream流\"\u003e\u003cspan class=\"icon icon-link\"\u003e\u003c/span\u003e\u003c/a\u003e什么是 Stream（流）\u003c/h2\u003e\n\u003cp\u003e先看一下 Node 官网中对于 Stream 的介绍\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eA stream is an abstract interface for working with streaming data in Node.js.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e其实我们写的 Node.js 代码经常会用到流。\u003c/p\u003e\n\u003cp\u003e来看一段代码\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-typescript\"\u003e\u003cspan class=\"hljs-comment\"\u003e// src/test.mjs\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e http \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'node:http'\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e fs \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'node:fs'\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e path \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'node:path'\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e server = http.\u003cspan class=\"hljs-title function_\"\u003ecreateServer\u003c/span\u003e(\u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e (\u003cspan class=\"hljs-params\"\u003ereq, res\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e data = fs.\u003cspan class=\"hljs-title function_\"\u003ereadFileSync\u003c/span\u003e(\n    path.\u003cspan class=\"hljs-title function_\"\u003ejoin\u003c/span\u003e(\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003emeta\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003edirname\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'..'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'package.json'\u003c/span\u003e),\n    \u003cspan class=\"hljs-string\"\u003e'utf-8'\u003c/span\u003e\n  );\n  res.\u003cspan class=\"hljs-title function_\"\u003eend\u003c/span\u003e(data);\n});\n\nserver.\u003cspan class=\"hljs-title function_\"\u003elisten\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e8000\u003c/span\u003e);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e我们跑了个 http 服务。\u003c/p\u003e\n\u003cp\u003e用 fs.readFileSync 读取项目中 package.json 的内容返回。\u003c/p\u003e\n\u003cp\u003e启动服务后使用 curl 访问下\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-shell\"\u003ecurl -i http://localhost:8000\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cimg src=\"https://github.com/user-attachments/assets/775ccae6-26e8-4149-abbe-8244ce84b035\" alt=\"image\"\u003e\u003c/p\u003e\n\u003cp\u003e因为是全部读完返回的，所以可以知道 Content-Length，也就是响应体的长度。\u003c/p\u003e\n\u003cp\u003e当文件比较小的时候，这样读取、返回没啥问题。\u003c/p\u003e\n\u003cp\u003e那如果文件非常大呢？\u003c/p\u003e\n\u003cp\u003e比如有好几百 M，这时候全部读取完再返回是不是就合适了？\u003c/p\u003e\n\u003cp\u003e因为要等好久才能读取完文件，之后才有响应。\u003c/p\u003e\n\u003cp\u003e这就需要用到流了：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-typescript\"\u003e\u003cspan class=\"hljs-comment\"\u003e//更新 src/test.mjs\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e http \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'node:http'\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e fs \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'node:fs'\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e path \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'node:path'\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e server = http.\u003cspan class=\"hljs-title function_\"\u003ecreateServer\u003c/span\u003e(\u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e (\u003cspan class=\"hljs-params\"\u003ereq, res\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e readStream = fs.\u003cspan class=\"hljs-title function_\"\u003ecreateReadStream\u003c/span\u003e(\n    path.\u003cspan class=\"hljs-title function_\"\u003ejoin\u003c/span\u003e(\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003emeta\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003edirname\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'..'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'package.json'\u003c/span\u003e),\n    \u003cspan class=\"hljs-string\"\u003e'utf-8'\u003c/span\u003e\n  );\n  readStream.\u003cspan class=\"hljs-title function_\"\u003epipe\u003c/span\u003e(res);\n});\n\nserver.\u003cspan class=\"hljs-title function_\"\u003elisten\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e8000\u003c/span\u003e);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cimg src=\"https://github.com/user-attachments/assets/7d9096be-3d6b-4640-ac7d-09a3700b32b2\" alt=\"image\"\u003e\u003c/p\u003e\n\u003cp\u003e结果一样，但是因为现在是流式返回的，并不知道响应体的 Content-Length。\u003c/p\u003e\n\u003cp\u003e所以是用 Transfer-Encoding: chunked 的方式返回流式内容。\u003c/p\u003e\n\u003cp\u003e从服务器下载一个文件的时候，如何知道文件下载完了呢？\u003c/p\u003e\n\u003cp\u003e有两种方式：\u003c/p\u003e\n\u003cp\u003e一种是 header 里带上 Content-Length，浏览器下载到这个长度就结束。\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://github.com/user-attachments/assets/05f39e48-2f39-4fdd-9c51-2a1f4736991e\" alt=\"image\"\u003e\u003c/p\u003e\n\u003cp\u003e另一种是设置 transfer-encoding:chunked，它是不固定长度的，服务器不断返回内容，直到返回一个空的内容代表结束。\u003c/p\u003e\n\u003cp\u003e比如这样：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-shell\"\u003e5\nHello\n1\n,\n5\nWorld\n1\n!\n0\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e这里分了 “Hello” “,” “World”“!” 这 4 个块，长度分别为 5、1、5、1\u003c/p\u003e\n\u003cp\u003e最后以一个长度为 0 的块代表传输结束。\u003c/p\u003e\n\u003cp\u003e这样，不管内容多少都可以分块返回，就不用指定 Content-Length 了。\u003c/p\u003e\n\u003cp\u003e这就是大文件的流式传输的原理，就是 transfer-encoding:chunked。\u003c/p\u003e\n\u003cp\u003e当然，这是 http 传输时的流，在用 shell 命令的时候，也经常会用到流：\u003c/p\u003e\n\u003cp\u003e比如\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-shell\"\u003els | grep pack\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cimg src=\"https://github.com/user-attachments/assets/e7d69e47-5a8a-4717-b3e7-7251d5924dc6\" alt=\"image\"\u003e\u003c/p\u003e\n\u003cp\u003els 命令的输出流，作为 grep 命令的输入流。\u003c/p\u003e\n\u003cp\u003e当然，我们也可以把 grep 命令的输出流，作为 node 脚本的输入流。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-javascript\"\u003e\u003cspan class=\"hljs-comment\"\u003e//src/read.mjs\u003c/span\u003e\nprocess.\u003cspan class=\"hljs-property\"\u003estdin\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eon\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'readable'\u003c/span\u003e, \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e (\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e buf = process.\u003cspan class=\"hljs-property\"\u003estdin\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eread\u003c/span\u003e();\n    \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(buf?.\u003cspan class=\"hljs-title function_\"\u003etoString\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'utf-8'\u003c/span\u003e));\n});\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eprocess.stdin 就是输入流，监听 readable 事件，用 read 读取数据。\u003c/p\u003e\n\u003cp\u003e执行一下\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-shell\"\u003els | grep pack | node src/read.mjs\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cimg src=\"https://github.com/user-attachments/assets/e51ce88c-f842-4e5c-8758-4d203085a0ac\" alt=\"image\"\u003e\u003c/p\u003e\n\u003cp\u003e可以看到，我们的 node 脚本接收到了 grep 的输出流作为输入流。\u003c/p\u003e\n\u003cp\u003e这就是管道 pipe 的含义。\u003c/p\u003e\n\u003cp\u003e综上，可以小结下我们对流的认识：\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e流就是分段的传输内容，比如从服务端像浏览器返回响应数据的流，读取文件的流等。\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e流和流之间可以通过管道 pipe 连接，上个流的输出作为下个流的输入。\u003c/strong\u003e\u003c/p\u003e\n\u003ch2 id=\"流的类型\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#流的类型\"\u003e\u003cspan class=\"icon icon-link\"\u003e\u003c/span\u003e\u003c/a\u003e流的类型\u003c/h2\u003e\n\u003cp\u003e在 node 里，流一共有 4 种：可读流 Readable、可写流 Writable、双工流 Duplex、转换流 Transform。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-javascript\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e stream \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'node:stream'\u003c/span\u003e;\n\n\u003cspan class=\"hljs-comment\"\u003e// 可读流\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eReadable\u003c/span\u003e = stream.\u003cspan class=\"hljs-property\"\u003eReadable\u003c/span\u003e;\n\u003cspan class=\"hljs-comment\"\u003e// 可写流\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eWritable\u003c/span\u003e = stream.\u003cspan class=\"hljs-property\"\u003eWritable\u003c/span\u003e;\n\u003cspan class=\"hljs-comment\"\u003e// 双工流\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eDuplex\u003c/span\u003e = stream.\u003cspan class=\"hljs-property\"\u003eDuplex\u003c/span\u003e;\n\u003cspan class=\"hljs-comment\"\u003e// 转换流\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eTransform\u003c/span\u003e = stream.\u003cspan class=\"hljs-property\"\u003eTransform\u003c/span\u003e;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e其余的流都是基于这 4 种流封装出来的。\u003c/p\u003e\n\u003ch3 id=\"readable\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#readable\"\u003e\u003cspan class=\"icon icon-link\"\u003e\u003c/span\u003e\u003c/a\u003eReadable\u003c/h3\u003e\n\u003cp\u003eReadable 要实现 _read 方法，通过 push 返回具体的数据。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-javascript\"\u003e\u003cspan class=\"hljs-comment\"\u003e//readable.mjs\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { \u003cspan class=\"hljs-title class_\"\u003eReadable\u003c/span\u003e } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'node:stream'\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e readableStream = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eReadable\u003c/span\u003e();\n\nreadableStream.\u003cspan class=\"hljs-property\"\u003e_read\u003c/span\u003e = \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n    \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003epush\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'阿门阿前一棵葡萄树，'\u003c/span\u003e);\n    \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003epush\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'阿东阿东绿的刚发芽，'\u003c/span\u003e);\n    \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003epush\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'阿东背着那重重的的壳呀，'\u003c/span\u003e);\n    \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003epush\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'一步一步地往上爬。'\u003c/span\u003e)\n    \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003epush\u003c/span\u003e(\u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e);\n}\n\nreadableStream.\u003cspan class=\"hljs-title function_\"\u003eon\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'data'\u003c/span\u003e, \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003edata\u003c/span\u003e)=\u003e\u003c/span\u003e {\n    \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(data.\u003cspan class=\"hljs-title function_\"\u003etoString\u003c/span\u003e())\n});\n\nreadableStream.\u003cspan class=\"hljs-title function_\"\u003eon\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'end'\u003c/span\u003e, \u003cspan class=\"hljs-function\"\u003e() =\u003e\u003c/span\u003e {\n    \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'done'\u003c/span\u003e);\n});\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e当 push 一个 null 时，就代表结束流。\u003c/p\u003e\n\u003cp\u003e执行一下\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-shell\"\u003enode src/readable.mjs\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cimg src=\"https://github.com/user-attachments/assets/184fe685-1a0b-4a88-b846-c4ebe37a705c\" alt=\"image\"\u003e\u003c/p\u003e\n\u003cp\u003e创建 Readable 流也可以通过继承的方式：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-javascript\"\u003e\u003cspan class=\"hljs-comment\"\u003e// src/readable2.mjs\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { \u003cspan class=\"hljs-title class_\"\u003eReadable\u003c/span\u003e } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'node:stream'\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eReadableDong\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eextends\u003c/span\u003e \u003cspan class=\"hljs-title class_ inherited__\"\u003eReadable\u003c/span\u003e {\n\n    \u003cspan class=\"hljs-title function_\"\u003e_read\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n        \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003epush\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'阿门阿前一棵葡萄树，'\u003c/span\u003e);\n        \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003epush\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'阿东阿东绿的刚发芽，'\u003c/span\u003e);\n        \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003epush\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'阿东背着那重重的的壳呀，'\u003c/span\u003e);\n        \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003epush\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'一步一步地往上爬。'\u003c/span\u003e)\n        \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003epush\u003c/span\u003e(\u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e);\n    }\n\n}\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e readableStream = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eReadableDong\u003c/span\u003e();\n\nreadableStream.\u003cspan class=\"hljs-title function_\"\u003eon\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'data'\u003c/span\u003e, \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003edata\u003c/span\u003e)=\u003e\u003c/span\u003e {\n    \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(data.\u003cspan class=\"hljs-title function_\"\u003etoString\u003c/span\u003e())\n});\n\nreadableStream.\u003cspan class=\"hljs-title function_\"\u003eon\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'end'\u003c/span\u003e, \u003cspan class=\"hljs-function\"\u003e() =\u003e\u003c/span\u003e {\n    \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'done'\u003c/span\u003e);\n});\n\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cimg src=\"https://github.com/user-attachments/assets/267137eb-e992-4c71-9bd3-3325e05a74a7\" alt=\"image\"\u003e\u003c/p\u003e\n\u003cp\u003e可读流是生成内容的，那么很自然可以和生成器结合：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-javascript\"\u003e\u003cspan class=\"hljs-comment\"\u003e// src/readable3.mjs\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { \u003cspan class=\"hljs-title class_\"\u003eReadable\u003c/span\u003e } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'node:stream'\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eReadableDong\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eextends\u003c/span\u003e \u003cspan class=\"hljs-title class_ inherited__\"\u003eReadable\u003c/span\u003e {\n\n    \u003cspan class=\"hljs-title function_\"\u003econstructor\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eiterator\u003c/span\u003e) {\n        \u003cspan class=\"hljs-variable language_\"\u003esuper\u003c/span\u003e();\n        \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eiterator\u003c/span\u003e = iterator;\n    }\n\n    \u003cspan class=\"hljs-title function_\"\u003e_read\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n        \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e next = \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eiterator\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003enext\u003c/span\u003e();\n        \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e(next.\u003cspan class=\"hljs-property\"\u003edone\u003c/span\u003e) {\n            \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003epush\u003c/span\u003e(\u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e);\n        } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n            \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003epush\u003c/span\u003e(next.\u003cspan class=\"hljs-property\"\u003evalue\u003c/span\u003e)\n        }\n    }\n\n}\n\n\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e *\u003cspan class=\"hljs-title function_\"\u003esongGenerator\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003eyield\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'阿门阿前一棵葡萄树，'\u003c/span\u003e;\n    \u003cspan class=\"hljs-keyword\"\u003eyield\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'阿东阿东绿的刚发芽，'\u003c/span\u003e;\n    \u003cspan class=\"hljs-keyword\"\u003eyield\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'阿东背着那重重的的壳呀，'\u003c/span\u003e;\n    \u003cspan class=\"hljs-keyword\"\u003eyield\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'一步一步地往上爬。'\u003c/span\u003e;\n}\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e songIterator = \u003cspan class=\"hljs-title function_\"\u003esongGenerator\u003c/span\u003e();\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e readableStream = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eReadableDong\u003c/span\u003e(songIterator);\n\nreadableStream.\u003cspan class=\"hljs-title function_\"\u003eon\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'data'\u003c/span\u003e, \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003edata\u003c/span\u003e)=\u003e\u003c/span\u003e {\n    \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(data.\u003cspan class=\"hljs-title function_\"\u003etoString\u003c/span\u003e())\n});\n\nreadableStream.\u003cspan class=\"hljs-title function_\"\u003eon\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'end'\u003c/span\u003e, \u003cspan class=\"hljs-function\"\u003e() =\u003e\u003c/span\u003e {\n    \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'done'\u003c/span\u003e);\n});\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003e和 yield 是 js 的 generator 的语法，它是异步返回 yield 后的内容，通过 iterator 的 next 来取下一个。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg src=\"https://github.com/user-attachments/assets/c2290823-cc7b-45b7-b2d6-cbcd5febfaaf\" alt=\"image\"\u003e\u003c/p\u003e\n\u003cp\u003e我们封装个工厂方法：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-javascript\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ecreateReadStream\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eiterator\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eReadableDong\u003c/span\u003e(iterator);\n}\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e readableStream = \u003cspan class=\"hljs-title function_\"\u003ecreateReadStream\u003c/span\u003e(songIterator);\n\nreadableStream.\u003cspan class=\"hljs-title function_\"\u003eon\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'data'\u003c/span\u003e, \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003edata\u003c/span\u003e) =\u003e\u003c/span\u003e {\n  \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(data.\u003cspan class=\"hljs-title function_\"\u003etoString\u003c/span\u003e());\n});\n\nreadableStream.\u003cspan class=\"hljs-title function_\"\u003eon\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'end'\u003c/span\u003e, \u003cspan class=\"hljs-function\"\u003e() =\u003e\u003c/span\u003e {\n  \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'done'\u003c/span\u003e);\n});\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e是不是就和 fs.createReadStream 很像了？\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-javascript\"\u003e\u003cspan class=\"hljs-comment\"\u003e// 创建 src/fsReadStream.mjs\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e fs \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'node:fs'\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e path \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'node:path'\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e readStream = fs.\u003cspan class=\"hljs-title function_\"\u003ecreateReadStream\u003c/span\u003e(\n  path.\u003cspan class=\"hljs-title function_\"\u003ejoin\u003c/span\u003e(\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003emeta\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003edirname\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'..'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'package.json'\u003c/span\u003e),\n  \u003cspan class=\"hljs-string\"\u003e'utf-8'\u003c/span\u003e\n);\n\nreadStream.\u003cspan class=\"hljs-title function_\"\u003eon\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'data'\u003c/span\u003e, \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003edata\u003c/span\u003e) =\u003e\u003c/span\u003e {\n  \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(data.\u003cspan class=\"hljs-title function_\"\u003etoString\u003c/span\u003e());\n});\n\nreadStream.\u003cspan class=\"hljs-title function_\"\u003eon\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'end'\u003c/span\u003e, \u003cspan class=\"hljs-function\"\u003e() =\u003e\u003c/span\u003e {\n  \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'done'\u003c/span\u003e);\n});\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cimg src=\"https://github.com/user-attachments/assets/1e7bb2ed-6be6-479f-a4fe-f3318766f17d\" alt=\"image\"\u003e\u003c/p\u003e\n\u003cp\u003e其实文件的 ReadStream 就是基于 stream 的 Readable 封装出来的。\u003c/p\u003e\n\u003cp\u003e这就是可读流。\u003c/p\u003e\n\u003cp\u003ehttp 服务的 request 就是 Readable 的实例：\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://github.com/user-attachments/assets/bca3ed3c-fd44-4ff4-974e-7e5830ae21b7\" alt=\"image\"\u003e\u003c/p\u003e\n\u003cp\u003e所以我们可以这样写：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-javascript\"\u003e\u003cspan class=\"hljs-comment\"\u003e// src/test2.mjs\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e http \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'node:http'\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e fs \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'node:fs'\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e server = http.\u003cspan class=\"hljs-title function_\"\u003ecreateServer\u003c/span\u003e(\u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e (\u003cspan class=\"hljs-params\"\u003ereq, res\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e writeStream = fs.\u003cspan class=\"hljs-title function_\"\u003ecreateWriteStream\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'aaa.txt'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'utf-8'\u003c/span\u003e);\n    req.\u003cspan class=\"hljs-title function_\"\u003epipe\u003c/span\u003e(writeStream);\n    res.\u003cspan class=\"hljs-title function_\"\u003eend\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'done'\u003c/span\u003e);\n});\n\nserver.\u003cspan class=\"hljs-title function_\"\u003elisten\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e8000\u003c/span\u003e);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e启动服务后访问一下\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003ecurl -X POST -d \"a=1\u0026#x26;b=2\" http://localhost:8000\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cimg src=\"https://github.com/user-attachments/assets/df08f683-77d2-4252-84fe-742c42d5c230\" alt=\"image\"\u003e\u003c/p\u003e\n\u003cp\u003e可以看到，从 request 的流中读出的内容写入了文件的 WriteStream\u003c/p\u003e\n\u003ch3 id=\"writable\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#writable\"\u003e\u003cspan class=\"icon icon-link\"\u003e\u003c/span\u003e\u003c/a\u003eWritable\u003c/h3\u003e","theme":"fancy","tag":[null]}},"__N_SSG":true},"page":"/posts/[slug]","query":{"slug":"Node.js-Stream学习记录"},"buildId":"yIbYpMrVODDFyEXyLGSSq","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>