<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><link rel="apple-touch-icon" sizes="180x180" href="/favicon/apple-touch-icon.png"/><link rel="icon" type="image/png" sizes="32x32" href="/favicon/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="16x16" href="/favicon/favicon-16x16.png"/><link rel="manifest" href="/favicon/site.webmanifest"/><link rel="mask-icon" href="/favicon/safari-pinned-tab.svg" color="#000000"/><link rel="shortcut icon" href="/favicon/favicon.ico"/><meta name="msapplication-TileColor" content="#000000"/><meta name="msapplication-config" content="/favicon/browserconfig.xml"/><meta name="theme-color" content="#000"/><link rel="alternate" type="application/rss+xml" href="/feed.xml"/><meta property="og:image" content="https://og-image.vercel.app/Next.js%20Blog%20Starter%20Example.png?theme=light&amp;md=1&amp;fontSize=100px&amp;images=https%3A%2F%2Fassets.vercel.com%2Fimage%2Fupload%2Ffront%2Fassets%2Fdesign%2Fnextjs-black-logo.svg"/><title>Node.js-Stream学习记录 | Ai.Haibara codes</title><meta name="next-head-count" content="14"/><link rel="preload" href="/_next/static/css/8681f744d5932be6.css" as="style"/><link rel="stylesheet" href="/_next/static/css/8681f744d5932be6.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-8fa1640cc84ba8fe.js" defer=""></script><script src="/_next/static/chunks/framework-3b5a00d5d7e8d93b.js" defer=""></script><script src="/_next/static/chunks/main-59a90320855f5cf5.js" defer=""></script><script src="/_next/static/chunks/pages/_app-f46e289d7ac5e197.js" defer=""></script><script src="/_next/static/chunks/799-575b46febca3af7d.js" defer=""></script><script src="/_next/static/chunks/399-cac0cd8ed02bf02a.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bslug%5D-e2afa3a98c674f72.js" defer=""></script><script src="/_next/static/Rfvy9WK71nLCZ90Ws6Jh7/_buildManifest.js" defer=""></script><script src="/_next/static/Rfvy9WK71nLCZ90Ws6Jh7/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="min-h-screen"><header class="text-white bg-black drop-shadow-2xl"><div class="mx-auto my-0 max-w-[960px] py-6 px-4 flex items-center"><div class="flex items-center"><img alt="Ai.Haibara" src="/assets/blog/authors/haibara_2.jpg" width="100" height="100" decoding="async" data-nimg="1" class=" rounded-full" loading="lazy" style="color:transparent"/></div><div class="ml-6"><a class=" font-bold text-3xl" href="/">Ai.Haibara codes</a><div class="mt-2"><a class="p-1 rounded-sm text-xl mr-2 hover:border-b-2 border-indigo" href="/">Home</a><a class="p-1 rounded-sm text-xl mr-2 hover:border-b-2 border-indigo" href="/projects">Projects</a><a class="p-1 rounded-sm text-xl mr-2 hover:border-b-2 border-indigo" href="/talks">Talks</a><a class="p-1 rounded-sm text-xl mr-2 hover:border-b-2 border-indigo" href="/blogs">Blogs</a></div></div></div></header><main class="p-6 flex justify-center"><article><div class="flex justify-center font-[Arial] max-w-[864px] text-center"><h1 class="text-5xl font-bold bg-indigo px-5 py-2 rounded-sm text-shadow-lg leading-[1.1]">Node.js-Stream学习记录</h1></div><time dateTime="2024-12-20" class="text-center block my-4 text-sm opacity-60">December	20, 2024</time><section><div class="markdown-body-fancy max-w-3xl"><h2 id="什么是-stream流"><a aria-hidden="true" tabindex="-1" href="#什么是-stream流"><span class="icon icon-link"></span></a>什么是 Stream（流）</h2>
<p>先看一下 Node 官网中对于 Stream 的介绍</p>
<blockquote>
<p>A stream is an abstract interface for working with streaming data in Node.js.</p>
</blockquote>
<p>其实我们写的 Node.js 代码经常会用到流。</p>
<p>来看一段代码</p>
<pre><code>// src/test.mjs
import http from 'node:http';
import fs from 'node:fs';
import path from 'node:path';

const server = http.createServer(async function (req, res) {
  const data = fs.readFileSync(
    path.join(import.meta.dirname, '..', 'package.json'),
    'utf-8'
  );
  res.end(data);
});

server.listen(8000);
</code></pre>
<p>我们跑了个 http 服务。</p>
<p>用 fs.readFileSync 读取项目中 package.json 的内容返回。</p>
<p>启动服务后使用 curl 访问下</p>
<pre><code>curl -i http://localhost:8000
</code></pre>
<p><img src="https://github.com/user-attachments/assets/775ccae6-26e8-4149-abbe-8244ce84b035" alt="image"></p>
<p>因为是全部读完返回的，所以可以知道 Content-Length，也就是响应体的长度。</p>
<p>当文件比较小的时候，这样读取、返回没啥问题。</p>
<p>那如果文件非常大呢？</p>
<p>比如有好几百 M，这时候全部读取完再返回是不是就合适了？</p>
<p>因为要等好久才能读取完文件，之后才有响应。</p>
<p>这就需要用到流了：</p>
<pre><code>//更新 src/test.mjs
import http from 'node:http';
import fs from 'node:fs';
import path from 'node:path';

const server = http.createServer(async function (req, res) {
  const readStream = fs.createReadStream(
    path.join(import.meta.dirname, '..', 'package.json'),
    'utf-8'
  );
  readStream.pipe(res);
});

server.listen(8000);
</code></pre>
<p><img src="https://github.com/user-attachments/assets/7d9096be-3d6b-4640-ac7d-09a3700b32b2" alt="image"></p>
<p>结果一样，但是因为现在是流式返回的，并不知道响应体的 Content-Length。</p>
<p>所以是用 Transfer-Encoding: chunked 的方式返回流式内容。</p>
<p>从服务器下载一个文件的时候，如何知道文件下载完了呢？</p>
<p>有两种方式：</p>
<p>一种是 header 里带上 Content-Length，浏览器下载到这个长度就结束。</p>
<p><img src="https://github.com/user-attachments/assets/05f39e48-2f39-4fdd-9c51-2a1f4736991e" alt="image"></p>
<p>另一种是设置 transfer-encoding:chunked，它是不固定长度的，服务器不断返回内容，直到返回一个空的内容代表结束。</p>
<p>比如这样：</p>
<pre><code>5
Hello
1
,
5
World
1
!
0
</code></pre>
<p>这里分了 “Hello” “,” “World”“!” 这 4 个块，长度分别为 5、1、5、1</p>
<p>最后以一个长度为 0 的块代表传输结束。</p>
<p>这样，不管内容多少都可以分块返回，就不用指定 Content-Length 了。</p>
<p>这就是大文件的流式传输的原理，就是 transfer-encoding:chunked。</p>
<p>当然，这是 http 传输时的流，在用 shell 命令的时候，也经常会用到流：</p>
<p>比如</p>
<pre><code>ls | grep pack
</code></pre>
<p><img src="https://github.com/user-attachments/assets/e7d69e47-5a8a-4717-b3e7-7251d5924dc6" alt="image"></p>
<p>ls 命令的输出流，作为 grep 命令的输入流。</p>
<p>当然，我们也可以把 grep 命令的输出流，作为 node 脚本的输入流。</p>
<pre><code>//src/read.mjs
process.stdin.on('readable', function () {
    const buf = process.stdin.read();
    console.log(buf?.toString('utf-8'));
});
</code></pre>
<p>process.stdin 就是输入流，监听 readable 事件，用 read 读取数据。</p>
<p>执行一下</p>
<pre><code>ls | grep pack | node src/read.mjs
</code></pre>
<p><img src="https://github.com/user-attachments/assets/e51ce88c-f842-4e5c-8758-4d203085a0ac" alt="image"></p>
<p>可以看到，我们的 node 脚本接收到了 grep 的输出流作为输入流。</p>
<p>这就是管道 pipe 的含义。</p>
<p>综上，可以小结下我们对流的认识：</p>
<p><strong>流就是分段的传输内容，比如从服务端像浏览器返回响应数据的流，读取文件的流等。</strong></p>
<p><strong>流和流之间可以通过管道 pipe 连接，上个流的输出作为下个流的输入。</strong></p>
<h2 id="流的类型"><a aria-hidden="true" tabindex="-1" href="#流的类型"><span class="icon icon-link"></span></a>流的类型</h2>
<p>在 node 里，流一共有 4 种：可读流 Readable、可写流 Writable、双工流 Duplex、转换流 Transform。</p>
<pre><code>import stream from 'node:stream';

// 可读流
const Readable = stream.Readable;
// 可写流
const Writable = stream.Writable;
// 双工流
const Duplex = stream.Duplex;
// 转换流
const Transform = stream.Transform;
</code></pre>
<p>其余的流都是基于这 4 种流封装出来的。</p>
<h3 id="readable"><a aria-hidden="true" tabindex="-1" href="#readable"><span class="icon icon-link"></span></a>Readable</h3>
<p>Readable 要实现 _read 方法，通过 push 返回具体的数据。</p>
<pre><code>//readable.mjs
import { Readable } from 'node:stream';

const readableStream = new Readable();

readableStream._read = function() {
    this.push('阿门阿前一棵葡萄树，');
    this.push('阿东阿东绿的刚发芽，');
    this.push('阿东背着那重重的的壳呀，');
    this.push('一步一步地往上爬。')
    this.push(null);
}

readableStream.on('data', (data)=> {
    console.log(data.toString())
});

readableStream.on('end', () => {
    console.log('done');
});
</code></pre>
<p>当 push 一个 null 时，就代表结束流。</p>
<p>执行一下</p>
<pre><code>node src/readable.mjs
</code></pre>
<p><img src="https://github.com/user-attachments/assets/184fe685-1a0b-4a88-b846-c4ebe37a705c" alt="image"></p>
<p>创建 Readable 流也可以通过继承的方式：</p>
<pre><code>// src/readable2.mjs
import { Readable } from 'node:stream';

class ReadableDong extends Readable {

    _read() {
        this.push('阿门阿前一棵葡萄树，');
        this.push('阿东阿东绿的刚发芽，');
        this.push('阿东背着那重重的的壳呀，');
        this.push('一步一步地往上爬。')
        this.push(null);
    }

}

const readableStream = new ReadableDong();

readableStream.on('data', (data)=> {
    console.log(data.toString())
});

readableStream.on('end', () => {
    console.log('done');
});

</code></pre>
<p><img src="https://github.com/user-attachments/assets/267137eb-e992-4c71-9bd3-3325e05a74a7" alt="image"></p>
<p>可读流是生成内容的，那么很自然可以和生成器结合：</p>
<pre><code>// src/readable3.mjs

import { Readable } from 'node:stream';

class ReadableDong extends Readable {

    constructor(iterator) {
        super();
        this.iterator = iterator;
    }

    _read() {
        const next = this.iterator.next();
        if(next.done) {
            return this.push(null);
        } else {
            this.push(next.value)
        }
    }

}

function *songGenerator() {
    yield '阿门阿前一棵葡萄树，';
    yield '阿东阿东绿的刚发芽，';
    yield '阿东背着那重重的的壳呀，';
    yield '一步一步地往上爬。';
}

const songIterator = songGenerator();

const readableStream = new ReadableDong(songIterator);

readableStream.on('data', (data)=> {
    console.log(data.toString())
});

readableStream.on('end', () => {
    console.log('done');
});
</code></pre>
<ul>
<li>和 yield 是 js 的 generator 的语法，它是异步返回 yield 后的内容，通过 iterator 的 next 来取下一个。</li>
</ul>
<p><img src="https://github.com/user-attachments/assets/c2290823-cc7b-45b7-b2d6-cbcd5febfaaf" alt="image"></p>
<p>我们封装个工厂方法：</p>
<pre><code>function createReadStream(iterator) {
  return new ReadableDong(iterator);
}

const readableStream = createReadStream(songIterator);

readableStream.on('data', (data) => {
  console.log(data.toString());
});

readableStream.on('end', () => {
  console.log('done');
});
</code></pre>
<p>是不是就和 fs.createReadStream 很像了？</p>
<pre><code>// 创建 src/fsReadStream.mjs
import fs from 'node:fs';
import path from 'node:path';

const readStream = fs.createReadStream(
  path.join(import.meta.dirname, '..', 'package.json'),
  'utf-8'
);

readStream.on('data', (data) => {
  console.log(data.toString());
});

readStream.on('end', () => {
  console.log('done');
});
</code></pre>
<p><img src="https://github.com/user-attachments/assets/1e7bb2ed-6be6-479f-a4fe-f3318766f17d" alt="image"></p>
<p>其实文件的 ReadStream 就是基于 stream 的 Readable 封装出来的。</p>
<p>这就是可读流。</p>
<p>http 服务的 request 就是 Readable 的实例：</p>
<p><img src="https://github.com/user-attachments/assets/bca3ed3c-fd44-4ff4-974e-7e5830ae21b7" alt="image"></p>
<p>所以我们可以这样写：</p>
<pre><code>// src/test2.mjs
import http from 'node:http';
import fs from 'node:fs';

const server = http.createServer(async function (req, res) {
    const writeStream = fs.createWriteStream('aaa.txt', 'utf-8');
    req.pipe(writeStream);
    res.end('done');
});

server.listen(8000);
</code></pre>
<p>启动服务后访问一下</p>
<pre><code>curl -X POST -d "a=1&#x26;b=2" http://localhost:8000
</code></pre>
<p><img src="https://github.com/user-attachments/assets/df08f683-77d2-4252-84fe-742c42d5c230" alt="image"></p>
<p>可以看到，从 request 的流中读出的内容写入了文件的 WriteStream</p>
<h3 id="writable"><a aria-hidden="true" tabindex="-1" href="#writable"><span class="icon icon-link"></span></a>Writable</h3></div></section></article></main><footer class="bg-neutral-50 border-t border-neutral-200 text-center text-xs opacity-50 py-4">© 2022,<!-- --> <a rel="noopener noreferrer" class="hover:underline hover:bg-indigo" href="https://github.com/LZS911" target="_blank">LZS_911</a>, build with<!-- --> <a rel="noopener noreferrer" class="underline hover:bg-indigo" href="https://nextjs.org/" target="_blank">Next.js</a> <!-- -->and<!-- --> <a rel="noopener noreferrer" class="underline hover:bg-indigo" href="https://pages.github.com/?(null)" target="_blank">GitHub Pages</a></footer></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"Node.js-Stream学习记录","date":"2024-12-20","slug":"Node.js-Stream学习记录","author":"Ai.Haibara","content":"\u003ch2 id=\"什么是-stream流\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#什么是-stream流\"\u003e\u003cspan class=\"icon icon-link\"\u003e\u003c/span\u003e\u003c/a\u003e什么是 Stream（流）\u003c/h2\u003e\n\u003cp\u003e先看一下 Node 官网中对于 Stream 的介绍\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eA stream is an abstract interface for working with streaming data in Node.js.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e其实我们写的 Node.js 代码经常会用到流。\u003c/p\u003e\n\u003cp\u003e来看一段代码\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e// src/test.mjs\nimport http from 'node:http';\nimport fs from 'node:fs';\nimport path from 'node:path';\n\nconst server = http.createServer(async function (req, res) {\n  const data = fs.readFileSync(\n    path.join(import.meta.dirname, '..', 'package.json'),\n    'utf-8'\n  );\n  res.end(data);\n});\n\nserver.listen(8000);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e我们跑了个 http 服务。\u003c/p\u003e\n\u003cp\u003e用 fs.readFileSync 读取项目中 package.json 的内容返回。\u003c/p\u003e\n\u003cp\u003e启动服务后使用 curl 访问下\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003ecurl -i http://localhost:8000\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cimg src=\"https://github.com/user-attachments/assets/775ccae6-26e8-4149-abbe-8244ce84b035\" alt=\"image\"\u003e\u003c/p\u003e\n\u003cp\u003e因为是全部读完返回的，所以可以知道 Content-Length，也就是响应体的长度。\u003c/p\u003e\n\u003cp\u003e当文件比较小的时候，这样读取、返回没啥问题。\u003c/p\u003e\n\u003cp\u003e那如果文件非常大呢？\u003c/p\u003e\n\u003cp\u003e比如有好几百 M，这时候全部读取完再返回是不是就合适了？\u003c/p\u003e\n\u003cp\u003e因为要等好久才能读取完文件，之后才有响应。\u003c/p\u003e\n\u003cp\u003e这就需要用到流了：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e//更新 src/test.mjs\nimport http from 'node:http';\nimport fs from 'node:fs';\nimport path from 'node:path';\n\nconst server = http.createServer(async function (req, res) {\n  const readStream = fs.createReadStream(\n    path.join(import.meta.dirname, '..', 'package.json'),\n    'utf-8'\n  );\n  readStream.pipe(res);\n});\n\nserver.listen(8000);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cimg src=\"https://github.com/user-attachments/assets/7d9096be-3d6b-4640-ac7d-09a3700b32b2\" alt=\"image\"\u003e\u003c/p\u003e\n\u003cp\u003e结果一样，但是因为现在是流式返回的，并不知道响应体的 Content-Length。\u003c/p\u003e\n\u003cp\u003e所以是用 Transfer-Encoding: chunked 的方式返回流式内容。\u003c/p\u003e\n\u003cp\u003e从服务器下载一个文件的时候，如何知道文件下载完了呢？\u003c/p\u003e\n\u003cp\u003e有两种方式：\u003c/p\u003e\n\u003cp\u003e一种是 header 里带上 Content-Length，浏览器下载到这个长度就结束。\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://github.com/user-attachments/assets/05f39e48-2f39-4fdd-9c51-2a1f4736991e\" alt=\"image\"\u003e\u003c/p\u003e\n\u003cp\u003e另一种是设置 transfer-encoding:chunked，它是不固定长度的，服务器不断返回内容，直到返回一个空的内容代表结束。\u003c/p\u003e\n\u003cp\u003e比如这样：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e5\nHello\n1\n,\n5\nWorld\n1\n!\n0\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e这里分了 “Hello” “,” “World”“!” 这 4 个块，长度分别为 5、1、5、1\u003c/p\u003e\n\u003cp\u003e最后以一个长度为 0 的块代表传输结束。\u003c/p\u003e\n\u003cp\u003e这样，不管内容多少都可以分块返回，就不用指定 Content-Length 了。\u003c/p\u003e\n\u003cp\u003e这就是大文件的流式传输的原理，就是 transfer-encoding:chunked。\u003c/p\u003e\n\u003cp\u003e当然，这是 http 传输时的流，在用 shell 命令的时候，也经常会用到流：\u003c/p\u003e\n\u003cp\u003e比如\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003els | grep pack\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cimg src=\"https://github.com/user-attachments/assets/e7d69e47-5a8a-4717-b3e7-7251d5924dc6\" alt=\"image\"\u003e\u003c/p\u003e\n\u003cp\u003els 命令的输出流，作为 grep 命令的输入流。\u003c/p\u003e\n\u003cp\u003e当然，我们也可以把 grep 命令的输出流，作为 node 脚本的输入流。\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e//src/read.mjs\nprocess.stdin.on('readable', function () {\n    const buf = process.stdin.read();\n    console.log(buf?.toString('utf-8'));\n});\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eprocess.stdin 就是输入流，监听 readable 事件，用 read 读取数据。\u003c/p\u003e\n\u003cp\u003e执行一下\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003els | grep pack | node src/read.mjs\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cimg src=\"https://github.com/user-attachments/assets/e51ce88c-f842-4e5c-8758-4d203085a0ac\" alt=\"image\"\u003e\u003c/p\u003e\n\u003cp\u003e可以看到，我们的 node 脚本接收到了 grep 的输出流作为输入流。\u003c/p\u003e\n\u003cp\u003e这就是管道 pipe 的含义。\u003c/p\u003e\n\u003cp\u003e综上，可以小结下我们对流的认识：\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e流就是分段的传输内容，比如从服务端像浏览器返回响应数据的流，读取文件的流等。\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e流和流之间可以通过管道 pipe 连接，上个流的输出作为下个流的输入。\u003c/strong\u003e\u003c/p\u003e\n\u003ch2 id=\"流的类型\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#流的类型\"\u003e\u003cspan class=\"icon icon-link\"\u003e\u003c/span\u003e\u003c/a\u003e流的类型\u003c/h2\u003e\n\u003cp\u003e在 node 里，流一共有 4 种：可读流 Readable、可写流 Writable、双工流 Duplex、转换流 Transform。\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eimport stream from 'node:stream';\n\n// 可读流\nconst Readable = stream.Readable;\n// 可写流\nconst Writable = stream.Writable;\n// 双工流\nconst Duplex = stream.Duplex;\n// 转换流\nconst Transform = stream.Transform;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e其余的流都是基于这 4 种流封装出来的。\u003c/p\u003e\n\u003ch3 id=\"readable\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#readable\"\u003e\u003cspan class=\"icon icon-link\"\u003e\u003c/span\u003e\u003c/a\u003eReadable\u003c/h3\u003e\n\u003cp\u003eReadable 要实现 _read 方法，通过 push 返回具体的数据。\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e//readable.mjs\nimport { Readable } from 'node:stream';\n\nconst readableStream = new Readable();\n\nreadableStream._read = function() {\n    this.push('阿门阿前一棵葡萄树，');\n    this.push('阿东阿东绿的刚发芽，');\n    this.push('阿东背着那重重的的壳呀，');\n    this.push('一步一步地往上爬。')\n    this.push(null);\n}\n\nreadableStream.on('data', (data)=\u003e {\n    console.log(data.toString())\n});\n\nreadableStream.on('end', () =\u003e {\n    console.log('done');\n});\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e当 push 一个 null 时，就代表结束流。\u003c/p\u003e\n\u003cp\u003e执行一下\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003enode src/readable.mjs\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cimg src=\"https://github.com/user-attachments/assets/184fe685-1a0b-4a88-b846-c4ebe37a705c\" alt=\"image\"\u003e\u003c/p\u003e\n\u003cp\u003e创建 Readable 流也可以通过继承的方式：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e// src/readable2.mjs\nimport { Readable } from 'node:stream';\n\nclass ReadableDong extends Readable {\n\n    _read() {\n        this.push('阿门阿前一棵葡萄树，');\n        this.push('阿东阿东绿的刚发芽，');\n        this.push('阿东背着那重重的的壳呀，');\n        this.push('一步一步地往上爬。')\n        this.push(null);\n    }\n\n}\n\nconst readableStream = new ReadableDong();\n\nreadableStream.on('data', (data)=\u003e {\n    console.log(data.toString())\n});\n\nreadableStream.on('end', () =\u003e {\n    console.log('done');\n});\n\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cimg src=\"https://github.com/user-attachments/assets/267137eb-e992-4c71-9bd3-3325e05a74a7\" alt=\"image\"\u003e\u003c/p\u003e\n\u003cp\u003e可读流是生成内容的，那么很自然可以和生成器结合：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e// src/readable3.mjs\n\nimport { Readable } from 'node:stream';\n\nclass ReadableDong extends Readable {\n\n    constructor(iterator) {\n        super();\n        this.iterator = iterator;\n    }\n\n    _read() {\n        const next = this.iterator.next();\n        if(next.done) {\n            return this.push(null);\n        } else {\n            this.push(next.value)\n        }\n    }\n\n}\n\nfunction *songGenerator() {\n    yield '阿门阿前一棵葡萄树，';\n    yield '阿东阿东绿的刚发芽，';\n    yield '阿东背着那重重的的壳呀，';\n    yield '一步一步地往上爬。';\n}\n\nconst songIterator = songGenerator();\n\nconst readableStream = new ReadableDong(songIterator);\n\nreadableStream.on('data', (data)=\u003e {\n    console.log(data.toString())\n});\n\nreadableStream.on('end', () =\u003e {\n    console.log('done');\n});\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003e和 yield 是 js 的 generator 的语法，它是异步返回 yield 后的内容，通过 iterator 的 next 来取下一个。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg src=\"https://github.com/user-attachments/assets/c2290823-cc7b-45b7-b2d6-cbcd5febfaaf\" alt=\"image\"\u003e\u003c/p\u003e\n\u003cp\u003e我们封装个工厂方法：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003efunction createReadStream(iterator) {\n  return new ReadableDong(iterator);\n}\n\nconst readableStream = createReadStream(songIterator);\n\nreadableStream.on('data', (data) =\u003e {\n  console.log(data.toString());\n});\n\nreadableStream.on('end', () =\u003e {\n  console.log('done');\n});\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e是不是就和 fs.createReadStream 很像了？\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e// 创建 src/fsReadStream.mjs\nimport fs from 'node:fs';\nimport path from 'node:path';\n\nconst readStream = fs.createReadStream(\n  path.join(import.meta.dirname, '..', 'package.json'),\n  'utf-8'\n);\n\nreadStream.on('data', (data) =\u003e {\n  console.log(data.toString());\n});\n\nreadStream.on('end', () =\u003e {\n  console.log('done');\n});\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cimg src=\"https://github.com/user-attachments/assets/1e7bb2ed-6be6-479f-a4fe-f3318766f17d\" alt=\"image\"\u003e\u003c/p\u003e\n\u003cp\u003e其实文件的 ReadStream 就是基于 stream 的 Readable 封装出来的。\u003c/p\u003e\n\u003cp\u003e这就是可读流。\u003c/p\u003e\n\u003cp\u003ehttp 服务的 request 就是 Readable 的实例：\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://github.com/user-attachments/assets/bca3ed3c-fd44-4ff4-974e-7e5830ae21b7\" alt=\"image\"\u003e\u003c/p\u003e\n\u003cp\u003e所以我们可以这样写：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e// src/test2.mjs\nimport http from 'node:http';\nimport fs from 'node:fs';\n\nconst server = http.createServer(async function (req, res) {\n    const writeStream = fs.createWriteStream('aaa.txt', 'utf-8');\n    req.pipe(writeStream);\n    res.end('done');\n});\n\nserver.listen(8000);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e启动服务后访问一下\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003ecurl -X POST -d \"a=1\u0026#x26;b=2\" http://localhost:8000\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cimg src=\"https://github.com/user-attachments/assets/df08f683-77d2-4252-84fe-742c42d5c230\" alt=\"image\"\u003e\u003c/p\u003e\n\u003cp\u003e可以看到，从 request 的流中读出的内容写入了文件的 WriteStream\u003c/p\u003e\n\u003ch3 id=\"writable\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#writable\"\u003e\u003cspan class=\"icon icon-link\"\u003e\u003c/span\u003e\u003c/a\u003eWritable\u003c/h3\u003e","theme":"fancy","tag":[null]}},"__N_SSG":true},"page":"/posts/[slug]","query":{"slug":"Node.js-Stream学习记录"},"buildId":"Rfvy9WK71nLCZ90Ws6Jh7","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>