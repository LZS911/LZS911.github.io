<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><link rel="apple-touch-icon" sizes="180x180" href="/favicon/apple-touch-icon.png"/><link rel="icon" type="image/png" sizes="32x32" href="/favicon/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="16x16" href="/favicon/favicon-16x16.png"/><link rel="manifest" href="/favicon/site.webmanifest"/><link rel="mask-icon" href="/favicon/safari-pinned-tab.svg" color="#000000"/><link rel="shortcut icon" href="/favicon/favicon.ico"/><meta name="msapplication-TileColor" content="#000000"/><meta name="msapplication-config" content="/favicon/browserconfig.xml"/><meta name="theme-color" content="#000"/><link rel="alternate" type="application/rss+xml" href="/feed.xml"/><meta property="og:image" content="https://og-image.vercel.app/Next.js%20Blog%20Starter%20Example.png?theme=light&amp;md=1&amp;fontSize=100px&amp;images=https%3A%2F%2Fassets.vercel.com%2Fimage%2Fupload%2Ffront%2Fassets%2Fdesign%2Fnextjs-black-logo.svg"/><title>《架构整洁之道》读书笔记 - 设计原则篇 | Ai.Haibara codes</title><meta name="next-head-count" content="14"/><link rel="preload" href="/_next/static/css/a5eda337cc81d9ab.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a5eda337cc81d9ab.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee7e63bc15b31913.js" defer=""></script><script src="/_next/static/chunks/framework-3b5a00d5d7e8d93b.js" defer=""></script><script src="/_next/static/chunks/main-59a90320855f5cf5.js" defer=""></script><script src="/_next/static/chunks/pages/_app-91d7f786791773ad.js" defer=""></script><script src="/_next/static/chunks/799-575b46febca3af7d.js" defer=""></script><script src="/_next/static/chunks/642-f55f53346f993b53.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bslug%5D-8e1a2fba1f5daa00.js" defer=""></script><script src="/_next/static/YweoWqZUfFtvB-M1jJ2CU/_buildManifest.js" defer=""></script><script src="/_next/static/YweoWqZUfFtvB-M1jJ2CU/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="min-h-screen"><header class="text-white bg-black drop-shadow-2xl"><div class="mx-auto my-0 max-w-[960px] py-6 px-4 flex items-center"><div class="flex items-center"><img alt="Ai.Haibara" src="/assets/blog/authors/haibara_2.jpg" width="100" height="100" decoding="async" data-nimg="1" class=" rounded-full" loading="lazy" style="color:transparent"/></div><div class="ml-6"><a class=" font-bold text-3xl" href="/">Ai.Haibara codes</a><div class="mt-2"><a class="p-1 rounded-sm text-xl mr-2 hover:border-b-2 border-indigo" href="/">Home</a><a class="p-1 rounded-sm text-xl mr-2 hover:border-b-2 border-indigo" href="/projects">Projects</a><a class="p-1 rounded-sm text-xl mr-2 hover:border-b-2 border-indigo" href="/talks">Talks</a><a class="p-1 rounded-sm text-xl mr-2 hover:border-b-2 border-indigo" href="/blogs">Blogs</a></div></div></div></header><main class="p-6 flex justify-center"><article><div class="flex justify-center font-[Arial] max-w-[864px] text-center"><h1 class="text-5xl font-bold bg-indigo px-5 py-2 rounded-sm text-shadow-lg leading-[1.1]">《架构整洁之道》读书笔记 - 设计原则篇</h1></div><time dateTime="2024-12-11" class="text-center block my-4 text-sm opacity-60">December	11, 2024</time><section><div class="markdown-body-fancy max-w-3xl"><h2 id="概述"><a aria-hidden="true" tabindex="-1" href="#概述"><span class="icon icon-link"></span></a>概述</h2>
<h2 id="solid原则"><a aria-hidden="true" tabindex="-1" href="#solid原则"><span class="icon icon-link"></span></a>SOLID原则</h2>
<ul>
<li>SRP：单一职责原则。 该设计原则是某于康威圧律（Conway's Law）的一个推论——一个软件系统的最佳结构高度依赖于开发这个系统的组织的内部结构。这样，每个软件模块都有且只有一个需要被改变的理由。</li>
<li>OCP：开闭原则。 该设计原则是由 Bertrand Meyer 在 20 世纪 80 年代大力推广的，其核心要素是：如果软件系统想要更容易被改变，那么其设计就必须允许新增代码来修改系统行为，而非只能靠修改原来的代码。</li>
<li>LSP：里氏替换原则。 该设计原则是 Barbara Liskov 在 1988 年提出的一个著名的子类型定义。简单来说，这项原则的意思是如果想用可替换的组件来构建软件系统，那么这些组件就必须遵守同一个约定，以便让这些组件可以相互替换。</li>
<li>ISP：接口隔离原则。 这项设计原则主要告诫软件设计师应该在设计中避免不必要的依赖。</li>
<li>DIP：依赖反转原则。 该设计原则指出高层策略性的代码不应该依赖实现底层细节的代码，恰恰相反，那些实现底层细节的代码应该依赖高层策略性的代码。</li>
</ul>
<h3 id="单一职责原则"><a aria-hidden="true" tabindex="-1" href="#单一职责原则"><span class="icon icon-link"></span></a>单一职责原则</h3>
<p>每个模块都应该只做一件事。</p>
<p>任何一个软件模块都应该有且仅有一个被修改的原因。</p>
<p>任何一个软件模块都应该只对某一类行为者负责。</p>
<p>单一职责原则主要讨论的是函数和类之间的关系——但是它在两个讨论层面上会以不同的形式出现。在组件层面，我们可以将其称为共同闭包原则（Common Closure Principle)，在软件架构层面，它则是用于奠定架构边界的变更轴心（Axis of Change）</p>
<h3 id="开闭原则"><a aria-hidden="true" tabindex="-1" href="#开闭原则"><span class="icon icon-link"></span></a>开闭原则</h3>
<p>设计良好的计算机软件应该易于扩展，同时抗拒修改。</p>
<p>一个设计良好的计算机系统应该在不需要修改的前提下就可以轻易被扩展。</p>
<h3 id="里氏替换原则"><a aria-hidden="true" tabindex="-1" href="#里氏替换原则"><span class="icon icon-link"></span></a>里氏替换原则</h3>
<p>如果对于每个类型是 S 的对象 o1 都存在一个类型为 T 的对象 o2，能使操作 T 类型的程序 P 在用 o2 替换 o1 时行为保持不变，我们就可以将 S 称为 T 的子类型。</p>
<p>LSP 可以且应该被应用于软件架构层面，因为一旦违背了可替换也该系统架构就不得不为此增添大量复杂的应对机制。</p>
<h3 id="接口隔离原则"><a aria-hidden="true" tabindex="-1" href="#接口隔离原则"><span class="icon icon-link"></span></a>接口隔离原则</h3>
<p>在一般情况下，任何层次的软件设计如果依赖于不需要的东西，都会是有害的。从源代码层次来说，这样的依赖关系会导致不必要的重新编译和重新部署，对更高层次的软件架构设计来说，问题也是类似的。</p>
<p>任何层次的软件设计如果依赖了它并不需要的东西，就会带来意料之外的麻烦。</p>
<h3 id="依赖反转原则"><a aria-hidden="true" tabindex="-1" href="#依赖反转原则"><span class="icon icon-link"></span></a>依赖反转原则</h3>
<ol>
<li>应在代码中多使用抽象接口，尽量避免使用那些多变的具体实现类。同时，对象的创建过程也应该受到严格限制，对此，我们通常会选择用抽象工厂（abstract factory）这个设计模式。</li>
<li>不要在具体实现类上创建衍生类。</li>
<li>不要覆盖（override）包含具体实现的函数。</li>
<li>应避免在代码中写入与任何具体实现相关的名字，或者是其他容易变动的事物的名字。</li>
</ol></div></section><div class="mt-10 max-w-3xl"><h3 class="text-2xl font-bold mb-4">评论</h3><p>加载评论中...</p></div></article></main><footer class="bg-neutral-50 border-t border-neutral-200 text-center text-xs opacity-50 py-4">© 2022,<!-- --> <a rel="noopener noreferrer" class="hover:underline hover:bg-indigo" href="https://github.com/LZS911" target="_blank">LZS_911</a>, build with<!-- --> <a rel="noopener noreferrer" class="underline hover:bg-indigo" href="https://nextjs.org/" target="_blank">Next.js</a> <!-- -->and<!-- --> <a rel="noopener noreferrer" class="underline hover:bg-indigo" href="https://pages.github.com/?(null)" target="_blank">GitHub Pages</a></footer></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"《架构整洁之道》读书笔记 - 设计原则篇","date":"2024-12-11","slug":"《架构整洁之道》读书笔记 - 设计原则篇","author":"Ai.Haibara","content":"\u003ch2 id=\"概述\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#概述\"\u003e\u003cspan class=\"icon icon-link\"\u003e\u003c/span\u003e\u003c/a\u003e概述\u003c/h2\u003e\n\u003ch2 id=\"solid原则\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#solid原则\"\u003e\u003cspan class=\"icon icon-link\"\u003e\u003c/span\u003e\u003c/a\u003eSOLID原则\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eSRP：单一职责原则。 该设计原则是某于康威圧律（Conway's Law）的一个推论——一个软件系统的最佳结构高度依赖于开发这个系统的组织的内部结构。这样，每个软件模块都有且只有一个需要被改变的理由。\u003c/li\u003e\n\u003cli\u003eOCP：开闭原则。 该设计原则是由 Bertrand Meyer 在 20 世纪 80 年代大力推广的，其核心要素是：如果软件系统想要更容易被改变，那么其设计就必须允许新增代码来修改系统行为，而非只能靠修改原来的代码。\u003c/li\u003e\n\u003cli\u003eLSP：里氏替换原则。 该设计原则是 Barbara Liskov 在 1988 年提出的一个著名的子类型定义。简单来说，这项原则的意思是如果想用可替换的组件来构建软件系统，那么这些组件就必须遵守同一个约定，以便让这些组件可以相互替换。\u003c/li\u003e\n\u003cli\u003eISP：接口隔离原则。 这项设计原则主要告诫软件设计师应该在设计中避免不必要的依赖。\u003c/li\u003e\n\u003cli\u003eDIP：依赖反转原则。 该设计原则指出高层策略性的代码不应该依赖实现底层细节的代码，恰恰相反，那些实现底层细节的代码应该依赖高层策略性的代码。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"单一职责原则\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#单一职责原则\"\u003e\u003cspan class=\"icon icon-link\"\u003e\u003c/span\u003e\u003c/a\u003e单一职责原则\u003c/h3\u003e\n\u003cp\u003e每个模块都应该只做一件事。\u003c/p\u003e\n\u003cp\u003e任何一个软件模块都应该有且仅有一个被修改的原因。\u003c/p\u003e\n\u003cp\u003e任何一个软件模块都应该只对某一类行为者负责。\u003c/p\u003e\n\u003cp\u003e单一职责原则主要讨论的是函数和类之间的关系——但是它在两个讨论层面上会以不同的形式出现。在组件层面，我们可以将其称为共同闭包原则（Common Closure Principle)，在软件架构层面，它则是用于奠定架构边界的变更轴心（Axis of Change）\u003c/p\u003e\n\u003ch3 id=\"开闭原则\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#开闭原则\"\u003e\u003cspan class=\"icon icon-link\"\u003e\u003c/span\u003e\u003c/a\u003e开闭原则\u003c/h3\u003e\n\u003cp\u003e设计良好的计算机软件应该易于扩展，同时抗拒修改。\u003c/p\u003e\n\u003cp\u003e一个设计良好的计算机系统应该在不需要修改的前提下就可以轻易被扩展。\u003c/p\u003e\n\u003ch3 id=\"里氏替换原则\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#里氏替换原则\"\u003e\u003cspan class=\"icon icon-link\"\u003e\u003c/span\u003e\u003c/a\u003e里氏替换原则\u003c/h3\u003e\n\u003cp\u003e如果对于每个类型是 S 的对象 o1 都存在一个类型为 T 的对象 o2，能使操作 T 类型的程序 P 在用 o2 替换 o1 时行为保持不变，我们就可以将 S 称为 T 的子类型。\u003c/p\u003e\n\u003cp\u003eLSP 可以且应该被应用于软件架构层面，因为一旦违背了可替换也该系统架构就不得不为此增添大量复杂的应对机制。\u003c/p\u003e\n\u003ch3 id=\"接口隔离原则\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#接口隔离原则\"\u003e\u003cspan class=\"icon icon-link\"\u003e\u003c/span\u003e\u003c/a\u003e接口隔离原则\u003c/h3\u003e\n\u003cp\u003e在一般情况下，任何层次的软件设计如果依赖于不需要的东西，都会是有害的。从源代码层次来说，这样的依赖关系会导致不必要的重新编译和重新部署，对更高层次的软件架构设计来说，问题也是类似的。\u003c/p\u003e\n\u003cp\u003e任何层次的软件设计如果依赖了它并不需要的东西，就会带来意料之外的麻烦。\u003c/p\u003e\n\u003ch3 id=\"依赖反转原则\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#依赖反转原则\"\u003e\u003cspan class=\"icon icon-link\"\u003e\u003c/span\u003e\u003c/a\u003e依赖反转原则\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003e应在代码中多使用抽象接口，尽量避免使用那些多变的具体实现类。同时，对象的创建过程也应该受到严格限制，对此，我们通常会选择用抽象工厂（abstract factory）这个设计模式。\u003c/li\u003e\n\u003cli\u003e不要在具体实现类上创建衍生类。\u003c/li\u003e\n\u003cli\u003e不要覆盖（override）包含具体实现的函数。\u003c/li\u003e\n\u003cli\u003e应避免在代码中写入与任何具体实现相关的名字，或者是其他容易变动的事物的名字。\u003c/li\u003e\n\u003c/ol\u003e","theme":"fancy","tag":[null]}},"__N_SSG":true},"page":"/posts/[slug]","query":{"slug":"《架构整洁之道》读书笔记 - 设计原则篇"},"buildId":"YweoWqZUfFtvB-M1jJ2CU","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>