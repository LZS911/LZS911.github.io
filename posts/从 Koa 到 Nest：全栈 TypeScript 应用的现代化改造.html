<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><link rel="apple-touch-icon" sizes="180x180" href="/favicon/apple-touch-icon.png"/><link rel="icon" type="image/png" sizes="32x32" href="/favicon/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="16x16" href="/favicon/favicon-16x16.png"/><link rel="manifest" href="/favicon/site.webmanifest"/><link rel="mask-icon" href="/favicon/safari-pinned-tab.svg" color="#000000"/><link rel="shortcut icon" href="/favicon/favicon.ico"/><meta name="msapplication-TileColor" content="#000000"/><meta name="msapplication-config" content="/favicon/browserconfig.xml"/><meta name="theme-color" content="#000"/><link rel="alternate" type="application/rss+xml" href="/feed.xml"/><meta property="og:image" content="https://og-image.vercel.app/Next.js%20Blog%20Starter%20Example.png?theme=light&amp;md=1&amp;fontSize=100px&amp;images=https%3A%2F%2Fassets.vercel.com%2Fimage%2Fupload%2Ffront%2Fassets%2Fdesign%2Fnextjs-black-logo.svg"/><title>从 Koa 到 Nest：全栈 TypeScript 应用的现代化改造.md | Ai.Haibara codes</title><meta name="next-head-count" content="14"/><link rel="preload" href="/_next/static/css/8681f744d5932be6.css" as="style"/><link rel="stylesheet" href="/_next/static/css/8681f744d5932be6.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-8fa1640cc84ba8fe.js" defer=""></script><script src="/_next/static/chunks/framework-3b5a00d5d7e8d93b.js" defer=""></script><script src="/_next/static/chunks/main-59a90320855f5cf5.js" defer=""></script><script src="/_next/static/chunks/pages/_app-f46e289d7ac5e197.js" defer=""></script><script src="/_next/static/chunks/799-575b46febca3af7d.js" defer=""></script><script src="/_next/static/chunks/399-cac0cd8ed02bf02a.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bslug%5D-e2afa3a98c674f72.js" defer=""></script><script src="/_next/static/wBpNrlS8IoSL3vUDbJeTY/_buildManifest.js" defer=""></script><script src="/_next/static/wBpNrlS8IoSL3vUDbJeTY/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="min-h-screen"><header class="text-white bg-black drop-shadow-2xl"><div class="mx-auto my-0 max-w-[960px] py-6 px-4 flex items-center"><div class="flex items-center"><img alt="Ai.Haibara" src="/assets/blog/authors/haibara_2.jpg" width="100" height="100" decoding="async" data-nimg="1" class=" rounded-full" loading="lazy" style="color:transparent"/></div><div class="ml-6"><a class=" font-bold text-3xl" href="/">Ai.Haibara codes</a><div class="mt-2"><a class="p-1 rounded-sm text-xl mr-2 hover:border-b-2 border-indigo" href="/">Home</a><a class="p-1 rounded-sm text-xl mr-2 hover:border-b-2 border-indigo" href="/projects">Projects</a><a class="p-1 rounded-sm text-xl mr-2 hover:border-b-2 border-indigo" href="/talks">Talks</a><a class="p-1 rounded-sm text-xl mr-2 hover:border-b-2 border-indigo" href="/blogs">Blogs</a></div></div></div></header><main class="p-6 flex justify-center"><article><div class="flex justify-center font-[Arial] max-w-[864px] text-center"><h1 class="text-5xl font-bold bg-indigo px-5 py-2 rounded-sm text-shadow-lg leading-[1.1]">从 Koa 到 Nest：全栈 TypeScript 应用的现代化改造.md</h1></div><time dateTime="2024-11-28" class="text-center block my-4 text-sm opacity-60">November	28, 2024</time><section><div class="markdown-body-fancy max-w-3xl"><h2 id="引言"><a aria-hidden="true" tabindex="-1" href="#引言"><span class="icon icon-link"></span></a>引言</h2>
<h3 id="项目背景"><a aria-hidden="true" tabindex="-1" href="#项目背景"><span class="icon icon-link"></span></a>项目背景</h3>
<p>项目最初采用以下技术栈构建:
后端: Koa + TypeScript
数据存储: 文件系统
前端: React + Ant Design
部署: Docker</p>
<p>Koa 是一个轻量级的 Node.js Web 框架,通过中间件架构提供了优雅的 API 设计。项目初期选择 Koa 是看中其简洁性和灵活性。</p>
<ol>
<li>完整技术栈
Node
Typescript
Koa
React + antd</li>
<li>构建方式
启动 node 环境的 docker 镜像，进入镜像 clone 代码然后通过脚本启动服务</li>
</ol>
<h3 id="痛点分析"><a aria-hidden="true" tabindex="-1" href="#痛点分析"><span class="icon icon-link"></span></a>痛点分析</h3>
<p>随着项目规模扩大,原有架构暴露出几个主要问题:</p>
<ol>
<li>数据存储的局限性</li>
</ol>
<ul>
<li>文件系统存储难以支持复杂查询</li>
<li>数据一致性难以保证</li>
<li>性能瓶颈明显</li>
</ul>
<ol start="2">
<li>构建部署流程繁琐</li>
</ol>
<ul>
<li>需要在 Docker 内手动克隆代码</li>
<li>部署步骤多,容易出错</li>
<li>CI/CD 支持不完善</li>
</ul>
<ol start="3">
<li>类型安全问题</li>
</ol>
<ul>
<li>前后端 API 类型定义分离</li>
<li>类型不一致导致运行时错误</li>
<li>代码维护成本高</li>
</ul>
<ol start="4">
<li>代码数据耦合</li>
</ol>
<ul>
<li>部分业务数据硬编码在代码中</li>
<li>修改数据需要重新部署</li>
<li>不利于后期维护</li>
</ul>
<h4 id="改造的目标和预期成果"><a aria-hidden="true" tabindex="-1" href="#改造的目标和预期成果"><span class="icon icon-link"></span></a>改造的目标和预期成果。</h4>
<ol>
<li>引入 MySQL 作为数据持久层</li>
<li>优化项目构建以及发布方式</li>
<li><strong>前后端类型安全</strong></li>
<li>代码与数据解耦</li>
</ol>
<h2 id="技术选型与评估"><a aria-hidden="true" tabindex="-1" href="#技术选型与评估"><span class="icon icon-link"></span></a>技术选型与评估</h2>
<h3 id="后端框架-nestjs"><a aria-hidden="true" tabindex="-1" href="#后端框架-nestjs"><span class="icon icon-link"></span></a>后端框架: Nest.js</h3>
<p>选择 Nest.js 的主要原因:</p>
<ul>
<li>完整的企业级框架支持</li>
<li>优秀的 TypeScript 支持</li>
<li>模块化架构,利于代码组织</li>
<li>丰富的生态系统</li>
</ul>
<h3 id="orm-层-prisma"><a aria-hidden="true" tabindex="-1" href="#orm-层-prisma"><span class="icon icon-link"></span></a>ORM 层: Prisma</h3>
<p>Prisma 作为现代化的 ORM 框架:</p>
<ul>
<li>类型安全的数据库访问</li>
<li>强大的数据模型定义</li>
<li>自动生成类型定义</li>
<li>支持数据库迁移</li>
</ul>
<h3 id="ts-test"><a aria-hidden="true" tabindex="-1" href="#ts-test"><span class="icon icon-link"></span></a><a href="https://ts-rest.com/">ts-test</a></h3>
<p>ts-rest 提供了端到端的类型安全解决方案</p>
<h3 id="数据持久层"><a aria-hidden="true" tabindex="-1" href="#数据持久层"><span class="icon icon-link"></span></a>数据持久层</h3>
<p><a href="https://relph1119.github.io/mysql-learning-notes/#/mysql/00-%E4%B8%87%E9%87%8C%E9%95%BF%E5%BE%81%E7%AC%AC%E4%B8%80%E6%AD%A5%EF%BC%88%E9%9D%9E%E5%B8%B8%E9%87%8D%E8%A6%81%EF%BC%89-%E5%A6%82%E4%BD%95%E6%84%89%E5%BF%AB%E7%9A%84%E9%98%85%E8%AF%BB%E6%9C%AC%E5%B0%8F%E5%86%8C">MySQL</a></p>
<h3 id="ui"><a aria-hidden="true" tabindex="-1" href="#ui"><span class="icon icon-link"></span></a>UI</h3>
<p>调整为 React + <a href="https://ui.shadcn.com/">shadcn/ui</a> 的组合</p>
<h3 id="部署方案优化"><a aria-hidden="true" tabindex="-1" href="#部署方案优化"><span class="icon icon-link"></span></a>部署方案优化</h3>
<p>新的部署流程:</p>
<ul>
<li>构建 Docker 镜像并推送到私有仓库</li>
<li>服务器拉取 docker-compose 配置</li>
<li>自动化部署和服务编排</li>
</ul>
<h2 id="改造实施"><a aria-hidden="true" tabindex="-1" href="#改造实施"><span class="icon icon-link"></span></a>改造实施</h2>
<h3 id="阶段规划"><a aria-hidden="true" tabindex="-1" href="#阶段规划"><span class="icon icon-link"></span></a>阶段规划</h3>
<ol>
<li>数据迁移阶段</li>
</ol>
<ul>
<li>设计数据库模型</li>
<li>数据迁移脚本开发</li>
<li>数据一致性验证</li>
</ul>
<ol start="2">
<li>后端改造阶段</li>
</ol>
<ul>
<li>引入 Nest.js 框架</li>
<li>整合 Prisma ORM</li>
<li>API 层重构</li>
</ul>
<ol start="3">
<li>前端改造阶段</li>
</ol>
<ul>
<li>UI 组件迁移</li>
<li>API 调用适配</li>
<li>类型系统对接</li>
</ul>
<h4 id="数据迁移"><a aria-hidden="true" tabindex="-1" href="#数据迁移"><span class="icon icon-link"></span></a>数据迁移</h4>
<h4 id="后端改造"><a aria-hidden="true" tabindex="-1" href="#后端改造"><span class="icon icon-link"></span></a>后端改造</h4>
<h4 id="前端改造"><a aria-hidden="true" tabindex="-1" href="#前端改造"><span class="icon icon-link"></span></a>前端改造</h4>
<h2 id="项目总结"><a aria-hidden="true" tabindex="-1" href="#项目总结"><span class="icon icon-link"></span></a>项目总结</h2>
<h3 id="重构过程中遇到的一些问题"><a aria-hidden="true" tabindex="-1" href="#重构过程中遇到的一些问题"><span class="icon icon-link"></span></a>重构过程中遇到的一些问题</h3>
<ol>
<li>依赖包 @octokit/core 类型问题</li>
<li>prisma 环境变量配置</li>
<li>api-model 包产物问题</li>
<li>数据库结构设计的不完善导致表结构频繁更新</li>
</ol></div></section></article></main><footer class="bg-neutral-50 border-t border-neutral-200 text-center text-xs opacity-50 py-4">© 2022,<!-- --> <a rel="noopener noreferrer" class="hover:underline hover:bg-indigo" href="https://github.com/LZS911" target="_blank">LZS_911</a>, build with<!-- --> <a rel="noopener noreferrer" class="underline hover:bg-indigo" href="https://nextjs.org/" target="_blank">Next.js</a> <!-- -->and<!-- --> <a rel="noopener noreferrer" class="underline hover:bg-indigo" href="https://pages.github.com/?(null)" target="_blank">GitHub Pages</a></footer></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"从 Koa 到 Nest：全栈 TypeScript 应用的现代化改造.md","date":"2024-11-28","slug":"从 Koa 到 Nest：全栈 TypeScript 应用的现代化改造","author":"Ai.Haibara","content":"\u003ch2 id=\"引言\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#引言\"\u003e\u003cspan class=\"icon icon-link\"\u003e\u003c/span\u003e\u003c/a\u003e引言\u003c/h2\u003e\n\u003ch3 id=\"项目背景\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#项目背景\"\u003e\u003cspan class=\"icon icon-link\"\u003e\u003c/span\u003e\u003c/a\u003e项目背景\u003c/h3\u003e\n\u003cp\u003e项目最初采用以下技术栈构建:\n后端: Koa + TypeScript\n数据存储: 文件系统\n前端: React + Ant Design\n部署: Docker\u003c/p\u003e\n\u003cp\u003eKoa 是一个轻量级的 Node.js Web 框架,通过中间件架构提供了优雅的 API 设计。项目初期选择 Koa 是看中其简洁性和灵活性。\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e完整技术栈\nNode\nTypescript\nKoa\nReact + antd\u003c/li\u003e\n\u003cli\u003e构建方式\n启动 node 环境的 docker 镜像，进入镜像 clone 代码然后通过脚本启动服务\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3 id=\"痛点分析\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#痛点分析\"\u003e\u003cspan class=\"icon icon-link\"\u003e\u003c/span\u003e\u003c/a\u003e痛点分析\u003c/h3\u003e\n\u003cp\u003e随着项目规模扩大,原有架构暴露出几个主要问题:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e数据存储的局限性\u003c/li\u003e\n\u003c/ol\u003e\n\u003cul\u003e\n\u003cli\u003e文件系统存储难以支持复杂查询\u003c/li\u003e\n\u003cli\u003e数据一致性难以保证\u003c/li\u003e\n\u003cli\u003e性能瓶颈明显\u003c/li\u003e\n\u003c/ul\u003e\n\u003col start=\"2\"\u003e\n\u003cli\u003e构建部署流程繁琐\u003c/li\u003e\n\u003c/ol\u003e\n\u003cul\u003e\n\u003cli\u003e需要在 Docker 内手动克隆代码\u003c/li\u003e\n\u003cli\u003e部署步骤多,容易出错\u003c/li\u003e\n\u003cli\u003eCI/CD 支持不完善\u003c/li\u003e\n\u003c/ul\u003e\n\u003col start=\"3\"\u003e\n\u003cli\u003e类型安全问题\u003c/li\u003e\n\u003c/ol\u003e\n\u003cul\u003e\n\u003cli\u003e前后端 API 类型定义分离\u003c/li\u003e\n\u003cli\u003e类型不一致导致运行时错误\u003c/li\u003e\n\u003cli\u003e代码维护成本高\u003c/li\u003e\n\u003c/ul\u003e\n\u003col start=\"4\"\u003e\n\u003cli\u003e代码数据耦合\u003c/li\u003e\n\u003c/ol\u003e\n\u003cul\u003e\n\u003cli\u003e部分业务数据硬编码在代码中\u003c/li\u003e\n\u003cli\u003e修改数据需要重新部署\u003c/li\u003e\n\u003cli\u003e不利于后期维护\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4 id=\"改造的目标和预期成果\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#改造的目标和预期成果\"\u003e\u003cspan class=\"icon icon-link\"\u003e\u003c/span\u003e\u003c/a\u003e改造的目标和预期成果。\u003c/h4\u003e\n\u003col\u003e\n\u003cli\u003e引入 MySQL 作为数据持久层\u003c/li\u003e\n\u003cli\u003e优化项目构建以及发布方式\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e前后端类型安全\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003e代码与数据解耦\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2 id=\"技术选型与评估\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#技术选型与评估\"\u003e\u003cspan class=\"icon icon-link\"\u003e\u003c/span\u003e\u003c/a\u003e技术选型与评估\u003c/h2\u003e\n\u003ch3 id=\"后端框架-nestjs\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#后端框架-nestjs\"\u003e\u003cspan class=\"icon icon-link\"\u003e\u003c/span\u003e\u003c/a\u003e后端框架: Nest.js\u003c/h3\u003e\n\u003cp\u003e选择 Nest.js 的主要原因:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e完整的企业级框架支持\u003c/li\u003e\n\u003cli\u003e优秀的 TypeScript 支持\u003c/li\u003e\n\u003cli\u003e模块化架构,利于代码组织\u003c/li\u003e\n\u003cli\u003e丰富的生态系统\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"orm-层-prisma\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#orm-层-prisma\"\u003e\u003cspan class=\"icon icon-link\"\u003e\u003c/span\u003e\u003c/a\u003eORM 层: Prisma\u003c/h3\u003e\n\u003cp\u003ePrisma 作为现代化的 ORM 框架:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e类型安全的数据库访问\u003c/li\u003e\n\u003cli\u003e强大的数据模型定义\u003c/li\u003e\n\u003cli\u003e自动生成类型定义\u003c/li\u003e\n\u003cli\u003e支持数据库迁移\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"ts-test\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#ts-test\"\u003e\u003cspan class=\"icon icon-link\"\u003e\u003c/span\u003e\u003c/a\u003e\u003ca href=\"https://ts-rest.com/\"\u003ets-test\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003ets-rest 提供了端到端的类型安全解决方案\u003c/p\u003e\n\u003ch3 id=\"数据持久层\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#数据持久层\"\u003e\u003cspan class=\"icon icon-link\"\u003e\u003c/span\u003e\u003c/a\u003e数据持久层\u003c/h3\u003e\n\u003cp\u003e\u003ca href=\"https://relph1119.github.io/mysql-learning-notes/#/mysql/00-%E4%B8%87%E9%87%8C%E9%95%BF%E5%BE%81%E7%AC%AC%E4%B8%80%E6%AD%A5%EF%BC%88%E9%9D%9E%E5%B8%B8%E9%87%8D%E8%A6%81%EF%BC%89-%E5%A6%82%E4%BD%95%E6%84%89%E5%BF%AB%E7%9A%84%E9%98%85%E8%AF%BB%E6%9C%AC%E5%B0%8F%E5%86%8C\"\u003eMySQL\u003c/a\u003e\u003c/p\u003e\n\u003ch3 id=\"ui\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#ui\"\u003e\u003cspan class=\"icon icon-link\"\u003e\u003c/span\u003e\u003c/a\u003eUI\u003c/h3\u003e\n\u003cp\u003e调整为 React + \u003ca href=\"https://ui.shadcn.com/\"\u003eshadcn/ui\u003c/a\u003e 的组合\u003c/p\u003e\n\u003ch3 id=\"部署方案优化\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#部署方案优化\"\u003e\u003cspan class=\"icon icon-link\"\u003e\u003c/span\u003e\u003c/a\u003e部署方案优化\u003c/h3\u003e\n\u003cp\u003e新的部署流程:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e构建 Docker 镜像并推送到私有仓库\u003c/li\u003e\n\u003cli\u003e服务器拉取 docker-compose 配置\u003c/li\u003e\n\u003cli\u003e自动化部署和服务编排\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"改造实施\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#改造实施\"\u003e\u003cspan class=\"icon icon-link\"\u003e\u003c/span\u003e\u003c/a\u003e改造实施\u003c/h2\u003e\n\u003ch3 id=\"阶段规划\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#阶段规划\"\u003e\u003cspan class=\"icon icon-link\"\u003e\u003c/span\u003e\u003c/a\u003e阶段规划\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003e数据迁移阶段\u003c/li\u003e\n\u003c/ol\u003e\n\u003cul\u003e\n\u003cli\u003e设计数据库模型\u003c/li\u003e\n\u003cli\u003e数据迁移脚本开发\u003c/li\u003e\n\u003cli\u003e数据一致性验证\u003c/li\u003e\n\u003c/ul\u003e\n\u003col start=\"2\"\u003e\n\u003cli\u003e后端改造阶段\u003c/li\u003e\n\u003c/ol\u003e\n\u003cul\u003e\n\u003cli\u003e引入 Nest.js 框架\u003c/li\u003e\n\u003cli\u003e整合 Prisma ORM\u003c/li\u003e\n\u003cli\u003eAPI 层重构\u003c/li\u003e\n\u003c/ul\u003e\n\u003col start=\"3\"\u003e\n\u003cli\u003e前端改造阶段\u003c/li\u003e\n\u003c/ol\u003e\n\u003cul\u003e\n\u003cli\u003eUI 组件迁移\u003c/li\u003e\n\u003cli\u003eAPI 调用适配\u003c/li\u003e\n\u003cli\u003e类型系统对接\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4 id=\"数据迁移\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#数据迁移\"\u003e\u003cspan class=\"icon icon-link\"\u003e\u003c/span\u003e\u003c/a\u003e数据迁移\u003c/h4\u003e\n\u003ch4 id=\"后端改造\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#后端改造\"\u003e\u003cspan class=\"icon icon-link\"\u003e\u003c/span\u003e\u003c/a\u003e后端改造\u003c/h4\u003e\n\u003ch4 id=\"前端改造\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#前端改造\"\u003e\u003cspan class=\"icon icon-link\"\u003e\u003c/span\u003e\u003c/a\u003e前端改造\u003c/h4\u003e\n\u003ch2 id=\"项目总结\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#项目总结\"\u003e\u003cspan class=\"icon icon-link\"\u003e\u003c/span\u003e\u003c/a\u003e项目总结\u003c/h2\u003e\n\u003ch3 id=\"重构过程中遇到的一些问题\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#重构过程中遇到的一些问题\"\u003e\u003cspan class=\"icon icon-link\"\u003e\u003c/span\u003e\u003c/a\u003e重构过程中遇到的一些问题\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003e依赖包 @octokit/core 类型问题\u003c/li\u003e\n\u003cli\u003eprisma 环境变量配置\u003c/li\u003e\n\u003cli\u003eapi-model 包产物问题\u003c/li\u003e\n\u003cli\u003e数据库结构设计的不完善导致表结构频繁更新\u003c/li\u003e\n\u003c/ol\u003e","theme":"fancy","tag":[null]}},"__N_SSG":true},"page":"/posts/[slug]","query":{"slug":"从 Koa 到 Nest：全栈 TypeScript 应用的现代化改造"},"buildId":"wBpNrlS8IoSL3vUDbJeTY","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>