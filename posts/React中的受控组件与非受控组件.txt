1:"$Sreact.fragment"
2:I[7555,[],""]
3:I[1901,["874","static/chunks/874-16716eedeadde879.js","39","static/chunks/app/error-d036ecfd03716e30.js"],"default"]
4:I[1295,[],""]
5:I[9543,["874","static/chunks/874-16716eedeadde879.js","345","static/chunks/app/not-found-2113bbd7a2f55e8f.js"],"default"]
8:I[9665,[],"MetadataBoundary"]
a:I[9665,[],"OutletBoundary"]
d:I[4911,[],"AsyncMetadataOutlet"]
f:I[8460,["209","static/chunks/app/loading-b73dd9bd22c3caa2.js"],"default"]
10:I[9665,[],"ViewportBoundary"]
12:I[6614,[],""]
:HL["/_next/static/media/569ce4b8f30dc480-s.p.woff2","font",{"crossOrigin":"","type":"font/woff2"}]
:HL["/_next/static/media/93f479601ee12b01-s.p.woff2","font",{"crossOrigin":"","type":"font/woff2"}]
:HL["/_next/static/css/8aef079a875c7130.css","style"]
0:{"P":null,"b":"CLj95Pt5WAl4X3X-i4b9l","p":"","c":["","posts","React%E4%B8%AD%E7%9A%84%E5%8F%97%E6%8E%A7%E7%BB%84%E4%BB%B6%E4%B8%8E%E9%9D%9E%E5%8F%97%E6%8E%A7%E7%BB%84%E4%BB%B6"],"i":false,"f":[[["",{"children":["(article)",{"children":["posts",{"children":[["slug","React%E4%B8%AD%E7%9A%84%E5%8F%97%E6%8E%A7%E7%BB%84%E4%BB%B6%E4%B8%8E%E9%9D%9E%E5%8F%97%E6%8E%A7%E7%BB%84%E4%BB%B6","d"],{"children":["__PAGE__",{}]}]}]}]},"$undefined","$undefined",true],["",["$","$1","c",{"children":[[["$","link","0",{"rel":"stylesheet","href":"/_next/static/css/8aef079a875c7130.css","precedence":"next","crossOrigin":"$undefined","nonce":"$undefined"}]],["$","html",null,{"lang":"en","children":["$","body",null,{"className":"__variable_5cfdac __variable_9a8899 antialiased","children":["$","$L2",null,{"parallelRouterKey":"children","error":"$3","errorStyles":[],"errorScripts":[],"template":["$","$L4",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":[["$","$L5",null,{}],[]],"forbidden":"$undefined","unauthorized":"$undefined"}]}]}]]}],{"children":["(article)",["$","$1","c",{"children":[null,"$L6"]}],{"children":["posts",["$","$1","c",{"children":[null,["$","$L2",null,{"parallelRouterKey":"children","error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L4",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","forbidden":"$undefined","unauthorized":"$undefined"}]]}],{"children":[["slug","React%E4%B8%AD%E7%9A%84%E5%8F%97%E6%8E%A7%E7%BB%84%E4%BB%B6%E4%B8%8E%E9%9D%9E%E5%8F%97%E6%8E%A7%E7%BB%84%E4%BB%B6","d"],["$","$1","c",{"children":[null,["$","$L2",null,{"parallelRouterKey":"children","error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L4",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","forbidden":"$undefined","unauthorized":"$undefined"}]]}],{"children":["__PAGE__",["$","$1","c",{"children":["$L7",["$","$L8",null,{"children":"$L9"}],null,["$","$La",null,{"children":["$Lb","$Lc",["$","$Ld",null,{"promise":"$@e"}]]}]]}],{},null,false]},null,false]},null,false]},null,false]},[["$","$Lf","l",{}],[],[]],false],["$","$1","h",{"children":[null,["$","$1","DcNC3UQQtEzUjs6ozG1B1",{"children":[["$","$L10",null,{"children":"$L11"}],["$","meta",null,{"name":"next-size-adjust","content":""}]]}],null]}],false]],"m":"$undefined","G":["$12","$undefined"],"s":false,"S":true}
13:I[8565,["874","static/chunks/874-16716eedeadde879.js","766","static/chunks/766-eeb113df4f56c105.js","651","static/chunks/app/(article)/layout-18bcffe355ed9a9b.js"],"default"]
14:"$Sreact.suspense"
15:I[4911,[],"AsyncMetadata"]
6:["$","html",null,{"lang":"en","children":["$","body",null,{"className":"__variable_5cfdac __variable_9a8899 antialiased","children":[["$","div",null,{"className":"min-h-screen","children":[["$","$L13",null,{}],["$","main",null,{"className":"p-6 flex justify-center","children":["$","$L2",null,{"parallelRouterKey":"children","error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L4",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","forbidden":"$undefined","unauthorized":"$undefined"}]}],["$","footer",null,{"className":"bg-neutral-50 border-t border-neutral-200 text-center text-xs opacity-50 py-4","children":["© 2022 - ",2025,["$","a",null,{"rel":"noopener noreferrer","className":"hover:underline hover:bg-indigo","href":"https://github.com/LZS911","target":"_blank","children":", LZS_911"}],", build with"," ",["$","a",null,{"rel":"noopener noreferrer","className":"underline hover:bg-indigo","href":"https://nextjs.org/","target":"_blank","children":"Next.js"}]," ","and"," ",["$","a",null,{"rel":"noopener noreferrer","className":"underline hover:bg-indigo","href":"https://pages.github.com/?(null)","target":"_blank","children":"GitHub Pages"}]]}]]}],false]}]}]
9:["$","$14",null,{"fallback":null,"children":["$","$L15",null,{"promise":"$@16"}]}]
c:null
17:I[5099,["766","static/chunks/766-eeb113df4f56c105.js","62","static/chunks/62-36d7af331e30e687.js","520","static/chunks/app/(article)/posts/%5Bslug%5D/page-2ec56518ac6621da.js"],"ThemeLoader"]
18:T47b8,<h2 id="什么是受控组件和非受控组件"><a aria-hidden="true" tabindex="-1" href="#什么是受控组件和非受控组件"><span class="icon icon-link"></span></a>什么是受控组件和非受控组件?</h2>
<ol>
<li>
<p>非受控组件</p>
<pre><code class="hljs language-jsx"><span class="hljs-keyword">const</span> <span class="hljs-title class_">Input</span>: <span class="hljs-variable constant_">FC</span> = <span class="hljs-function">() =></span> {
  <span class="hljs-keyword">const</span> [value, setValue] = <span class="hljs-title function_">useState</span>(<span class="hljs-string">''</span>);

  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">input</span> <span class="hljs-attr">value</span>=<span class="hljs-string">{value}</span> <span class="hljs-attr">onChange</span>=<span class="hljs-string">{(e)</span> =></span> setValue(e.target.value)} /></span>;
};
</code></pre>
<p>首先我们看一段代码, 代码定义了一个自定义 <code>Input</code> 组件, 并且不接收任何 <code>props</code>. 所以该组件的 <code>value</code> 只能通过用户的操作来更改, 而不能通过代码去控制, 所以叫做 <strong>非受控组件</strong>.</p>
</li>
<li>
<p>受控组件</p>
<blockquote>
<p>在 HTML 中, 表单元素 (如&#x3C;input>、 &#x3C;textarea> 和 &#x3C;select>)通常自己维护 state, 并根据用户输入进行更新.而在 React 中, 可变状态 (mutable state)通常保存在组件的 state 属性中, 并且只能通过使用 setState()来更新.
我们可以把两者结合起来, 使 React 的 state 成为“唯一数据源”.渲染表单的 React 组件还控制着用户输入过程中表单发生的操作.被 React 以这种方式控制取值的表单输入元素就叫做“受控组件”.</p>
</blockquote>
<pre><code class="hljs language-tsx"> <span class="hljs-keyword">const</span> <span class="hljs-title class_">Input</span>:<span class="hljs-variable constant_">FC</span> = <span class="hljs-function">(<span class="hljs-params">{value:<span class="hljs-built_in">string</span>,  onChange:(val:<span class="hljs-built_in">string</span>) => <span class="hljs-built_in">void</span>}</span>) =></span> {
   <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">input</span> <span class="hljs-attr">value</span>=<span class="hljs-string">{value}</span> <span class="hljs-attr">onChange</span>=<span class="hljs-string">{e</span> =></span> onChange(e.target.value)}/></span>
 }
</code></pre>
<p>对之前的非受控 <code>Input</code> 组件的代码稍微做一点调整, 将它内部的状态改为 <code>props</code> 传入, 它就变成了受控组件, 因为此时 <code>Input</code> 组件的值取决于外部传递进来的 <code>props</code>.</p>
</li>
</ol>
<p>了解了这两个概念后, 我们思考一个问题, <code>ant-design</code> 中的 <code>Input</code> 组件是受控组件还是非受控组件?</p>
<p>答案是它既可以是受控组件, 也可以是非受控组件, 完全取决于项目中怎么去使用.</p>
<h2 id="如何实现"><a aria-hidden="true" tabindex="-1" href="#如何实现"><span class="icon icon-link"></span></a>如何实现?</h2>
<h3 id="最简单的方案-内外两个状态-手动同步"><a aria-hidden="true" tabindex="-1" href="#最简单的方案-内外两个状态-手动同步"><span class="icon icon-link"></span></a>最简单的方案: 内外两个状态, 手动同步</h3>
<p>考虑到实现成本的复杂度, 我们需要让组件逻辑在两种模式下, 尽可能的保持一致, 减少逻辑分支意味着更好的可维护性和可读性. 所以, 自然而然的, 我们可以很容易想到这个方案:</p>
<p><code>Child</code> 组件内部始终存在一个状态, 不管它处于哪种模式, 它都直接使用自己内部的状态. 而当它处于受控模式时, 我们让它的内部状态和 <code>Parent</code> 组件中的状态手动保持同步.</p>
<p>代码如下:</p>
<pre><code class="hljs language-tsx"><span class="hljs-keyword">const</span> <span class="hljs-title class_">Input</span>: <span class="hljs-title class_">React</span>.<span class="hljs-property">FC</span>&#x3C;{ <span class="hljs-attr">value</span>?: <span class="hljs-built_in">string</span>; <span class="hljs-attr">onChange</span>?: <span class="hljs-function">(<span class="hljs-params"><span class="hljs-attr">val</span>: <span class="hljs-built_in">string</span></span>) =></span> <span class="hljs-built_in">void</span> }> = <span class="hljs-function">(<span class="hljs-params">{
  value,
  onChange,
}</span>) =></span> {
  <span class="hljs-keyword">const</span> isControlled = value !== <span class="hljs-literal">undefined</span>;

  <span class="hljs-keyword">const</span> [innerValue, setInnerValue] = <span class="hljs-title function_">useState</span>(value);

  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =></span> {
    <span class="hljs-keyword">if</span> (isControlled) {
      <span class="hljs-title function_">setInnerValue</span>(value);
    }
  });

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">input</span>
      <span class="hljs-attr">value</span>=<span class="hljs-string">{innerValue}</span>
      <span class="hljs-attr">onChange</span>=<span class="hljs-string">{(e)</span> =></span> {
        if (!isControlled) {
          setInnerValue(e.target.value);
        }
        onChange(e.target.value);
      }}
    /></span>
  );
};
</code></pre>
<p>仔细看上面的代码, 我们会发现在受控模式下存在两个问题:</p>
<p>原子性: <code>Child</code> 内部状态的更新会比 <code>Parent</code> 组件晚一个渲染周期, 存在 <code>tearing</code> 的问题
性能:因为是在 <code>useEffect</code> 中通过 <code>setState</code> 来做的状态同步, 所以会额外的触发一次渲染, 存在性能问题
明确问题之后, 我们来逐个解决:</p>
<h3 id="原子性"><a aria-hidden="true" tabindex="-1" href="#原子性"><span class="icon icon-link"></span></a>原子性</h3>
<p>这个问题其实很好解决, 我们其实并不需要 Child 和 Parent 的状态保持非常严格的每时每刻都一致, 我们只需要判断, 如果组件此时处于受控模式, 那么直接使用来自外部的状态就可以了:</p>
<p>这样, 即便状态的同步是存在延迟的, 但是 Child 组件所真正使用到的值一定是最新的.</p>
<p>代码如下:</p>
<pre><code class="hljs language-tsx"><span class="hljs-keyword">const</span> <span class="hljs-title class_">Input</span>: <span class="hljs-title class_">React</span>.<span class="hljs-property">FC</span>&#x3C;{ <span class="hljs-attr">value</span>?: <span class="hljs-built_in">string</span>; <span class="hljs-attr">onChange</span>?: <span class="hljs-function">(<span class="hljs-params"><span class="hljs-attr">val</span>: <span class="hljs-built_in">string</span></span>) =></span> <span class="hljs-built_in">void</span> }> = <span class="hljs-function">(<span class="hljs-params">{
  value,
  onChange,
}</span>) =></span> {
  <span class="hljs-keyword">const</span> isControlled = value !== <span class="hljs-literal">undefined</span>;

  <span class="hljs-keyword">const</span> [innerValue, setInnerValue] = <span class="hljs-title function_">useState</span>(value);

  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =></span> {
    <span class="hljs-keyword">if</span> (isControlled) {
      <span class="hljs-title function_">setInnerValue</span>(value);
    }
  });

  <span class="hljs-keyword">const</span> finalValue = isControlled ? value : innerValue;

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">input</span>
      <span class="hljs-attr">value</span>=<span class="hljs-string">{finalValue}</span>
      <span class="hljs-attr">onChange</span>=<span class="hljs-string">{(e)</span> =></span> {
        setInnerValue(e.target.value);
        onChange(e.target.value);
      }}
    /></span>
  );
};
</code></pre>
<h3 id="性能"><a aria-hidden="true" tabindex="-1" href="#性能"><span class="icon icon-link"></span></a>性能</h3>
<p>因为我们是在 <code>useEffect</code> 去做状态同步的, 所以自然会额外的多触发一次 <code>Child</code> 组件的重渲染.如果 <code>Child</code> 组件比较简单的话, 那出现的性能影响可以忽略不计.但是对于一些复杂的组件 (例如 <code>Picker</code>), 多渲染一次带来的性能问题是比较严重的.</p>
<p>那有没有办法在 <code>Child</code> 组件的 <code>render</code> 阶段就直接更新 <code>value</code> 状态呢?</p>
<p>我们重新考虑一下这行 <code>useState</code> 的代码:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> [innerValue, setInnerValue] = <span class="hljs-title function_">useState</span>(value);
</code></pre>
<p>当我们创建这个 <code>State</code> 时? 我们的目的是什么? <code>State</code> 的本质是什么?</p>
<p>如果比较简单粗暴的分析, 我们可以把 <code>State</code> 拆成两部分:</p>
<p><code>State</code> 是用来存放数据的, 它让我们在组件的渲染函数之外, 可以“持久化”一些数据
<code>State</code> 的更新可以触发重新渲染, 因为 <code>React</code> 会感知 <code>State</code> 的更新
如果写一个公式的话, 可以写成:</p>
<p><code>State = 存放数据 + 触发重新渲染</code></p>
<p>而但就存放数据来看, 我们可以直接使用 Ref；同样, 如果只是需要触发重新渲染, 我们可以使用类似于 <code>setFlag({})</code> 或者 <code>setCount(v => v + 1)</code> 这样的强制方式 (虽然很蠢, 但想必 90% 的 React 开发者都曾经这么写过).</p>
<p>那我们根据这个推断来调整一下上面的公式:</p>
<p><code>State = Ref + forceUpdate()</code></p>
<p>我们已经非常接近了, 根据这个公式, 我们可以把 <code>Child</code> 组件中的 <code>State</code> 拆成一个 <code>Ref</code> 和一个 <code>forceUpdate</code> 函数:</p>
<p>这样一来, 我们就可以直接在 <code>render</code> 阶段直接更新 <code>ref</code> 的值了:</p>
<pre><code class="hljs language-tsx"><span class="hljs-keyword">const</span> <span class="hljs-title class_">Input</span>: <span class="hljs-title class_">React</span>.<span class="hljs-property">FC</span>&#x3C;{ <span class="hljs-attr">value</span>: <span class="hljs-built_in">string</span>; <span class="hljs-attr">onChange</span>: <span class="hljs-function">(<span class="hljs-params"><span class="hljs-attr">val</span>: <span class="hljs-built_in">string</span></span>) =></span> <span class="hljs-built_in">void</span> }> = <span class="hljs-function">(<span class="hljs-params">{
  value,
  onChange,
}</span>) =></span> {
  <span class="hljs-keyword">const</span> isControlled = value !== <span class="hljs-literal">undefined</span>;

  <span class="hljs-keyword">const</span> stateRef = useRef&#x3C;T | <span class="hljs-literal">undefined</span>>(value);

  <span class="hljs-keyword">const</span> [, setFlag] = <span class="hljs-title function_">useState</span>({});

  <span class="hljs-keyword">const</span> <span class="hljs-title function_">forceUpdate</span> = (<span class="hljs-params"></span>) => {
    <span class="hljs-title function_">setFlag</span>({});
  };

  <span class="hljs-keyword">const</span> finalValue = isControlled ? value : stateRef.<span class="hljs-property">current</span>;

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">input</span>
      <span class="hljs-attr">value</span>=<span class="hljs-string">{finalValue}</span>
      <span class="hljs-attr">onChange</span>=<span class="hljs-string">{(e)</span> =></span> {
        stateRef.current = e.target.value;
        forceUpdate();
        onChange(e.target.value);
      }}
    /></span>
  );
};
</code></pre>
<p>再回头看下代码, 会发现, 为什么还需要判断根据受控和非受控模式来使用不同的值呢? 既然 <code>stateRef.current</code> 一定是最新的值, 那么完全可以简化成 <code>Child</code> 组件永远使用内部存放的数据 (<code>Ref</code>):</p>
<pre><code class="hljs language-tsx"><span class="hljs-keyword">const</span> <span class="hljs-title class_">Input</span>: <span class="hljs-title class_">React</span>.<span class="hljs-property">FC</span>&#x3C;{ <span class="hljs-attr">value</span>: <span class="hljs-built_in">string</span>; <span class="hljs-attr">onChange</span>: <span class="hljs-function">(<span class="hljs-params"><span class="hljs-attr">val</span>: <span class="hljs-built_in">string</span></span>) =></span> <span class="hljs-built_in">void</span> }> = <span class="hljs-function">(<span class="hljs-params">{
  value,
  onChange,
}</span>) =></span> {
  <span class="hljs-keyword">const</span> isControlled = value !== <span class="hljs-literal">undefined</span>;

  <span class="hljs-keyword">const</span> stateRef = useRef&#x3C;T | <span class="hljs-literal">undefined</span>>(value);

  <span class="hljs-keyword">if</span> (isControlled) {
    stateRef.<span class="hljs-property">current</span> = props.<span class="hljs-property">value</span>;
  }
  <span class="hljs-keyword">const</span> [, setFlag] = <span class="hljs-title function_">useState</span>({});

  <span class="hljs-keyword">const</span> <span class="hljs-title function_">forceUpdate</span> = (<span class="hljs-params"></span>) => {
    <span class="hljs-title function_">setFlag</span>({});
  };

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">input</span>
      <span class="hljs-attr">value</span>=<span class="hljs-string">{finalValue}</span>
      <span class="hljs-attr">onChange</span>=<span class="hljs-string">{(e)</span> =></span> {
        stateRef.current = e.target.value;
        forceUpdate();
        onChange(e.target.value);
      }}
    /></span>
  );
};
</code></pre>
<h3 id="抽象与复用-usepropsvalue"><a aria-hidden="true" tabindex="-1" href="#抽象与复用-usepropsvalue"><span class="icon icon-link"></span></a>抽象与复用: usePropsValue</h3>
<p>上述代码仅实现了一个 <code>Input</code> 组件, 当需要定义其他组件时, 仍需要重复上述中的某些代码, 所以我们把核心代码抽离成一个自定义 <code>Hooks</code>, 同时完善一些细节. 代码如下:</p>
<pre><code class="hljs language-ts"><span class="hljs-keyword">import</span> { useUpdate } <span class="hljs-keyword">from</span> <span class="hljs-string">'ahooks'</span>;
<span class="hljs-keyword">import</span> { isFunction } <span class="hljs-keyword">from</span> <span class="hljs-string">'lodash-es'</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">SetStateAction</span>, useRef } <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">type</span> usePropsValueOptions&#x3C;T> = {
  <span class="hljs-attr">value</span>?: T;
  <span class="hljs-attr">defaultValue</span>?: T;
  <span class="hljs-attr">onChange</span>?: <span class="hljs-function">(<span class="hljs-params"><span class="hljs-attr">value</span>?: T</span>) =></span> <span class="hljs-built_in">void</span>;
};

<span class="hljs-keyword">const</span> usePropsValue = &#x3C;T>({
  value,
  defaultValue,
  onChange,
}: usePropsValueOptions&#x3C;T>): [
  T | <span class="hljs-literal">undefined</span>,
  <span class="hljs-function">(<span class="hljs-params"><span class="hljs-attr">v</span>: <span class="hljs-title class_">SetStateAction</span>&#x3C;T | <span class="hljs-literal">undefined</span>></span>) =></span> <span class="hljs-built_in">void</span>
] => {
  <span class="hljs-keyword">const</span> isControlled = value !== <span class="hljs-literal">undefined</span>;
  <span class="hljs-keyword">const</span> update = <span class="hljs-title function_">useUpdate</span>();
  <span class="hljs-keyword">const</span> stateRef = useRef&#x3C;T | <span class="hljs-literal">undefined</span>>(isControlled ? value : defaultValue);

  <span class="hljs-keyword">if</span> (isControlled) {
    stateRef.<span class="hljs-property">current</span> = value;
  }

  <span class="hljs-keyword">const</span> <span class="hljs-title function_">setState</span> = (<span class="hljs-params"><span class="hljs-attr">v</span>: <span class="hljs-title class_">SetStateAction</span>&#x3C;T | <span class="hljs-literal">undefined</span>></span>) => {
    <span class="hljs-keyword">const</span> nextValue = <span class="hljs-title function_">isFunction</span>(v) ? <span class="hljs-title function_">v</span>(stateRef.<span class="hljs-property">current</span>) : v;

    <span class="hljs-keyword">if</span> (nextValue === stateRef.<span class="hljs-property">current</span>) {
      <span class="hljs-keyword">return</span>;
    }

    stateRef.<span class="hljs-property">current</span> = nextValue;
    <span class="hljs-title function_">update</span>();
    onChange?.(nextValue);
  };
  <span class="hljs-keyword">return</span> [stateRef.<span class="hljs-property">current</span>, setState];
};

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> usePropsValue;
</code></pre>
<p>这样, 在各种组件中, 我们可以直接使用 <code>usePropsValue</code>, 用法和 <code>useState</code> 非常接近:</p>
<pre><code class="hljs language-ts"><span class="hljs-keyword">const</span> [internalValue, setInternalValue] = usePropsValue&#x3C;<span class="hljs-built_in">string</span>>({
  defaultValue,
  value,
  onChange,
});

<span class="hljs-keyword">return</span> (
  <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">input</span>
    <span class="hljs-attr">value</span>=<span class="hljs-string">{internalValue}</span>
    <span class="hljs-attr">onChange</span>=<span class="hljs-string">{(e)</span> =></span> {
      setInternalValue(e.target.value);
    }}
  /></span>
);
</code></pre>7:["$","article",null,{"children":[["$","div",null,{"className":"flex justify-center font-[Arial] max-w-[864px] text-center","children":["$","h1",null,{"className":"text-[2.5rem] font-bold bg-lime-300 px-5 py-2 rounded-sm text-shadow-lg leading-[1.1]","children":"React中的受控组件与非受控组件"}]}],["$","time",null,{"dateTime":"2022-09-14","className":"text-center block my-4 text-sm opacity-60","children":"September\t14, 2022"}],[null,["$","$L17",null,{"theme":"jzman"}],["$","section",null,{"className":"markdown-body-jzman max-w-3xl","dangerouslySetInnerHTML":{"__html":"$18"}}]],null]}]
11:[["$","meta","0",{"charSet":"utf-8"}],["$","meta","1",{"name":"viewport","content":"width=device-width, initial-scale=1"}]]
b:null
16:{"metadata":[["$","title","0",{"children":"Ai.Haibara codes"}],["$","meta","1",{"name":"description","content":"LZS Blog"}],["$","link","2",{"rel":"icon","href":"/favicon.ico","type":"image/x-icon","sizes":"96x96"}]],"error":null,"digest":"$undefined"}
e:{"metadata":"$16:metadata","error":null,"digest":"$undefined"}
