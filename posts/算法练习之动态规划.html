<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><link rel="apple-touch-icon" sizes="180x180" href="/favicon/apple-touch-icon.png"/><link rel="icon" type="image/png" sizes="32x32" href="/favicon/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="16x16" href="/favicon/favicon-16x16.png"/><link rel="manifest" href="/favicon/site.webmanifest"/><link rel="mask-icon" href="/favicon/safari-pinned-tab.svg" color="#000000"/><link rel="shortcut icon" href="/favicon/favicon.ico"/><meta name="msapplication-TileColor" content="#000000"/><meta name="msapplication-config" content="/favicon/browserconfig.xml"/><meta name="theme-color" content="#000"/><link rel="alternate" type="application/rss+xml" href="/feed.xml"/><meta property="og:image" content="https://og-image.vercel.app/Next.js%20Blog%20Starter%20Example.png?theme=light&amp;md=1&amp;fontSize=100px&amp;images=https%3A%2F%2Fassets.vercel.com%2Fimage%2Fupload%2Ffront%2Fassets%2Fdesign%2Fnextjs-black-logo.svg"/><title>算法练习之动态规划 | Ai.Haibara codes</title><meta name="next-head-count" content="14"/><link rel="preload" href="/_next/static/css/a5eda337cc81d9ab.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a5eda337cc81d9ab.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee7e63bc15b31913.js" defer=""></script><script src="/_next/static/chunks/framework-3b5a00d5d7e8d93b.js" defer=""></script><script src="/_next/static/chunks/main-59a90320855f5cf5.js" defer=""></script><script src="/_next/static/chunks/pages/_app-91d7f786791773ad.js" defer=""></script><script src="/_next/static/chunks/799-575b46febca3af7d.js" defer=""></script><script src="/_next/static/chunks/642-f55f53346f993b53.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bslug%5D-d7fe9a31c8040d96.js" defer=""></script><script src="/_next/static/k52nxzxdyD3iAtLv2GTft/_buildManifest.js" defer=""></script><script src="/_next/static/k52nxzxdyD3iAtLv2GTft/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="min-h-screen"><header class="text-white bg-black drop-shadow-2xl"><div class="mx-auto my-0 max-w-[960px] py-6 px-4 flex items-center"><div class="flex items-center"><img alt="Ai.Haibara" src="/assets/blog/authors/haibara_2.jpg" width="100" height="100" decoding="async" data-nimg="1" class=" rounded-full" loading="lazy" style="color:transparent"/></div><div class="ml-6"><a class=" font-bold text-3xl" href="/">Ai.Haibara codes</a><div class="mt-2"><a class="p-1 rounded-sm text-xl mr-2 hover:border-b-2 border-indigo" href="/">Home</a><a class="p-1 rounded-sm text-xl mr-2 hover:border-b-2 border-indigo" href="/projects">Projects</a><a class="p-1 rounded-sm text-xl mr-2 hover:border-b-2 border-indigo" href="/talks">Talks</a><a class="p-1 rounded-sm text-xl mr-2 hover:border-b-2 border-indigo" href="/blogs">Blogs</a></div></div></div></header><main class="p-6 flex justify-center"><article><div class="flex justify-center font-[Arial] max-w-[864px] text-center"><h1 class="text-5xl font-bold bg-indigo px-5 py-2 rounded-sm text-shadow-lg leading-[1.1]">算法练习之动态规划</h1></div><time dateTime="2021-11-12" class="text-center block my-4 text-sm opacity-60">November	12, 2021</time><section><div class="markdown-body-awesome-green max-w-3xl"><h3 id="粉刷房间"><a aria-hidden="true" tabindex="-1" href="#粉刷房间"><span class="icon icon-link"></span></a>粉刷房间</h3>
<hr>
<h4 id="题目描述"><a aria-hidden="true" tabindex="-1" href="#题目描述"><span class="icon icon-link"></span></a>题目描述</h4>
<pre><code>假如有一排房子，共 n 个，每个房子可以被粉刷成红色、蓝色或者绿色这三种颜色中的一种，你需要粉刷所有的房子并且使其相邻的两个房子颜色不能相同。

当然，因为市场上不同颜色油漆的价格不同，所以房子粉刷成不同颜色的花费成本也是不同的。每个房子粉刷成不同颜色的花费是以一个 n x 3 的正整数矩阵 costs 来表示的。

例如，costs[0][0] 表示第 0 号房子粉刷成红色的成本花费；costs[1][2] 表示第 1 号房子粉刷成绿色的花费，以此类推。

请计算出粉刷完所有房子最少的花费成本。
</code></pre>
<h4 id="解题思路"><a aria-hidden="true" tabindex="-1" href="#解题思路"><span class="icon icon-link"></span></a>解题思路</h4>
<ol>
<li>递归暴力法</li>
</ol>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">minCost</span>(<span class="hljs-params"><span class="hljs-attr">costs</span>: <span class="hljs-built_in">number</span>[][]</span>) {
  <span class="hljs-keyword">const</span> len = costs.<span class="hljs-property">length</span>;

  <span class="hljs-keyword">if</span> (len === <span class="hljs-number">1</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">min</span>(...costs[<span class="hljs-number">0</span>]);
  }

  <span class="hljs-keyword">const</span> fn = (<span class="hljs-attr">prevIndex</span>: <span class="hljs-built_in">number</span>, <span class="hljs-attr">count</span>: <span class="hljs-built_in">number</span>, <span class="hljs-attr">res</span>: <span class="hljs-built_in">number</span>): <span class="hljs-function"><span class="hljs-params">number</span> =></span> {
    <span class="hljs-keyword">if</span> (count === len) {
      <span class="hljs-keyword">return</span> res;
    }
    <span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>&#x3C;<span class="hljs-built_in">number</span>, <span class="hljs-built_in">number</span>[]>([
      [<span class="hljs-number">0</span>, [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>]],
      [<span class="hljs-number">1</span>, [<span class="hljs-number">0</span>, <span class="hljs-number">2</span>]],
      [<span class="hljs-number">2</span>, [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>]],
    ]);
    <span class="hljs-keyword">const</span> arr = map.<span class="hljs-title function_">get</span>(prevIndex)!;
    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">min</span>(...arr.<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">v</span>) =></span> <span class="hljs-title function_">fn</span>(v, count + <span class="hljs-number">1</span>, res + costs[count][v])));
  };

  <span class="hljs-keyword">const</span> r = <span class="hljs-title function_">fn</span>(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, costs[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]);
  <span class="hljs-keyword">const</span> g = <span class="hljs-title function_">fn</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, costs[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]);
  <span class="hljs-keyword">const</span> b = <span class="hljs-title function_">fn</span>(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>, costs[<span class="hljs-number">0</span>][<span class="hljs-number">2</span>]);
  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">min</span>(r, g, b);
}
</code></pre>
<p>不需要思考任何算法的一种方式, 直接递归计算出所有可能, 但是中间会包含很多重复计算, 执行 <code>LeetCode</code> 测试时会超时. 所以需要进一步思考最优解.</p>
<ol start="2">
<li>动态规划</li>
</ol>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">minCost</span>(<span class="hljs-params"><span class="hljs-attr">costs</span>: <span class="hljs-built_in">number</span>[][]</span>) {
  <span class="hljs-keyword">let</span> [r, b, g] = costs[<span class="hljs-number">0</span>];
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &#x3C; costs.<span class="hljs-property">length</span>; ++i) {
    [r, b, g] = [
      <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">min</span>(b, g) + costs[i][<span class="hljs-number">0</span>],
      <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">min</span>(r, g) + costs[i][<span class="hljs-number">1</span>],
      <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">min</span>(r, b) + costs[i][<span class="hljs-number">2</span>],
    ];
  }
  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">min</span>(r, g, b);
}
</code></pre>
<p>大致思路:</p>
<ol>
<li>定义变量 r、b、g 分别表示粉刷至某一间房时红色、蓝色、绿色所需粉刷的最小花费</li>
</ol>
<ul>
<li>let [r, b, g] = costs[0] 即表示粉刷第一间时的最小花费</li>
</ul>
<ol start="2">
<li>从第二间房开始遍历, 第二间房可粉刷三种任意颜色, 但限制条件为粉刷红色时, 前一间房子的粉刷只能为绿色或蓝色, 依次类推, 得到</li>
</ol>
<pre><code class="hljs language-typescript">[r, b, g] = [
  <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">min</span>(b, g) + costs[i][<span class="hljs-number">0</span>],
  <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">min</span>(r, g) + costs[i][<span class="hljs-number">1</span>],
  <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">min</span>(r, b) + costs[i][<span class="hljs-number">2</span>],
];
</code></pre>
<p><strong>这里使用了 ES6 的数组解构, 类似于对象解构, 赋值语句左侧为粉刷到第 <code>i</code> 间房对应某一种颜色时的总最小花费, 右侧 <code>Math.min(b, g)</code> 表示粉刷到上一间房使用蓝色或绿色时的最小花费, <code>costs[i][0]</code> 表示粉刷第 <code>i</code>间房时使用红色的情况, 然后继续赋值给 r, 后续依次类推. 当循环结束时, 最后得到的 <code>r、b、g</code> 即为最后一间房子粉刷某一种情况的总花费, 最后返回最小值即可.</strong></p>
<hr>
<h3 id="todo持续更新"><a aria-hidden="true" tabindex="-1" href="#todo持续更新"><span class="icon icon-link"></span></a>.........<em>todo(持续更新)</em></h3></div></section><div class="mt-10 max-w-3xl"><h3 class="text-2xl font-bold mb-4">评论</h3><p>加载评论中...</p></div></article></main><footer class="bg-neutral-50 border-t border-neutral-200 text-center text-xs opacity-50 py-4">© 2022,<!-- --> <a rel="noopener noreferrer" class="hover:underline hover:bg-indigo" href="https://github.com/LZS911" target="_blank">LZS_911</a>, build with<!-- --> <a rel="noopener noreferrer" class="underline hover:bg-indigo" href="https://nextjs.org/" target="_blank">Next.js</a> <!-- -->and<!-- --> <a rel="noopener noreferrer" class="underline hover:bg-indigo" href="https://pages.github.com/?(null)" target="_blank">GitHub Pages</a></footer></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"算法练习之动态规划","date":"2021-11-12","slug":"算法练习之动态规划","author":"LZS_911","content":"\u003ch3 id=\"粉刷房间\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#粉刷房间\"\u003e\u003cspan class=\"icon icon-link\"\u003e\u003c/span\u003e\u003c/a\u003e粉刷房间\u003c/h3\u003e\n\u003chr\u003e\n\u003ch4 id=\"题目描述\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#题目描述\"\u003e\u003cspan class=\"icon icon-link\"\u003e\u003c/span\u003e\u003c/a\u003e题目描述\u003c/h4\u003e\n\u003cpre\u003e\u003ccode\u003e假如有一排房子，共 n 个，每个房子可以被粉刷成红色、蓝色或者绿色这三种颜色中的一种，你需要粉刷所有的房子并且使其相邻的两个房子颜色不能相同。\n\n当然，因为市场上不同颜色油漆的价格不同，所以房子粉刷成不同颜色的花费成本也是不同的。每个房子粉刷成不同颜色的花费是以一个 n x 3 的正整数矩阵 costs 来表示的。\n\n例如，costs[0][0] 表示第 0 号房子粉刷成红色的成本花费；costs[1][2] 表示第 1 号房子粉刷成绿色的花费，以此类推。\n\n请计算出粉刷完所有房子最少的花费成本。\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch4 id=\"解题思路\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#解题思路\"\u003e\u003cspan class=\"icon icon-link\"\u003e\u003c/span\u003e\u003c/a\u003e解题思路\u003c/h4\u003e\n\u003col\u003e\n\u003cli\u003e递归暴力法\u003c/li\u003e\n\u003c/ol\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-typescript\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eminCost\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003cspan class=\"hljs-attr\"\u003ecosts\u003c/span\u003e: \u003cspan class=\"hljs-built_in\"\u003enumber\u003c/span\u003e[][]\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e len = costs.\u003cspan class=\"hljs-property\"\u003elength\u003c/span\u003e;\n\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (len === \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eMath\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003emin\u003c/span\u003e(...costs[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e]);\n  }\n\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e fn = (\u003cspan class=\"hljs-attr\"\u003eprevIndex\u003c/span\u003e: \u003cspan class=\"hljs-built_in\"\u003enumber\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003ecount\u003c/span\u003e: \u003cspan class=\"hljs-built_in\"\u003enumber\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003eres\u003c/span\u003e: \u003cspan class=\"hljs-built_in\"\u003enumber\u003c/span\u003e): \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003enumber\u003c/span\u003e =\u003e\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (count === len) {\n      \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e res;\n    }\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e map = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eMap\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-built_in\"\u003enumber\u003c/span\u003e, \u003cspan class=\"hljs-built_in\"\u003enumber\u003c/span\u003e[]\u003e([\n      [\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, [\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e]],\n      [\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, [\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e]],\n      [\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, [\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e]],\n    ]);\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e arr = map.\u003cspan class=\"hljs-title function_\"\u003eget\u003c/span\u003e(prevIndex)!;\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eMath\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003emin\u003c/span\u003e(...arr.\u003cspan class=\"hljs-title function_\"\u003emap\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003ev\u003c/span\u003e) =\u003e\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efn\u003c/span\u003e(v, count + \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, res + costs[count][v])));\n  };\n\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e r = \u003cspan class=\"hljs-title function_\"\u003efn\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, costs[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e][\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e]);\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e g = \u003cspan class=\"hljs-title function_\"\u003efn\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, costs[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e][\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e]);\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e b = \u003cspan class=\"hljs-title function_\"\u003efn\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, costs[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e][\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e]);\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eMath\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003emin\u003c/span\u003e(r, g, b);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e不需要思考任何算法的一种方式, 直接递归计算出所有可能, 但是中间会包含很多重复计算, 执行 \u003ccode\u003eLeetCode\u003c/code\u003e 测试时会超时. 所以需要进一步思考最优解.\u003c/p\u003e\n\u003col start=\"2\"\u003e\n\u003cli\u003e动态规划\u003c/li\u003e\n\u003c/ol\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-typescript\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eminCost\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003cspan class=\"hljs-attr\"\u003ecosts\u003c/span\u003e: \u003cspan class=\"hljs-built_in\"\u003enumber\u003c/span\u003e[][]\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e [r, b, g] = costs[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e];\n  \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e (\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e i = \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e; i \u0026#x3C; costs.\u003cspan class=\"hljs-property\"\u003elength\u003c/span\u003e; ++i) {\n    [r, b, g] = [\n      \u003cspan class=\"hljs-title class_\"\u003eMath\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003emin\u003c/span\u003e(b, g) + costs[i][\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e],\n      \u003cspan class=\"hljs-title class_\"\u003eMath\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003emin\u003c/span\u003e(r, g) + costs[i][\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e],\n      \u003cspan class=\"hljs-title class_\"\u003eMath\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003emin\u003c/span\u003e(r, b) + costs[i][\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e],\n    ];\n  }\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eMath\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003emin\u003c/span\u003e(r, g, b);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e大致思路:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e定义变量 r、b、g 分别表示粉刷至某一间房时红色、蓝色、绿色所需粉刷的最小花费\u003c/li\u003e\n\u003c/ol\u003e\n\u003cul\u003e\n\u003cli\u003elet [r, b, g] = costs[0] 即表示粉刷第一间时的最小花费\u003c/li\u003e\n\u003c/ul\u003e\n\u003col start=\"2\"\u003e\n\u003cli\u003e从第二间房开始遍历, 第二间房可粉刷三种任意颜色, 但限制条件为粉刷红色时, 前一间房子的粉刷只能为绿色或蓝色, 依次类推, 得到\u003c/li\u003e\n\u003c/ol\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-typescript\"\u003e[r, b, g] = [\n  \u003cspan class=\"hljs-title class_\"\u003eMath\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003emin\u003c/span\u003e(b, g) + costs[i][\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e],\n  \u003cspan class=\"hljs-title class_\"\u003eMath\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003emin\u003c/span\u003e(r, g) + costs[i][\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e],\n  \u003cspan class=\"hljs-title class_\"\u003eMath\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003emin\u003c/span\u003e(r, b) + costs[i][\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e],\n];\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e这里使用了 ES6 的数组解构, 类似于对象解构, 赋值语句左侧为粉刷到第 \u003ccode\u003ei\u003c/code\u003e 间房对应某一种颜色时的总最小花费, 右侧 \u003ccode\u003eMath.min(b, g)\u003c/code\u003e 表示粉刷到上一间房使用蓝色或绿色时的最小花费, \u003ccode\u003ecosts[i][0]\u003c/code\u003e 表示粉刷第 \u003ccode\u003ei\u003c/code\u003e间房时使用红色的情况, 然后继续赋值给 r, 后续依次类推. 当循环结束时, 最后得到的 \u003ccode\u003er、b、g\u003c/code\u003e 即为最后一间房子粉刷某一种情况的总花费, 最后返回最小值即可.\u003c/strong\u003e\u003c/p\u003e\n\u003chr\u003e\n\u003ch3 id=\"todo持续更新\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#todo持续更新\"\u003e\u003cspan class=\"icon icon-link\"\u003e\u003c/span\u003e\u003c/a\u003e.........\u003cem\u003etodo(持续更新)\u003c/em\u003e\u003c/h3\u003e","ogImage":{"url":"/assets/blog/image/cover.jpg"},"coverImage":"/assets/blog/image/cover.jpg","theme":"awesome-green","tag":[null]}},"__N_SSG":true},"page":"/posts/[slug]","query":{"slug":"算法练习之动态规划"},"buildId":"k52nxzxdyD3iAtLv2GTft","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>