<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><link rel="apple-touch-icon" sizes="180x180" href="/favicon/apple-touch-icon.png"/><link rel="icon" type="image/png" sizes="32x32" href="/favicon/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="16x16" href="/favicon/favicon-16x16.png"/><link rel="manifest" href="/favicon/site.webmanifest"/><link rel="mask-icon" href="/favicon/safari-pinned-tab.svg" color="#000000"/><link rel="shortcut icon" href="/favicon/favicon.ico"/><meta name="msapplication-TileColor" content="#000000"/><meta name="msapplication-config" content="/favicon/browserconfig.xml"/><meta name="theme-color" content="#000"/><link rel="alternate" type="application/rss+xml" href="/feed.xml"/><meta property="og:image" content="https://og-image.vercel.app/Next.js%20Blog%20Starter%20Example.png?theme=light&amp;md=1&amp;fontSize=100px&amp;images=https%3A%2F%2Fassets.vercel.com%2Fimage%2Fupload%2Ffront%2Fassets%2Fdesign%2Fnextjs-black-logo.svg"/><title>算法练习之动态规划 | Ai.Haibara codes</title><meta name="next-head-count" content="14"/><link rel="preload" href="/_next/static/css/cbc0135ff184ccab.css" as="style"/><link rel="stylesheet" href="/_next/static/css/cbc0135ff184ccab.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-8fa1640cc84ba8fe.js" defer=""></script><script src="/_next/static/chunks/framework-3b5a00d5d7e8d93b.js" defer=""></script><script src="/_next/static/chunks/main-59a90320855f5cf5.js" defer=""></script><script src="/_next/static/chunks/pages/_app-f46e289d7ac5e197.js" defer=""></script><script src="/_next/static/chunks/799-575b46febca3af7d.js" defer=""></script><script src="/_next/static/chunks/399-cac0cd8ed02bf02a.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bslug%5D-ca05212d4081d62f.js" defer=""></script><script src="/_next/static/mgXzME5F3FYYzt3qXbTUJ/_buildManifest.js" defer=""></script><script src="/_next/static/mgXzME5F3FYYzt3qXbTUJ/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="min-h-screen"><header class="text-white bg-black drop-shadow-2xl"><div class="mx-auto my-0 max-w-[960px] py-6 px-4 flex items-center"><div class="flex items-center"><img alt="Ai.Haibara" src="/assets/blog/authors/haibara_2.jpg" width="100" height="100" decoding="async" data-nimg="1" class=" rounded-full" loading="lazy" style="color:transparent"/></div><div class="ml-6"><a class=" font-bold text-3xl" href="/">Ai.Haibara codes</a><div class="mt-2"><a class="p-1 rounded-sm text-xl mr-2 hover:border-b-2 border-indigo" href="/">Home</a><a class="p-1 rounded-sm text-xl mr-2 hover:border-b-2 border-indigo" href="/projects">Projects</a><a class="p-1 rounded-sm text-xl mr-2 hover:border-b-2 border-indigo" href="/talks">Talks</a><a class="p-1 rounded-sm text-xl mr-2 hover:border-b-2 border-indigo" href="/blogs">Blogs</a></div></div></div></header><main class="p-6 flex justify-center"><article><div class="flex justify-center font-[Arial]"><h1 class="text-5xl font-bold bg-indigo px-5 py-2 rounded-sm text-shadow-lg leading-[1.1]">算法练习之动态规划</h1></div><time dateTime="2021-11-12" class="text-center block my-4 text-sm opacity-60">November	12, 2021</time><section><div class="markdown-body-awesome-green max-w-3xl"><h3 id="粉刷房间"><a aria-hidden="true" tabindex="-1" href="#粉刷房间"><span class="icon icon-link"></span></a>粉刷房间</h3>
<hr>
<h4 id="题目描述"><a aria-hidden="true" tabindex="-1" href="#题目描述"><span class="icon icon-link"></span></a>题目描述</h4>
<pre><code>假如有一排房子，共 n 个，每个房子可以被粉刷成红色、蓝色或者绿色这三种颜色中的一种，你需要粉刷所有的房子并且使其相邻的两个房子颜色不能相同。

当然，因为市场上不同颜色油漆的价格不同，所以房子粉刷成不同颜色的花费成本也是不同的。每个房子粉刷成不同颜色的花费是以一个 n x 3 的正整数矩阵 costs 来表示的。

例如，costs[0][0] 表示第 0 号房子粉刷成红色的成本花费；costs[1][2] 表示第 1 号房子粉刷成绿色的花费，以此类推。

请计算出粉刷完所有房子最少的花费成本。
</code></pre>
<h4 id="解题思路"><a aria-hidden="true" tabindex="-1" href="#解题思路"><span class="icon icon-link"></span></a>解题思路</h4>
<ol>
<li>递归暴力法</li>
</ol>
<pre><code class="language-typescript">function minCost(costs: number[][]) {
  const len = costs.length;

  if (len === 1) {
    return Math.min(...costs[0]);
  }

  const fn = (prevIndex: number, count: number, res: number): number => {
    if (count === len) {
      return res;
    }
    const map = new Map&#x3C;number, number[]>([
      [0, [1, 2]],
      [1, [0, 2]],
      [2, [0, 1]],
    ]);
    const arr = map.get(prevIndex)!;
    return Math.min(...arr.map((v) => fn(v, count + 1, res + costs[count][v])));
  };

  const r = fn(0, 1, costs[0][0]);
  const g = fn(1, 1, costs[0][1]);
  const b = fn(2, 1, costs[0][2]);
  return Math.min(r, g, b);
}
</code></pre>
<p>不需要思考任何算法的一种方式, 直接递归计算出所有可能, 但是中间会包含很多重复计算, 执行 <code>LeetCode</code> 测试时会超时. 所以需要进一步思考最优解.</p>
<ol start="2">
<li>动态规划</li>
</ol>
<pre><code class="language-typescript">function minCost(costs: number[][]) {
  let [r, b, g] = costs[0];
  for (let i = 1; i &#x3C; costs.length; ++i) {
    [r, b, g] = [
      Math.min(b, g) + costs[i][0],
      Math.min(r, g) + costs[i][1],
      Math.min(r, b) + costs[i][2],
    ];
  }
  return Math.min(r, g, b);
}
</code></pre>
<p>大致思路:</p>
<ol>
<li>定义变量 r、b、g 分别表示粉刷至某一间房时红色、蓝色、绿色所需粉刷的最小花费</li>
</ol>
<ul>
<li>let [r, b, g] = costs[0] 即表示粉刷第一间时的最小花费</li>
</ul>
<ol start="2">
<li>从第二间房开始遍历, 第二间房可粉刷三种任意颜色, 但限制条件为粉刷红色时, 前一间房子的粉刷只能为绿色或蓝色, 依次类推, 得到</li>
</ol>
<pre><code class="language-typescript">[r, b, g] = [
  Math.min(b, g) + costs[i][0],
  Math.min(r, g) + costs[i][1],
  Math.min(r, b) + costs[i][2],
];
</code></pre>
<p><strong>这里使用了 ES6 的数组解构, 类似于对象解构, 赋值语句左侧为粉刷到第 <code>i</code> 间房对应某一种颜色时的总最小花费, 右侧 <code>Math.min(b, g)</code> 表示粉刷到上一间房使用蓝色或绿色时的最小花费, <code>costs[i][0]</code> 表示粉刷第 <code>i</code>间房时使用红色的情况, 然后继续赋值给 r, 后续依次类推. 当循环结束时, 最后得到的 <code>r、b、g</code> 即为最后一间房子粉刷某一种情况的总花费, 最后返回最小值即可.</strong></p>
<hr>
<h3 id="todo持续更新"><a aria-hidden="true" tabindex="-1" href="#todo持续更新"><span class="icon icon-link"></span></a>.........<em>todo(持续更新)</em></h3></div></section></article></main><footer class="bg-neutral-50 border-t border-neutral-200 text-center text-xs opacity-50 py-4">© 2022,<!-- --> <a rel="noopener noreferrer" class="hover:underline hover:bg-indigo" href="https://github.com/LZS911" target="_blank">LZS_911</a>, build with<!-- --> <a rel="noopener noreferrer" class="underline hover:bg-indigo" href="https://nextjs.org/" target="_blank">Next.js</a> <!-- -->and<!-- --> <a rel="noopener noreferrer" class="underline hover:bg-indigo" href="https://pages.github.com/?(null)" target="_blank">GitHub Pages</a></footer></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"算法练习之动态规划","date":"2021-11-12","slug":"算法练习之动态规划","author":"LZS_911","content":"\u003ch3 id=\"粉刷房间\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#粉刷房间\"\u003e\u003cspan class=\"icon icon-link\"\u003e\u003c/span\u003e\u003c/a\u003e粉刷房间\u003c/h3\u003e\n\u003chr\u003e\n\u003ch4 id=\"题目描述\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#题目描述\"\u003e\u003cspan class=\"icon icon-link\"\u003e\u003c/span\u003e\u003c/a\u003e题目描述\u003c/h4\u003e\n\u003cpre\u003e\u003ccode\u003e假如有一排房子，共 n 个，每个房子可以被粉刷成红色、蓝色或者绿色这三种颜色中的一种，你需要粉刷所有的房子并且使其相邻的两个房子颜色不能相同。\n\n当然，因为市场上不同颜色油漆的价格不同，所以房子粉刷成不同颜色的花费成本也是不同的。每个房子粉刷成不同颜色的花费是以一个 n x 3 的正整数矩阵 costs 来表示的。\n\n例如，costs[0][0] 表示第 0 号房子粉刷成红色的成本花费；costs[1][2] 表示第 1 号房子粉刷成绿色的花费，以此类推。\n\n请计算出粉刷完所有房子最少的花费成本。\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch4 id=\"解题思路\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#解题思路\"\u003e\u003cspan class=\"icon icon-link\"\u003e\u003c/span\u003e\u003c/a\u003e解题思路\u003c/h4\u003e\n\u003col\u003e\n\u003cli\u003e递归暴力法\u003c/li\u003e\n\u003c/ol\u003e\n\u003cpre\u003e\u003ccode class=\"language-typescript\"\u003efunction minCost(costs: number[][]) {\n  const len = costs.length;\n\n  if (len === 1) {\n    return Math.min(...costs[0]);\n  }\n\n  const fn = (prevIndex: number, count: number, res: number): number =\u003e {\n    if (count === len) {\n      return res;\n    }\n    const map = new Map\u0026#x3C;number, number[]\u003e([\n      [0, [1, 2]],\n      [1, [0, 2]],\n      [2, [0, 1]],\n    ]);\n    const arr = map.get(prevIndex)!;\n    return Math.min(...arr.map((v) =\u003e fn(v, count + 1, res + costs[count][v])));\n  };\n\n  const r = fn(0, 1, costs[0][0]);\n  const g = fn(1, 1, costs[0][1]);\n  const b = fn(2, 1, costs[0][2]);\n  return Math.min(r, g, b);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e不需要思考任何算法的一种方式, 直接递归计算出所有可能, 但是中间会包含很多重复计算, 执行 \u003ccode\u003eLeetCode\u003c/code\u003e 测试时会超时. 所以需要进一步思考最优解.\u003c/p\u003e\n\u003col start=\"2\"\u003e\n\u003cli\u003e动态规划\u003c/li\u003e\n\u003c/ol\u003e\n\u003cpre\u003e\u003ccode class=\"language-typescript\"\u003efunction minCost(costs: number[][]) {\n  let [r, b, g] = costs[0];\n  for (let i = 1; i \u0026#x3C; costs.length; ++i) {\n    [r, b, g] = [\n      Math.min(b, g) + costs[i][0],\n      Math.min(r, g) + costs[i][1],\n      Math.min(r, b) + costs[i][2],\n    ];\n  }\n  return Math.min(r, g, b);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e大致思路:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e定义变量 r、b、g 分别表示粉刷至某一间房时红色、蓝色、绿色所需粉刷的最小花费\u003c/li\u003e\n\u003c/ol\u003e\n\u003cul\u003e\n\u003cli\u003elet [r, b, g] = costs[0] 即表示粉刷第一间时的最小花费\u003c/li\u003e\n\u003c/ul\u003e\n\u003col start=\"2\"\u003e\n\u003cli\u003e从第二间房开始遍历, 第二间房可粉刷三种任意颜色, 但限制条件为粉刷红色时, 前一间房子的粉刷只能为绿色或蓝色, 依次类推, 得到\u003c/li\u003e\n\u003c/ol\u003e\n\u003cpre\u003e\u003ccode class=\"language-typescript\"\u003e[r, b, g] = [\n  Math.min(b, g) + costs[i][0],\n  Math.min(r, g) + costs[i][1],\n  Math.min(r, b) + costs[i][2],\n];\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e这里使用了 ES6 的数组解构, 类似于对象解构, 赋值语句左侧为粉刷到第 \u003ccode\u003ei\u003c/code\u003e 间房对应某一种颜色时的总最小花费, 右侧 \u003ccode\u003eMath.min(b, g)\u003c/code\u003e 表示粉刷到上一间房使用蓝色或绿色时的最小花费, \u003ccode\u003ecosts[i][0]\u003c/code\u003e 表示粉刷第 \u003ccode\u003ei\u003c/code\u003e间房时使用红色的情况, 然后继续赋值给 r, 后续依次类推. 当循环结束时, 最后得到的 \u003ccode\u003er、b、g\u003c/code\u003e 即为最后一间房子粉刷某一种情况的总花费, 最后返回最小值即可.\u003c/strong\u003e\u003c/p\u003e\n\u003chr\u003e\n\u003ch3 id=\"todo持续更新\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#todo持续更新\"\u003e\u003cspan class=\"icon icon-link\"\u003e\u003c/span\u003e\u003c/a\u003e.........\u003cem\u003etodo(持续更新)\u003c/em\u003e\u003c/h3\u003e","ogImage":{"url":"/assets/blog/image/cover.jpg"},"coverImage":"/assets/blog/image/cover.jpg","theme":"awesome-green","tag":[null]}},"__N_SSG":true},"page":"/posts/[slug]","query":{"slug":"算法练习之动态规划"},"buildId":"mgXzME5F3FYYzt3qXbTUJ","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>