<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><link rel="apple-touch-icon" sizes="180x180" href="/favicon/apple-touch-icon.png"/><link rel="icon" type="image/png" sizes="32x32" href="/favicon/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="16x16" href="/favicon/favicon-16x16.png"/><link rel="manifest" href="/favicon/site.webmanifest"/><link rel="mask-icon" href="/favicon/safari-pinned-tab.svg" color="#000000"/><link rel="shortcut icon" href="/favicon/favicon.ico"/><meta name="msapplication-TileColor" content="#000000"/><meta name="msapplication-config" content="/favicon/browserconfig.xml"/><meta name="theme-color" content="#000"/><link rel="alternate" type="application/rss+xml" href="/feed.xml"/><meta property="og:image" content="https://og-image.vercel.app/Next.js%20Blog%20Starter%20Example.png?theme=light&amp;md=1&amp;fontSize=100px&amp;images=https%3A%2F%2Fassets.vercel.com%2Fimage%2Fupload%2Ffront%2Fassets%2Fdesign%2Fnextjs-black-logo.svg"/><title>promise学习记录 | Ai.Haibara codes</title><meta name="next-head-count" content="14"/><link rel="preload" href="/_next/static/css/8681f744d5932be6.css" as="style"/><link rel="stylesheet" href="/_next/static/css/8681f744d5932be6.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-8fa1640cc84ba8fe.js" defer=""></script><script src="/_next/static/chunks/framework-3b5a00d5d7e8d93b.js" defer=""></script><script src="/_next/static/chunks/main-59a90320855f5cf5.js" defer=""></script><script src="/_next/static/chunks/pages/_app-f46e289d7ac5e197.js" defer=""></script><script src="/_next/static/chunks/799-575b46febca3af7d.js" defer=""></script><script src="/_next/static/chunks/399-cac0cd8ed02bf02a.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bslug%5D-e2afa3a98c674f72.js" defer=""></script><script src="/_next/static/d505lWANAwEkY6DLPcxRp/_buildManifest.js" defer=""></script><script src="/_next/static/d505lWANAwEkY6DLPcxRp/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="min-h-screen"><header class="text-white bg-black drop-shadow-2xl"><div class="mx-auto my-0 max-w-[960px] py-6 px-4 flex items-center"><div class="flex items-center"><img alt="Ai.Haibara" src="/assets/blog/authors/haibara_2.jpg" width="100" height="100" decoding="async" data-nimg="1" class=" rounded-full" loading="lazy" style="color:transparent"/></div><div class="ml-6"><a class=" font-bold text-3xl" href="/">Ai.Haibara codes</a><div class="mt-2"><a class="p-1 rounded-sm text-xl mr-2 hover:border-b-2 border-indigo" href="/">Home</a><a class="p-1 rounded-sm text-xl mr-2 hover:border-b-2 border-indigo" href="/projects">Projects</a><a class="p-1 rounded-sm text-xl mr-2 hover:border-b-2 border-indigo" href="/talks">Talks</a><a class="p-1 rounded-sm text-xl mr-2 hover:border-b-2 border-indigo" href="/blogs">Blogs</a></div></div></div></header><main class="p-6 flex justify-center"><article><div class="flex justify-center font-[Arial] max-w-[864px] text-center"><h1 class="text-5xl font-bold bg-indigo px-5 py-2 rounded-sm text-shadow-lg leading-[1.1]">promise学习记录</h1></div><time dateTime="2022-03-01" class="text-center block my-4 text-sm opacity-60">March	1, 2022</time><section><div class="markdown-body-simplicity-green max-w-3xl"><h2 id="1-一些相关的概念"><a aria-hidden="true" tabindex="-1" href="#1-一些相关的概念"><span class="icon icon-link"></span></a>1. 一些相关的概念</h2>
<h3 id="11-javascript-中的异步"><a aria-hidden="true" tabindex="-1" href="#11-javascript-中的异步"><span class="icon icon-link"></span></a>1.1 JavaScript 中的异步</h3>
<p>在 <code>JavaScript</code> 中, 程序中将来执行的部分并不一定在现在运行的部分执行完之后立即执行. 换句话说, 现在无法完成的任务将会异步完成, 因此并不会出现阻塞行为.</p>
<p>来看一段代码:</p>
<pre><code class="language-javascript">//现在执行的
const url = 'http://some.url.1';
//将来执行的
const data = ajax(url);
//接着现在执行的
console.log(data);
</code></pre>
<p>这里的 <code>data</code> 通常是不会包含 <code>ajax</code> 请求所返回的数据的. 因为用户在请求网络资源时并不希望阻塞所有的 UI 交互.</p>
<h3 id="12-回调函数"><a aria-hidden="true" tabindex="-1" href="#12-回调函数"><span class="icon icon-link"></span></a>1.2 回调函数</h3>
<p>从现在到将来的等待, 最简单的办法(并不唯一, 甚至不是最优办法)是使用一个通常称为回调函数的函数.
来看一段代码:</p>
<pre><code class="language-javascript">const url = 'http://some.url.1';
ajax(url, (data) => {
  console.log(data);
});
</code></pre>
<p>为什么说 回调不是最优的解决办法, 还是先来看一段代码:</p>
<pre><code class="language-javascript">listen('click', (evt) => {
  setTimeout(() => {
    ajax('http://some.url.1', (text) => {
      if (text === 'hello') {
        handle();
      } else {
        request();
      }
    });
  }, 500);
});

//node 范式的回调
readFile('hello.txt', (err, data) => {
  if (err) {
    throw Error(err);
  }
  if (data.toString() === 'hello') {
    writeFile('hello.txt', 'hello world!', (err, data) => {
      if (err) {
        throw Error(err);
      }
      //todo...
    });
  }
});
</code></pre>
<p>上面这段代码常常被称为 “回调地狱”, 虽然已经使用箭头函数来减少复杂度了, 但是看起来却还是不太优雅. 当然, 这仅仅是一个小问题. 上述这段代码的执行顺序还是比较好理解的, 往往在业务开发中, 会产生一些更严重的问题. 来看下面一段伪代码:</p>
<pre><code class="language-javascript">doA(() => {
  doB();
  doC(() => {
    doD();
  });
  doE();
});
doF();
</code></pre>
<p>上述代码的执行顺序便会更加复杂一点了, 实际运行顺序是:</p>
<p><code>doA() -> doF() -> doB() -> doC() -> doE() -> doD()</code></p>
<p>所以, 我们需要比回调更好的机制, 需要一种更同步、更顺序、更阻塞的方式来表达异步.</p>
<h2 id="2-promise"><a aria-hidden="true" tabindex="-1" href="#2-promise"><span class="icon icon-link"></span></a>2. Promise</h2>
<p>抛砖引玉结束, 现在回到本文的主题, 来好好了解 <code>Promise</code> 吧.</p>
<h3 id="21-什么是-promise"><a aria-hidden="true" tabindex="-1" href="#21-什么是-promise"><span class="icon icon-link"></span></a>2.1 什么是 <code>Promise</code></h3>
<p>Promise 是抽象异步处理对象以及对其进行各种操作的组件. Promise 最初被提出是在 E 语言中, 它是基于并列/并行处理设计的一种编程语言.</p>
<h4 id="211-constructor"><a aria-hidden="true" tabindex="-1" href="#211-constructor"><span class="icon icon-link"></span></a>2.1.1 Constructor</h4>
<p><code>Promise</code> 类似于 <code>XMLHttpRequest</code>, 从构造函数 <code>Promise</code> 来创建一个新建新 <code>promise</code> 对象作为接口.</p>
<p>要想创建一个 <code>promise</code> 对象、可以使用 <code>new</code> 来调用 <code>Promise</code> 的构造器来进行实例化。</p>
<pre><code class="language-javascript">const promise = new Promise(function (resolve, reject) {
  // 异步处理
  // 处理结束后、调用resolve 或 reject
});
</code></pre>
<h4 id="212-instance-method"><a aria-hidden="true" tabindex="-1" href="#212-instance-method"><span class="icon icon-link"></span></a>2.1.2 Instance Method</h4>
<p>对通过 <code>new</code> 生成的 <code>promise</code> 对象为了设置其值在 <code>resolve(成功)</code> / <code>reject(失败)</code> 时调用的回调函数, 可以使用<code>promise.then()</code> 实例方法。</p>
<pre><code class="language-javascript">promise.then(onFulfilled, onRejected),
</code></pre>
<p><code>resolve</code> (成功)时 <code>onFulfilled</code> 会被调用</p>
<p><code>reject</code>(失败)时 <code>onRejected</code> 会被调用</p>
<p><code>onFulfilled、onRejected</code> 两个都为可选参数.</p>
<p><code>promise.then</code> 成功和失败时都可以使用。 另外在只想对异常进行处理时可以采用 <code>promise.then(undefined, onRejected)</code> 这种方式，只指定 <code>reject</code> 时的回调函数即可. 不过这种情况下 <code>promise.catch(onRejected)</code> 应该是个更好的选择.</p>
<pre><code class="language-javascript">promise.catch(onRejected);
</code></pre>
<h3 id="213-static-method"><a aria-hidden="true" tabindex="-1" href="#213-static-method"><span class="icon icon-link"></span></a>2.1.3 Static Method</h3>
<p>像 <code>Promise</code> 这样的全局对象还拥有一些静态方法.</p>
<p>包括 <code>Promise.all()</code> 还有 <code>Promise.resolve()</code> 等在内，主要都是一些对 <code>Promise</code> 进行操作的辅助方法.</p>
<h3 id="22-promise-工作流程与状态"><a aria-hidden="true" tabindex="-1" href="#22-promise-工作流程与状态"><span class="icon icon-link"></span></a>2.2 Promise 工作流程与状态</h3>
<p>看一下下面的示例代码:</p>
<pre><code class="language-javascript">const asyncFn = () => {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      resolve('async hello world!');
    }, 500);
  });
};

asyncFn
  .then((res) => {
    console.log(res); //async hello world!
  })
  .catch((err) => {
    console.log(err);
  });
</code></pre>
<p>我们已经大概了解了 <code>Promise</code> 的处理流程，接下来让我们来稍微整理一下 <code>Promise</code> 的状态.</p>
<p>用 <code>new Promise</code> 实例化的 <code>promise</code> 对象有以下三个状态.</p>
<p><code>"has-resolution"</code> - Fulfilled
resolve(成功)时, 此时会调用 onFulfilled</p>
<p><code>"has-rejection"</code> - Rejected
reject(失败)时, 此时会调用 onRejected</p>
<p><code>"unresolved"</code> - Pending
既不是 resolve 也不是 reject 的状态, 也就是 promise 对象刚被创建后的初始化状态等.</p>
<p><code>promise</code>对象的状态</p>
<p>从 <code>Pending</code> 转换为 <code>Fulfilled</code> 或 <code>Rejected</code> 之后, 这个 <code>promise</code> 对象的状态就不会再发生任何变化.</p>
<p>也就是说, Promise 与 Event 等不同, 在.then 后执行的函数可以肯定地说只会被调用一次.</p>
<p>另外, Fulfilled 和 Rejected 这两个中的任一状态都可以表示为 Settled(不变的).</p>
<h3 id="23-实现上述工作流与状态控制"><a aria-hidden="true" tabindex="-1" href="#23-实现上述工作流与状态控制"><span class="icon icon-link"></span></a>2.3 实现上述工作流与状态控制</h3>
<pre><code class="language-typescript">type TGlPromiseStatus = "pending" | "fulfilled" | "rejected";

interface PromiseLike&#x3C;T> {
  then&#x3C;TResult1 = T, TResult2 = never>(
    onfulfilled?: ((value: T) => TResult1 | PromiseLike&#x3C;TResult1>) | null,
    onrejected?: ((reason: any) => TResult2 | PromiseLike&#x3C;TResult2>) | null
  ): PromiseLike&#x3C;TResult1 | TResult2>;
}
interface IGlPromise&#x3C;T> {
  then&#x3C;TResult1 = T, TResult2 = never>(
    onfulfilled?: ((value: T) => TResult1 | PromiseLike&#x3C;TResult1>) | null,
    onrejected?: ((reason: any) => TResult2 | PromiseLike&#x3C;TResult2>) | null
  ): GlPromise&#x3C;TResult1 | TResult2>;
  catch&#x3C;TResult = never>(
    onrejected?: ((reason: any) => TResult | PromiseLike&#x3C;TResult>) | null
  ): GlPromise&#x3C;T | TResult>;
}

export default class GlPromise&#x3C;T> implements IGlPromise&#x3C;T> {
  /**
   * 构造函数
   * @param executor 初始化 Promise 时传入的 callback, 类型为 : (resolve, reject) => void
   */
  constructor(
    executor: (
      resolve: (value: T) => void,
      reject: (reason: any) => void
    ) => void
  ) {
    // 执行传入的callback, 将 resolve, reject作为参数执行
    executor(this.resolve, this.reject);
  }

  //状态
  private PromiseStatus: TGlPromiseStatus = "pending";

  //最终结果
  private PromiseResult: T = undefined as any;

  /**
   * resolve函数,
   *  构造函数中的回调函数的第一个参数
   * 进行操作:
   * 0. 判断状态时候为  pending, 不为 pending 代表该 promise 已经有结果了, 无法更改状态, 直接 return
   * 1. 将 PromiseStatus 从 pending ===> fulfilled, 状态改变后, then中的成功回调才会执行
   * 2. 将参数赋值给 PromiseResult
   * @param: value: T
   * @returns: void
   **/
  private resolve = (value: T) => {
    if (this.PromiseStatus !== "pending") return;
    this.PromiseResult = value;
    this.PromiseStatus = "fulfilled";
    while (this.onfulfilledCallbacks.length) {
      this.onfulfilledCallbacks.shift()!(this.PromiseResult);
    }
  };

  /**
   * reject函数,
   * 构造函数中的回调函数的第二个参数
   * 进行操作:
   * 0. 判断状态时候为  pending, 不为 pending 代表该 promise 已经有结果了, 无法更改状态, 直接 return
   * 1. 将 PromiseStatus 从 pending ===> rejected, 状态改变后, catch中的成功回调才会执行
   * 2. 将参数赋值给 PromiseResult
   * @param reason:any
   * @returns void
   */
  private reject = (reason: any) => {
    if (this.PromiseStatus !== "pending") return;
    this.PromiseResult = reason;
    this.PromiseStatus = "rejected";
    while (this.onrejectedCallbacks.length) {
      this.onrejectedCallbacks.shift()!(this.PromiseResult);
    }
  };

  private onfulfilledCallbacks: Array&#x3C;((value?: T) => void) | null> = [];

  private onrejectedCallbacks: Array&#x3C;((value?: T) => void) | null> = [];

  /**
   * 核心: then 函数
   */
  public then = &#x3C;TResult1 = T, TResult2 = never>(
    onfulfilled?: ((value: T) => TResult1 | PromiseLike&#x3C;TResult1>) | null,
    onrejected?: ((reason: any) => TResult2 | PromiseLike&#x3C;TResult2>) | null
  ) =>
    new GlPromise&#x3C;TResult1 | TResult2>((resolve, reject) => {
      const thenPromise = (
        cb: (
          values: T
        ) => PromiseLike&#x3C;TResult1 | TResult2> | TResult1 | TResult2
      ) => {
        //模拟微任务
        setTimeout(() => {
          try {
            const val = cb(this.PromiseResult);
            if (val instanceof GlPromise) {
              val.then(resolve, reject);
            } else {
              this.resolve(val as any);
            }
          } catch (error) {
            this.reject(error);
          }
        });
      };

      if (this.PromiseStatus === "fulfilled") {
        onfulfilled &#x26;&#x26; thenPromise(onfulfilled);
      } else if (this.PromiseStatus === "rejected") {
        onrejected &#x26;&#x26; thenPromise(onrejected);
      } else if (this.PromiseStatus === "pending") {
        onfulfilled &#x26;&#x26;
          this.onfulfilledCallbacks.push(thenPromise.bind(this, onfulfilled));
        onrejected &#x26;&#x26;
          this.onrejectedCallbacks.push(thenPromise.bind(this, onrejected));
      }
    });

  public catch = &#x3C;TResult = never>(
    onrejected?: ((reason: any) => TResult | PromiseLike&#x3C;TResult>) | null
  ) => this.then(null, onrejected);
</code></pre>
<h3 id="23-静态方式的使用与实现"><a aria-hidden="true" tabindex="-1" href="#23-静态方式的使用与实现"><span class="icon icon-link"></span></a>2.3 静态方式的使用与实现</h3>
<h4 id="231-promiseresolve"><a aria-hidden="true" tabindex="-1" href="#231-promiseresolve"><span class="icon icon-link"></span></a>2.3.1 Promise.resolve</h4>
<p>静态方法 <code>Promise.resolve(value)</code> 可以认为是 <code>new Promise()</code> 方法的快捷方式.</p>
<p>比如 <code>Promise.resolve(42);</code> 可以认为是以下代码的语法糖:</p>
<pre><code class="language-javascript">new Promise(function (resolve) {
  resolve(42);
});
</code></pre>
<p>在这段代码中的 <code>resolve(42);</code> 会让这个 <code>promise</code> 对象立即进入确定（即 <code>resolved</code> ）状态, 并将 42 传递给后面<code>then</code>里所指定的 <code>onFulfilled</code> 函数.</p>
<p>方法 <code>Promise.resolve(value);</code> 的返回值也是一个 <code>promise</code> 对象, 所以我们可以像下面那样接着对其返回值进行 <code>.then</code> 调用.</p>
<pre><code class="language-javascript">Promise.resolve(42).then(function (value) {
  console.log(value);
});
</code></pre>
<p>实现:</p>
<pre><code class="language-typescript">  public static resolve = &#x3C;T>(value: T) => {
    return new GlPromise((resolve) => {
      resolve(value);
    });
  };
</code></pre>
<h4 id="232-promisereject"><a aria-hidden="true" tabindex="-1" href="#232-promisereject"><span class="icon icon-link"></span></a>2.3.2 Promise.reject</h4>
<p>基本类似与 Promise.resolve</p>
<h4 id="233-promiseall"><a aria-hidden="true" tabindex="-1" href="#233-promiseall"><span class="icon icon-link"></span></a>2.3.3 Promise.all</h4>
<p>Promise.all() 方法接收一个 promise 的 iterable 类型（注：Array，Map，Set 都属于 ES6 的 iterable 类型）的输入，并且只返回一个 Promise 实例， 那个输入的所有 promise 的 resolve 回调的结果是一个数组。这个 Promise 的 resolve 回调执行是在所有输入的 promise 的 resolve 回调都结束，或者输入的 iterable 里没有 promise 了的时候。它的 reject 回调执行是，只要任何一个输入的 promise 的 reject 回调执行或者输入不合法的 promise 就会立即抛出错误，并且 reject 的是第一个抛出的错误信息。</p>
<p>基本使用方式:</p>
<pre><code class="language-javascript">const p1 = new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve(2);
  }, 2000);
});
const p2 = new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve(4);
  }, 1000);
});
const p3 = new Promise((resolve, reject) => {
  setTimeout(() => {
    reject(4);
  }, 1000);
});
Promise.all([p1, p2]).then((res) => {
  console.log(res);
}); //[2, 4]
Promise.all([p1, p2, p3])
  .then((res) => {
    console.log(res);
  })
  .catch((err) => {
    console.log(err);
  }); //4
</code></pre>
<p>实现:</p>
<pre><code class="language-typescript">  public static all = &#x3C;T>(promises: Array&#x3C;PromiseLike&#x3C;T>>) => {
    const result: T[] = [];
    let count = 0;
    return new GlPromise((resolve, reject) => {
      const addData = (index: number, value: T) => {
        result[index] = value;
        count++;
        if (count === promises.length) {
          resolve(result);
        }
      };
      promises.forEach((promise, index) => {
        if (promise instanceof GlPromise) {
          promise.then((res) => {
            addData(index, res);
          }, (err) => {
            reject(err);
          });
        } else {
          addData(index, promise as any);
        }
      });
    });
  }
</code></pre>
<h3 id="234-promiseany"><a aria-hidden="true" tabindex="-1" href="#234-promiseany"><span class="icon icon-link"></span></a>2.3.4 Promise.any</h3>
<p>Promise.any() 接收一个 Promise 可迭代对象，只要其中的一个 promise 成功，就返回那个已经成功的 promise 。如果可迭代对象中没有一个 promise 成功（即所有的 promises 都失败/拒绝），就返回一个失败的 promise 和 AggregateError 类型的实例，它是 Error 的一个子类，用于把单一的错误集合在一起。本质上，这个方法和 Promise.all()是相反的。</p>
<pre><code class="language-javascript">const pErr = new Promise((resolve, reject) => {
  reject('总是失败');
});

const pSlow = new Promise((resolve, reject) => {
  setTimeout(resolve, 500, '最终完成');
});

const pFast = new Promise((resolve, reject) => {
  setTimeout(resolve, 100, '很快完成');
});

Promise.any([pErr, pSlow, pFast]).then((value) => {
  console.log(value); // "很快完成"
});
</code></pre>
<p>实现:</p>
<pre><code class="language-typescript">  public static any = &#x3C;T>(promises: Array&#x3C;PromiseLike&#x3C;T>>) => new GlPromise((resolve, reject) => {
    let count = 0;
    promises.forEach((promise) => {
      if (promise instanceof GlPromise) {
        promise.then((res) => resolve(res), () => {
          count++;
          if (count === promises.length) {
            reject('All promises were rejected');
          }
        });
      } else {
        resolve(promise as any);
      }
    });
  })

</code></pre>
<h3 id="235-promiserace"><a aria-hidden="true" tabindex="-1" href="#235-promiserace"><span class="icon icon-link"></span></a>2.3.5 Promise.race</h3>
<p>Promise.race(iterable) 方法返回一个 promise，一旦迭代器中的某个 promise 解决或拒绝，返回的 promise 就会解决或拒绝。</p>
<pre><code class="language-javascript">const promise1 = new Promise((resolve, reject) => {
  setTimeout(resolve, 500, 'one');
});

const promise2 = new Promise((resolve, reject) => {
  setTimeout(resolve, 100, 'two');
});

Promise.race([promise1, promise2])
  .then((value) => {
    console.log(value); // two
  })
  .catch((err) => {
    console.log(err);
  });
</code></pre>
<p>实现:</p>
<pre><code class="language-typescript">  public static race = &#x3C;T>(promises: Array&#x3C;PromiseLike&#x3C;T>>) => new GlPromise((resolve, reject) => {
    promises.forEach((promise) => {
      if (promise instanceof GlPromise) {
        promise.then((res) => resolve(res), (err) => reject(err));
      } else {
        resolve(promise);
      }
    });
  })
</code></pre>
<h3 id="236-promiseallsettled"><a aria-hidden="true" tabindex="-1" href="#236-promiseallsettled"><span class="icon icon-link"></span></a>2.3.6 Promise.allSettled</h3>
<p>该 Promise.allSettled()方法返回一个在所有给定的 promise 都已经 fulfilled 或 rejected 后的 promise，并带有一个对象数组，每个对象表示对应的 promise 结果。</p>
<p>当有多个彼此不依赖的异步任务成功完成时，或者总是想知道每个 promise 的结果时，通常使用它。</p>
<p>相比之下，Promise.all() 更适合彼此相互依赖或者在其中任何一个 reject 时立即结束。</p>
<pre><code class="language-javascript">const promise1 = Promise.resolve(3);
const promise2 = new Promise((resolve, reject) =>
  setTimeout(reject, 100, 'foo')
);
const promises = [promise1, promise2];

Promise.allSettled(promises).then((results) =>
  results.forEach((result) => console.log(result.status))
);

// "fulfilled"
// "rejected"
</code></pre>
<p>实现:</p>
<pre><code class="language-typescript"> public static allSettled = &#x3C;T>(promises: Array&#x3C;PromiseLike&#x3C;T>>) => new GlPromise((resolve, reject) => {
    const result: Array&#x3C;{ status: 'fulfilled' | 'rejected', value: T }> = [];
    let count = 0;

    const addData = (index: number, value: T, status: 'fulfilled' | 'rejected') => {
      result[index] = {
        status, value
      };
      count++;
      if (count === promises.length) resolve(result);
    };

    promises.forEach((promise, index) => {
      if (promise instanceof GlPromise) {
        promise.then((res) => addData(index, res, 'fulfilled'), (err) => addData(index, err, 'rejected'));
      } else {
        addData(index, promise as any, 'fulfilled');
      }
    });
  })
</code></pre></div></section></article></main><footer class="bg-neutral-50 border-t border-neutral-200 text-center text-xs opacity-50 py-4">© 2022,<!-- --> <a rel="noopener noreferrer" class="hover:underline hover:bg-indigo" href="https://github.com/LZS911" target="_blank">LZS_911</a>, build with<!-- --> <a rel="noopener noreferrer" class="underline hover:bg-indigo" href="https://nextjs.org/" target="_blank">Next.js</a> <!-- -->and<!-- --> <a rel="noopener noreferrer" class="underline hover:bg-indigo" href="https://pages.github.com/?(null)" target="_blank">GitHub Pages</a></footer></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"promise学习记录","date":"2022-03-01","slug":"promise学习记录","author":"LZS_911","content":"\u003ch2 id=\"1-一些相关的概念\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#1-一些相关的概念\"\u003e\u003cspan class=\"icon icon-link\"\u003e\u003c/span\u003e\u003c/a\u003e1. 一些相关的概念\u003c/h2\u003e\n\u003ch3 id=\"11-javascript-中的异步\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#11-javascript-中的异步\"\u003e\u003cspan class=\"icon icon-link\"\u003e\u003c/span\u003e\u003c/a\u003e1.1 JavaScript 中的异步\u003c/h3\u003e\n\u003cp\u003e在 \u003ccode\u003eJavaScript\u003c/code\u003e 中, 程序中将来执行的部分并不一定在现在运行的部分执行完之后立即执行. 换句话说, 现在无法完成的任务将会异步完成, 因此并不会出现阻塞行为.\u003c/p\u003e\n\u003cp\u003e来看一段代码:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003e//现在执行的\nconst url = 'http://some.url.1';\n//将来执行的\nconst data = ajax(url);\n//接着现在执行的\nconsole.log(data);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e这里的 \u003ccode\u003edata\u003c/code\u003e 通常是不会包含 \u003ccode\u003eajax\u003c/code\u003e 请求所返回的数据的. 因为用户在请求网络资源时并不希望阻塞所有的 UI 交互.\u003c/p\u003e\n\u003ch3 id=\"12-回调函数\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#12-回调函数\"\u003e\u003cspan class=\"icon icon-link\"\u003e\u003c/span\u003e\u003c/a\u003e1.2 回调函数\u003c/h3\u003e\n\u003cp\u003e从现在到将来的等待, 最简单的办法(并不唯一, 甚至不是最优办法)是使用一个通常称为回调函数的函数.\n来看一段代码:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003econst url = 'http://some.url.1';\najax(url, (data) =\u003e {\n  console.log(data);\n});\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e为什么说 回调不是最优的解决办法, 还是先来看一段代码:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003elisten('click', (evt) =\u003e {\n  setTimeout(() =\u003e {\n    ajax('http://some.url.1', (text) =\u003e {\n      if (text === 'hello') {\n        handle();\n      } else {\n        request();\n      }\n    });\n  }, 500);\n});\n\n//node 范式的回调\nreadFile('hello.txt', (err, data) =\u003e {\n  if (err) {\n    throw Error(err);\n  }\n  if (data.toString() === 'hello') {\n    writeFile('hello.txt', 'hello world!', (err, data) =\u003e {\n      if (err) {\n        throw Error(err);\n      }\n      //todo...\n    });\n  }\n});\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e上面这段代码常常被称为 “回调地狱”, 虽然已经使用箭头函数来减少复杂度了, 但是看起来却还是不太优雅. 当然, 这仅仅是一个小问题. 上述这段代码的执行顺序还是比较好理解的, 往往在业务开发中, 会产生一些更严重的问题. 来看下面一段伪代码:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003edoA(() =\u003e {\n  doB();\n  doC(() =\u003e {\n    doD();\n  });\n  doE();\n});\ndoF();\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e上述代码的执行顺序便会更加复杂一点了, 实际运行顺序是:\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003edoA() -\u003e doF() -\u003e doB() -\u003e doC() -\u003e doE() -\u003e doD()\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e所以, 我们需要比回调更好的机制, 需要一种更同步、更顺序、更阻塞的方式来表达异步.\u003c/p\u003e\n\u003ch2 id=\"2-promise\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#2-promise\"\u003e\u003cspan class=\"icon icon-link\"\u003e\u003c/span\u003e\u003c/a\u003e2. Promise\u003c/h2\u003e\n\u003cp\u003e抛砖引玉结束, 现在回到本文的主题, 来好好了解 \u003ccode\u003ePromise\u003c/code\u003e 吧.\u003c/p\u003e\n\u003ch3 id=\"21-什么是-promise\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#21-什么是-promise\"\u003e\u003cspan class=\"icon icon-link\"\u003e\u003c/span\u003e\u003c/a\u003e2.1 什么是 \u003ccode\u003ePromise\u003c/code\u003e\u003c/h3\u003e\n\u003cp\u003ePromise 是抽象异步处理对象以及对其进行各种操作的组件. Promise 最初被提出是在 E 语言中, 它是基于并列/并行处理设计的一种编程语言.\u003c/p\u003e\n\u003ch4 id=\"211-constructor\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#211-constructor\"\u003e\u003cspan class=\"icon icon-link\"\u003e\u003c/span\u003e\u003c/a\u003e2.1.1 Constructor\u003c/h4\u003e\n\u003cp\u003e\u003ccode\u003ePromise\u003c/code\u003e 类似于 \u003ccode\u003eXMLHttpRequest\u003c/code\u003e, 从构造函数 \u003ccode\u003ePromise\u003c/code\u003e 来创建一个新建新 \u003ccode\u003epromise\u003c/code\u003e 对象作为接口.\u003c/p\u003e\n\u003cp\u003e要想创建一个 \u003ccode\u003epromise\u003c/code\u003e 对象、可以使用 \u003ccode\u003enew\u003c/code\u003e 来调用 \u003ccode\u003ePromise\u003c/code\u003e 的构造器来进行实例化。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003econst promise = new Promise(function (resolve, reject) {\n  // 异步处理\n  // 处理结束后、调用resolve 或 reject\n});\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch4 id=\"212-instance-method\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#212-instance-method\"\u003e\u003cspan class=\"icon icon-link\"\u003e\u003c/span\u003e\u003c/a\u003e2.1.2 Instance Method\u003c/h4\u003e\n\u003cp\u003e对通过 \u003ccode\u003enew\u003c/code\u003e 生成的 \u003ccode\u003epromise\u003c/code\u003e 对象为了设置其值在 \u003ccode\u003eresolve(成功)\u003c/code\u003e / \u003ccode\u003ereject(失败)\u003c/code\u003e 时调用的回调函数, 可以使用\u003ccode\u003epromise.then()\u003c/code\u003e 实例方法。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003epromise.then(onFulfilled, onRejected),\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003eresolve\u003c/code\u003e (成功)时 \u003ccode\u003eonFulfilled\u003c/code\u003e 会被调用\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003ereject\u003c/code\u003e(失败)时 \u003ccode\u003eonRejected\u003c/code\u003e 会被调用\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eonFulfilled、onRejected\u003c/code\u003e 两个都为可选参数.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003epromise.then\u003c/code\u003e 成功和失败时都可以使用。 另外在只想对异常进行处理时可以采用 \u003ccode\u003epromise.then(undefined, onRejected)\u003c/code\u003e 这种方式，只指定 \u003ccode\u003ereject\u003c/code\u003e 时的回调函数即可. 不过这种情况下 \u003ccode\u003epromise.catch(onRejected)\u003c/code\u003e 应该是个更好的选择.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003epromise.catch(onRejected);\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"213-static-method\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#213-static-method\"\u003e\u003cspan class=\"icon icon-link\"\u003e\u003c/span\u003e\u003c/a\u003e2.1.3 Static Method\u003c/h3\u003e\n\u003cp\u003e像 \u003ccode\u003ePromise\u003c/code\u003e 这样的全局对象还拥有一些静态方法.\u003c/p\u003e\n\u003cp\u003e包括 \u003ccode\u003ePromise.all()\u003c/code\u003e 还有 \u003ccode\u003ePromise.resolve()\u003c/code\u003e 等在内，主要都是一些对 \u003ccode\u003ePromise\u003c/code\u003e 进行操作的辅助方法.\u003c/p\u003e\n\u003ch3 id=\"22-promise-工作流程与状态\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#22-promise-工作流程与状态\"\u003e\u003cspan class=\"icon icon-link\"\u003e\u003c/span\u003e\u003c/a\u003e2.2 Promise 工作流程与状态\u003c/h3\u003e\n\u003cp\u003e看一下下面的示例代码:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003econst asyncFn = () =\u003e {\n  return new Promise((resolve, reject) =\u003e {\n    setTimeout(() =\u003e {\n      resolve('async hello world!');\n    }, 500);\n  });\n};\n\nasyncFn\n  .then((res) =\u003e {\n    console.log(res); //async hello world!\n  })\n  .catch((err) =\u003e {\n    console.log(err);\n  });\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e我们已经大概了解了 \u003ccode\u003ePromise\u003c/code\u003e 的处理流程，接下来让我们来稍微整理一下 \u003ccode\u003ePromise\u003c/code\u003e 的状态.\u003c/p\u003e\n\u003cp\u003e用 \u003ccode\u003enew Promise\u003c/code\u003e 实例化的 \u003ccode\u003epromise\u003c/code\u003e 对象有以下三个状态.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003e\"has-resolution\"\u003c/code\u003e - Fulfilled\nresolve(成功)时, 此时会调用 onFulfilled\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003e\"has-rejection\"\u003c/code\u003e - Rejected\nreject(失败)时, 此时会调用 onRejected\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003e\"unresolved\"\u003c/code\u003e - Pending\n既不是 resolve 也不是 reject 的状态, 也就是 promise 对象刚被创建后的初始化状态等.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003epromise\u003c/code\u003e对象的状态\u003c/p\u003e\n\u003cp\u003e从 \u003ccode\u003ePending\u003c/code\u003e 转换为 \u003ccode\u003eFulfilled\u003c/code\u003e 或 \u003ccode\u003eRejected\u003c/code\u003e 之后, 这个 \u003ccode\u003epromise\u003c/code\u003e 对象的状态就不会再发生任何变化.\u003c/p\u003e\n\u003cp\u003e也就是说, Promise 与 Event 等不同, 在.then 后执行的函数可以肯定地说只会被调用一次.\u003c/p\u003e\n\u003cp\u003e另外, Fulfilled 和 Rejected 这两个中的任一状态都可以表示为 Settled(不变的).\u003c/p\u003e\n\u003ch3 id=\"23-实现上述工作流与状态控制\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#23-实现上述工作流与状态控制\"\u003e\u003cspan class=\"icon icon-link\"\u003e\u003c/span\u003e\u003c/a\u003e2.3 实现上述工作流与状态控制\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-typescript\"\u003etype TGlPromiseStatus = \"pending\" | \"fulfilled\" | \"rejected\";\n\ninterface PromiseLike\u0026#x3C;T\u003e {\n  then\u0026#x3C;TResult1 = T, TResult2 = never\u003e(\n    onfulfilled?: ((value: T) =\u003e TResult1 | PromiseLike\u0026#x3C;TResult1\u003e) | null,\n    onrejected?: ((reason: any) =\u003e TResult2 | PromiseLike\u0026#x3C;TResult2\u003e) | null\n  ): PromiseLike\u0026#x3C;TResult1 | TResult2\u003e;\n}\ninterface IGlPromise\u0026#x3C;T\u003e {\n  then\u0026#x3C;TResult1 = T, TResult2 = never\u003e(\n    onfulfilled?: ((value: T) =\u003e TResult1 | PromiseLike\u0026#x3C;TResult1\u003e) | null,\n    onrejected?: ((reason: any) =\u003e TResult2 | PromiseLike\u0026#x3C;TResult2\u003e) | null\n  ): GlPromise\u0026#x3C;TResult1 | TResult2\u003e;\n  catch\u0026#x3C;TResult = never\u003e(\n    onrejected?: ((reason: any) =\u003e TResult | PromiseLike\u0026#x3C;TResult\u003e) | null\n  ): GlPromise\u0026#x3C;T | TResult\u003e;\n}\n\nexport default class GlPromise\u0026#x3C;T\u003e implements IGlPromise\u0026#x3C;T\u003e {\n  /**\n   * 构造函数\n   * @param executor 初始化 Promise 时传入的 callback, 类型为 : (resolve, reject) =\u003e void\n   */\n  constructor(\n    executor: (\n      resolve: (value: T) =\u003e void,\n      reject: (reason: any) =\u003e void\n    ) =\u003e void\n  ) {\n    // 执行传入的callback, 将 resolve, reject作为参数执行\n    executor(this.resolve, this.reject);\n  }\n\n  //状态\n  private PromiseStatus: TGlPromiseStatus = \"pending\";\n\n  //最终结果\n  private PromiseResult: T = undefined as any;\n\n  /**\n   * resolve函数,\n   *  构造函数中的回调函数的第一个参数\n   * 进行操作:\n   * 0. 判断状态时候为  pending, 不为 pending 代表该 promise 已经有结果了, 无法更改状态, 直接 return\n   * 1. 将 PromiseStatus 从 pending ===\u003e fulfilled, 状态改变后, then中的成功回调才会执行\n   * 2. 将参数赋值给 PromiseResult\n   * @param: value: T\n   * @returns: void\n   **/\n  private resolve = (value: T) =\u003e {\n    if (this.PromiseStatus !== \"pending\") return;\n    this.PromiseResult = value;\n    this.PromiseStatus = \"fulfilled\";\n    while (this.onfulfilledCallbacks.length) {\n      this.onfulfilledCallbacks.shift()!(this.PromiseResult);\n    }\n  };\n\n  /**\n   * reject函数,\n   * 构造函数中的回调函数的第二个参数\n   * 进行操作:\n   * 0. 判断状态时候为  pending, 不为 pending 代表该 promise 已经有结果了, 无法更改状态, 直接 return\n   * 1. 将 PromiseStatus 从 pending ===\u003e rejected, 状态改变后, catch中的成功回调才会执行\n   * 2. 将参数赋值给 PromiseResult\n   * @param reason:any\n   * @returns void\n   */\n  private reject = (reason: any) =\u003e {\n    if (this.PromiseStatus !== \"pending\") return;\n    this.PromiseResult = reason;\n    this.PromiseStatus = \"rejected\";\n    while (this.onrejectedCallbacks.length) {\n      this.onrejectedCallbacks.shift()!(this.PromiseResult);\n    }\n  };\n\n  private onfulfilledCallbacks: Array\u0026#x3C;((value?: T) =\u003e void) | null\u003e = [];\n\n  private onrejectedCallbacks: Array\u0026#x3C;((value?: T) =\u003e void) | null\u003e = [];\n\n  /**\n   * 核心: then 函数\n   */\n  public then = \u0026#x3C;TResult1 = T, TResult2 = never\u003e(\n    onfulfilled?: ((value: T) =\u003e TResult1 | PromiseLike\u0026#x3C;TResult1\u003e) | null,\n    onrejected?: ((reason: any) =\u003e TResult2 | PromiseLike\u0026#x3C;TResult2\u003e) | null\n  ) =\u003e\n    new GlPromise\u0026#x3C;TResult1 | TResult2\u003e((resolve, reject) =\u003e {\n      const thenPromise = (\n        cb: (\n          values: T\n        ) =\u003e PromiseLike\u0026#x3C;TResult1 | TResult2\u003e | TResult1 | TResult2\n      ) =\u003e {\n        //模拟微任务\n        setTimeout(() =\u003e {\n          try {\n            const val = cb(this.PromiseResult);\n            if (val instanceof GlPromise) {\n              val.then(resolve, reject);\n            } else {\n              this.resolve(val as any);\n            }\n          } catch (error) {\n            this.reject(error);\n          }\n        });\n      };\n\n      if (this.PromiseStatus === \"fulfilled\") {\n        onfulfilled \u0026#x26;\u0026#x26; thenPromise(onfulfilled);\n      } else if (this.PromiseStatus === \"rejected\") {\n        onrejected \u0026#x26;\u0026#x26; thenPromise(onrejected);\n      } else if (this.PromiseStatus === \"pending\") {\n        onfulfilled \u0026#x26;\u0026#x26;\n          this.onfulfilledCallbacks.push(thenPromise.bind(this, onfulfilled));\n        onrejected \u0026#x26;\u0026#x26;\n          this.onrejectedCallbacks.push(thenPromise.bind(this, onrejected));\n      }\n    });\n\n  public catch = \u0026#x3C;TResult = never\u003e(\n    onrejected?: ((reason: any) =\u003e TResult | PromiseLike\u0026#x3C;TResult\u003e) | null\n  ) =\u003e this.then(null, onrejected);\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"23-静态方式的使用与实现\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#23-静态方式的使用与实现\"\u003e\u003cspan class=\"icon icon-link\"\u003e\u003c/span\u003e\u003c/a\u003e2.3 静态方式的使用与实现\u003c/h3\u003e\n\u003ch4 id=\"231-promiseresolve\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#231-promiseresolve\"\u003e\u003cspan class=\"icon icon-link\"\u003e\u003c/span\u003e\u003c/a\u003e2.3.1 Promise.resolve\u003c/h4\u003e\n\u003cp\u003e静态方法 \u003ccode\u003ePromise.resolve(value)\u003c/code\u003e 可以认为是 \u003ccode\u003enew Promise()\u003c/code\u003e 方法的快捷方式.\u003c/p\u003e\n\u003cp\u003e比如 \u003ccode\u003ePromise.resolve(42);\u003c/code\u003e 可以认为是以下代码的语法糖:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003enew Promise(function (resolve) {\n  resolve(42);\n});\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e在这段代码中的 \u003ccode\u003eresolve(42);\u003c/code\u003e 会让这个 \u003ccode\u003epromise\u003c/code\u003e 对象立即进入确定（即 \u003ccode\u003eresolved\u003c/code\u003e ）状态, 并将 42 传递给后面\u003ccode\u003ethen\u003c/code\u003e里所指定的 \u003ccode\u003eonFulfilled\u003c/code\u003e 函数.\u003c/p\u003e\n\u003cp\u003e方法 \u003ccode\u003ePromise.resolve(value);\u003c/code\u003e 的返回值也是一个 \u003ccode\u003epromise\u003c/code\u003e 对象, 所以我们可以像下面那样接着对其返回值进行 \u003ccode\u003e.then\u003c/code\u003e 调用.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003ePromise.resolve(42).then(function (value) {\n  console.log(value);\n});\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e实现:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-typescript\"\u003e  public static resolve = \u0026#x3C;T\u003e(value: T) =\u003e {\n    return new GlPromise((resolve) =\u003e {\n      resolve(value);\n    });\n  };\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch4 id=\"232-promisereject\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#232-promisereject\"\u003e\u003cspan class=\"icon icon-link\"\u003e\u003c/span\u003e\u003c/a\u003e2.3.2 Promise.reject\u003c/h4\u003e\n\u003cp\u003e基本类似与 Promise.resolve\u003c/p\u003e\n\u003ch4 id=\"233-promiseall\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#233-promiseall\"\u003e\u003cspan class=\"icon icon-link\"\u003e\u003c/span\u003e\u003c/a\u003e2.3.3 Promise.all\u003c/h4\u003e\n\u003cp\u003ePromise.all() 方法接收一个 promise 的 iterable 类型（注：Array，Map，Set 都属于 ES6 的 iterable 类型）的输入，并且只返回一个 Promise 实例， 那个输入的所有 promise 的 resolve 回调的结果是一个数组。这个 Promise 的 resolve 回调执行是在所有输入的 promise 的 resolve 回调都结束，或者输入的 iterable 里没有 promise 了的时候。它的 reject 回调执行是，只要任何一个输入的 promise 的 reject 回调执行或者输入不合法的 promise 就会立即抛出错误，并且 reject 的是第一个抛出的错误信息。\u003c/p\u003e\n\u003cp\u003e基本使用方式:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003econst p1 = new Promise((resolve, reject) =\u003e {\n  setTimeout(() =\u003e {\n    resolve(2);\n  }, 2000);\n});\nconst p2 = new Promise((resolve, reject) =\u003e {\n  setTimeout(() =\u003e {\n    resolve(4);\n  }, 1000);\n});\nconst p3 = new Promise((resolve, reject) =\u003e {\n  setTimeout(() =\u003e {\n    reject(4);\n  }, 1000);\n});\nPromise.all([p1, p2]).then((res) =\u003e {\n  console.log(res);\n}); //[2, 4]\nPromise.all([p1, p2, p3])\n  .then((res) =\u003e {\n    console.log(res);\n  })\n  .catch((err) =\u003e {\n    console.log(err);\n  }); //4\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e实现:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-typescript\"\u003e  public static all = \u0026#x3C;T\u003e(promises: Array\u0026#x3C;PromiseLike\u0026#x3C;T\u003e\u003e) =\u003e {\n    const result: T[] = [];\n    let count = 0;\n    return new GlPromise((resolve, reject) =\u003e {\n      const addData = (index: number, value: T) =\u003e {\n        result[index] = value;\n        count++;\n        if (count === promises.length) {\n          resolve(result);\n        }\n      };\n      promises.forEach((promise, index) =\u003e {\n        if (promise instanceof GlPromise) {\n          promise.then((res) =\u003e {\n            addData(index, res);\n          }, (err) =\u003e {\n            reject(err);\n          });\n        } else {\n          addData(index, promise as any);\n        }\n      });\n    });\n  }\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"234-promiseany\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#234-promiseany\"\u003e\u003cspan class=\"icon icon-link\"\u003e\u003c/span\u003e\u003c/a\u003e2.3.4 Promise.any\u003c/h3\u003e\n\u003cp\u003ePromise.any() 接收一个 Promise 可迭代对象，只要其中的一个 promise 成功，就返回那个已经成功的 promise 。如果可迭代对象中没有一个 promise 成功（即所有的 promises 都失败/拒绝），就返回一个失败的 promise 和 AggregateError 类型的实例，它是 Error 的一个子类，用于把单一的错误集合在一起。本质上，这个方法和 Promise.all()是相反的。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003econst pErr = new Promise((resolve, reject) =\u003e {\n  reject('总是失败');\n});\n\nconst pSlow = new Promise((resolve, reject) =\u003e {\n  setTimeout(resolve, 500, '最终完成');\n});\n\nconst pFast = new Promise((resolve, reject) =\u003e {\n  setTimeout(resolve, 100, '很快完成');\n});\n\nPromise.any([pErr, pSlow, pFast]).then((value) =\u003e {\n  console.log(value); // \"很快完成\"\n});\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e实现:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-typescript\"\u003e  public static any = \u0026#x3C;T\u003e(promises: Array\u0026#x3C;PromiseLike\u0026#x3C;T\u003e\u003e) =\u003e new GlPromise((resolve, reject) =\u003e {\n    let count = 0;\n    promises.forEach((promise) =\u003e {\n      if (promise instanceof GlPromise) {\n        promise.then((res) =\u003e resolve(res), () =\u003e {\n          count++;\n          if (count === promises.length) {\n            reject('All promises were rejected');\n          }\n        });\n      } else {\n        resolve(promise as any);\n      }\n    });\n  })\n\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"235-promiserace\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#235-promiserace\"\u003e\u003cspan class=\"icon icon-link\"\u003e\u003c/span\u003e\u003c/a\u003e2.3.5 Promise.race\u003c/h3\u003e\n\u003cp\u003ePromise.race(iterable) 方法返回一个 promise，一旦迭代器中的某个 promise 解决或拒绝，返回的 promise 就会解决或拒绝。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003econst promise1 = new Promise((resolve, reject) =\u003e {\n  setTimeout(resolve, 500, 'one');\n});\n\nconst promise2 = new Promise((resolve, reject) =\u003e {\n  setTimeout(resolve, 100, 'two');\n});\n\nPromise.race([promise1, promise2])\n  .then((value) =\u003e {\n    console.log(value); // two\n  })\n  .catch((err) =\u003e {\n    console.log(err);\n  });\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e实现:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-typescript\"\u003e  public static race = \u0026#x3C;T\u003e(promises: Array\u0026#x3C;PromiseLike\u0026#x3C;T\u003e\u003e) =\u003e new GlPromise((resolve, reject) =\u003e {\n    promises.forEach((promise) =\u003e {\n      if (promise instanceof GlPromise) {\n        promise.then((res) =\u003e resolve(res), (err) =\u003e reject(err));\n      } else {\n        resolve(promise);\n      }\n    });\n  })\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"236-promiseallsettled\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#236-promiseallsettled\"\u003e\u003cspan class=\"icon icon-link\"\u003e\u003c/span\u003e\u003c/a\u003e2.3.6 Promise.allSettled\u003c/h3\u003e\n\u003cp\u003e该 Promise.allSettled()方法返回一个在所有给定的 promise 都已经 fulfilled 或 rejected 后的 promise，并带有一个对象数组，每个对象表示对应的 promise 结果。\u003c/p\u003e\n\u003cp\u003e当有多个彼此不依赖的异步任务成功完成时，或者总是想知道每个 promise 的结果时，通常使用它。\u003c/p\u003e\n\u003cp\u003e相比之下，Promise.all() 更适合彼此相互依赖或者在其中任何一个 reject 时立即结束。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003econst promise1 = Promise.resolve(3);\nconst promise2 = new Promise((resolve, reject) =\u003e\n  setTimeout(reject, 100, 'foo')\n);\nconst promises = [promise1, promise2];\n\nPromise.allSettled(promises).then((results) =\u003e\n  results.forEach((result) =\u003e console.log(result.status))\n);\n\n// \"fulfilled\"\n// \"rejected\"\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e实现:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-typescript\"\u003e public static allSettled = \u0026#x3C;T\u003e(promises: Array\u0026#x3C;PromiseLike\u0026#x3C;T\u003e\u003e) =\u003e new GlPromise((resolve, reject) =\u003e {\n    const result: Array\u0026#x3C;{ status: 'fulfilled' | 'rejected', value: T }\u003e = [];\n    let count = 0;\n\n    const addData = (index: number, value: T, status: 'fulfilled' | 'rejected') =\u003e {\n      result[index] = {\n        status, value\n      };\n      count++;\n      if (count === promises.length) resolve(result);\n    };\n\n    promises.forEach((promise, index) =\u003e {\n      if (promise instanceof GlPromise) {\n        promise.then((res) =\u003e addData(index, res, 'fulfilled'), (err) =\u003e addData(index, err, 'rejected'));\n      } else {\n        addData(index, promise as any, 'fulfilled');\n      }\n    });\n  })\n\u003c/code\u003e\u003c/pre\u003e","ogImage":{"url":"/assets/blog/image/cover.jpg"},"coverImage":"/assets/blog/image/cover.jpg","theme":"simplicity-green","tag":["javascript","promise"]}},"__N_SSG":true},"page":"/posts/[slug]","query":{"slug":"promise学习记录"},"buildId":"d505lWANAwEkY6DLPcxRp","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>