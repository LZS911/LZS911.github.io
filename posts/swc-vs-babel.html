<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><link rel="apple-touch-icon" sizes="180x180" href="/favicon/apple-touch-icon.png"/><link rel="icon" type="image/png" sizes="32x32" href="/favicon/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="16x16" href="/favicon/favicon-16x16.png"/><link rel="manifest" href="/favicon/site.webmanifest"/><link rel="mask-icon" href="/favicon/safari-pinned-tab.svg" color="#000000"/><link rel="shortcut icon" href="/favicon/favicon.ico"/><meta name="msapplication-TileColor" content="#000000"/><meta name="msapplication-config" content="/favicon/browserconfig.xml"/><meta name="theme-color" content="#000"/><link rel="alternate" type="application/rss+xml" href="/feed.xml"/><meta property="og:image" content="https://og-image.vercel.app/Next.js%20Blog%20Starter%20Example.png?theme=light&amp;md=1&amp;fontSize=100px&amp;images=https%3A%2F%2Fassets.vercel.com%2Fimage%2Fupload%2Ffront%2Fassets%2Fdesign%2Fnextjs-black-logo.svg"/><title>swc-vs-babel | Ai.Haibara codes</title><meta name="next-head-count" content="14"/><link rel="preload" href="/_next/static/css/4d9faa1c82c5289e.css" as="style"/><link rel="stylesheet" href="/_next/static/css/4d9faa1c82c5289e.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-8fa1640cc84ba8fe.js" defer=""></script><script src="/_next/static/chunks/framework-3b5a00d5d7e8d93b.js" defer=""></script><script src="/_next/static/chunks/main-59a90320855f5cf5.js" defer=""></script><script src="/_next/static/chunks/pages/_app-a2603426f792f9a7.js" defer=""></script><script src="/_next/static/chunks/799-575b46febca3af7d.js" defer=""></script><script src="/_next/static/chunks/399-cac0cd8ed02bf02a.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bslug%5D-ca05212d4081d62f.js" defer=""></script><script src="/_next/static/PAaIdI4HrRATEJvun4Ivk/_buildManifest.js" defer=""></script><script src="/_next/static/PAaIdI4HrRATEJvun4Ivk/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="min-h-screen"><header class="text-white bg-black drop-shadow-2xl"><div class="mx-auto my-0 max-w-[960px] py-6 px-4 flex items-center"><div class="flex items-center"><img alt="Ai.Haibara" src="/assets/blog/authors/haibara_2.jpg" width="100" height="100" decoding="async" data-nimg="1" class=" rounded-full" loading="lazy" style="color:transparent"/></div><div class="ml-6"><a class=" font-bold text-3xl" href="/">Ai.Haibara codes</a><div class="mt-2"><a class="p-1 rounded-sm text-xl mr-2 hover:border-b-2 border-indigo" href="/">Home</a><a class="p-1 rounded-sm text-xl mr-2 hover:border-b-2 border-indigo" href="/projects">Projects</a><a class="p-1 rounded-sm text-xl mr-2 hover:border-b-2 border-indigo" href="/talks">Talks</a><a class="p-1 rounded-sm text-xl mr-2 hover:border-b-2 border-indigo" href="/blogs">Blogs</a></div></div></div></header><main class="p-6 flex justify-center"><article><div class="flex justify-center font-[Arial]"><h1 class="text-5xl font-bold bg-indigo px-5 py-2 rounded-sm text-shadow-lg leading-[1.1]">swc-vs-babel</h1></div><time dateTime="2023-03-18" class="text-center block my-4 text-sm opacity-60">March	18, 2023</time><section><div class="markdown-body-fancy max-w-3xl"><h2 id="babel"><a aria-hidden="true" tabindex="-1" href="#babel"><span class="icon icon-link"></span></a>babel</h2>
<p>关于 babel 的介绍: &#x3C;<a href="https://lzs911.github.io/posts/babe">https://lzs911.github.io/posts/babe</a></p>
<h2 id="swc"><a aria-hidden="true" tabindex="-1" href="#swc"><span class="icon icon-link"></span></a>swc</h2>
<p><a href="https://swc.rs/">swc</a> 是通过 <a href="https://www.rust-lang.org/">rust</a> 实现的一个类 babel 工具, 而且在 swc 的官网，很直白说自己和 babel 对标，swc 和 babel 命令可以相互替换，并且大部分的 babel 插件也已经实现。</p>
<p>对比 babel, swc 的最大优势就是快, 这是底层语言所造成的原因. 所以现在很多能用rust重写的工具都开始进行重写.</p>
<p>光说可能并不能具体的体会 swc 到底有多快, 所以准备同时使用 babel 以及 swc 实现一个简易版本的 <code>babel-import-plugin</code>, 也就是将 <code>import { A, B } from 'lib'</code> 转化成 <code>import A from lib/A; import B from lib/B;</code>.</p>
<h2 id="对比"><a aria-hidden="true" tabindex="-1" href="#对比"><span class="icon icon-link"></span></a>对比</h2>
<p>先来看下 babel 的实现</p>
<pre><code class="language-javascript">const { traverse, parseSync, types: t } = require("@babel/core");
const generator = require("@babel/generator").default;

const transform = (content) => {
  const ast = parseSync(content);
  traverse(ast, {
    ImportDeclaration(_path) {
      const { node } = _path;

      const libraryName = node.source.value;

      const _program = _path.findParent((p) => p.isProgram());

      if (
        node.specifiers.filter((v) => v.type === "ImportDefaultSpecifier")
          .length > 0
      ) {
        return;
      }

      node.specifiers.forEach((v) => {
        const name = v.imported?.name ?? "";

        _program.pushContainer(
          "body",
          t.importDeclaration(
            [t.importDefaultSpecifier(t.identifier(name))],
            t.stringLiteral(`${libraryName}/lib/${name}`)
          )
        );
      });

      _path.remove();
      _path.skip();
    },
  });

  const out = generator(ast)?.code;
};
</code></pre>
<p>主要流程还是老三步:</p>
<ol>
<li>将原代码转化成 ast 树</li>
<li>遍历 ast, 处理符合条件的 import 语句, 将其转化成需要的格式, 同时使用 <code>program.pushContainer</code> 添加到原树中, 并且移除掉旧的节点.</li>
<li>将 ast 转化回字符串格式的代码.</li>
</ol>
<p>接下来看下 swc 的实现</p>
<pre><code class="language-javascript">const Visitor = require("@swc/core/Visitor").default;
const { transformSync } = require("@swc/core");

class PluginTransformImport extends Visitor {
  visitModuleItems(nodes) {
    const transformedNodes = [];

    for (const node of nodes) {
      const { type, source, specifiers } = node;

      if (type === "ImportDefaultSpecifier") {
        transformedNodes.push(node);
        continue;
      }

      specifiers.forEach((v) => {
        const name = v.local.value;
        const type = v.type;

        if (type === "ImportSpecifier") {
          const newSpecifier = {
            ...v,
            imported: null,
            type: "ImportDefaultSpecifier",
          };
          const value = `${source.value}/lib/${name}`;

          const copyNode = {
            ...node,
            source: {
              ...source,
              value,
            },
            specifiers: [newSpecifier],
            type: "ImportDeclaration",
          };

          transformedNodes.push(copyNode);
        }
      });
    }
    return transformedNodes;
  }
}

const transform = (content) => {
  const code =
    transformSync(content, {
      plugin: (v) => new PluginTransformImport().visitProgram(v),
    })?.code ?? "";
};

</code></pre>
<p>具体流程:</p>
<ol>
<li>新建一个类, 并且继承 <code>@swc/core</code> 提供的 <code>Visitor</code> 类.</li>
<li>实现对应节点类型的处理函数, 这里是 <code>visitModuleItems</code>, 这里与 babel 不同的是这里是通过函数的返回值来 replace 掉旧的节点</li>
<li>调用 transformSync, 将实现的类作为插件的形式传入</li>
</ol>
<p>下面是两者在对 10000 条 import 语句下的表现:</p>
<p><img src="/assets/swc_vs_babel/example-1.png" alt="alt">
<img src="/assets/swc_vs_babel/example-1.png" alt="alt"></p></div></section></article></main><footer class="bg-neutral-50 border-t border-neutral-200 text-center text-xs opacity-50 py-4">© 2022,<!-- --> <a rel="noopener noreferrer" class="hover:underline hover:bg-indigo" href="https://github.com/LZS911" target="_blank">LZS_911</a>, build with<!-- --> <a rel="noopener noreferrer" class="underline hover:bg-indigo" href="https://nextjs.org/" target="_blank">Next.js</a> <!-- -->and<!-- --> <a rel="noopener noreferrer" class="underline hover:bg-indigo" href="https://pages.github.com/?(null)" target="_blank">GitHub Pages</a></footer></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"swc-vs-babel","date":"2023-03-18","slug":"swc-vs-babel","author":"Ai.Haibara","content":"\u003ch2 id=\"babel\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#babel\"\u003e\u003cspan class=\"icon icon-link\"\u003e\u003c/span\u003e\u003c/a\u003ebabel\u003c/h2\u003e\n\u003cp\u003e关于 babel 的介绍: \u0026#x3C;\u003ca href=\"https://lzs911.github.io/posts/babe\"\u003ehttps://lzs911.github.io/posts/babe\u003c/a\u003e\u003c/p\u003e\n\u003ch2 id=\"swc\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#swc\"\u003e\u003cspan class=\"icon icon-link\"\u003e\u003c/span\u003e\u003c/a\u003eswc\u003c/h2\u003e\n\u003cp\u003e\u003ca href=\"https://swc.rs/\"\u003eswc\u003c/a\u003e 是通过 \u003ca href=\"https://www.rust-lang.org/\"\u003erust\u003c/a\u003e 实现的一个类 babel 工具, 而且在 swc 的官网，很直白说自己和 babel 对标，swc 和 babel 命令可以相互替换，并且大部分的 babel 插件也已经实现。\u003c/p\u003e\n\u003cp\u003e对比 babel, swc 的最大优势就是快, 这是底层语言所造成的原因. 所以现在很多能用rust重写的工具都开始进行重写.\u003c/p\u003e\n\u003cp\u003e光说可能并不能具体的体会 swc 到底有多快, 所以准备同时使用 babel 以及 swc 实现一个简易版本的 \u003ccode\u003ebabel-import-plugin\u003c/code\u003e, 也就是将 \u003ccode\u003eimport { A, B } from 'lib'\u003c/code\u003e 转化成 \u003ccode\u003eimport A from lib/A; import B from lib/B;\u003c/code\u003e.\u003c/p\u003e\n\u003ch2 id=\"对比\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#对比\"\u003e\u003cspan class=\"icon icon-link\"\u003e\u003c/span\u003e\u003c/a\u003e对比\u003c/h2\u003e\n\u003cp\u003e先来看下 babel 的实现\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003econst { traverse, parseSync, types: t } = require(\"@babel/core\");\nconst generator = require(\"@babel/generator\").default;\n\nconst transform = (content) =\u003e {\n  const ast = parseSync(content);\n  traverse(ast, {\n    ImportDeclaration(_path) {\n      const { node } = _path;\n\n      const libraryName = node.source.value;\n\n      const _program = _path.findParent((p) =\u003e p.isProgram());\n\n      if (\n        node.specifiers.filter((v) =\u003e v.type === \"ImportDefaultSpecifier\")\n          .length \u003e 0\n      ) {\n        return;\n      }\n\n      node.specifiers.forEach((v) =\u003e {\n        const name = v.imported?.name ?? \"\";\n\n        _program.pushContainer(\n          \"body\",\n          t.importDeclaration(\n            [t.importDefaultSpecifier(t.identifier(name))],\n            t.stringLiteral(`${libraryName}/lib/${name}`)\n          )\n        );\n      });\n\n      _path.remove();\n      _path.skip();\n    },\n  });\n\n  const out = generator(ast)?.code;\n};\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e主要流程还是老三步:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e将原代码转化成 ast 树\u003c/li\u003e\n\u003cli\u003e遍历 ast, 处理符合条件的 import 语句, 将其转化成需要的格式, 同时使用 \u003ccode\u003eprogram.pushContainer\u003c/code\u003e 添加到原树中, 并且移除掉旧的节点.\u003c/li\u003e\n\u003cli\u003e将 ast 转化回字符串格式的代码.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e接下来看下 swc 的实现\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003econst Visitor = require(\"@swc/core/Visitor\").default;\nconst { transformSync } = require(\"@swc/core\");\n\nclass PluginTransformImport extends Visitor {\n  visitModuleItems(nodes) {\n    const transformedNodes = [];\n\n    for (const node of nodes) {\n      const { type, source, specifiers } = node;\n\n      if (type === \"ImportDefaultSpecifier\") {\n        transformedNodes.push(node);\n        continue;\n      }\n\n      specifiers.forEach((v) =\u003e {\n        const name = v.local.value;\n        const type = v.type;\n\n        if (type === \"ImportSpecifier\") {\n          const newSpecifier = {\n            ...v,\n            imported: null,\n            type: \"ImportDefaultSpecifier\",\n          };\n          const value = `${source.value}/lib/${name}`;\n\n          const copyNode = {\n            ...node,\n            source: {\n              ...source,\n              value,\n            },\n            specifiers: [newSpecifier],\n            type: \"ImportDeclaration\",\n          };\n\n          transformedNodes.push(copyNode);\n        }\n      });\n    }\n    return transformedNodes;\n  }\n}\n\nconst transform = (content) =\u003e {\n  const code =\n    transformSync(content, {\n      plugin: (v) =\u003e new PluginTransformImport().visitProgram(v),\n    })?.code ?? \"\";\n};\n\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e具体流程:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e新建一个类, 并且继承 \u003ccode\u003e@swc/core\u003c/code\u003e 提供的 \u003ccode\u003eVisitor\u003c/code\u003e 类.\u003c/li\u003e\n\u003cli\u003e实现对应节点类型的处理函数, 这里是 \u003ccode\u003evisitModuleItems\u003c/code\u003e, 这里与 babel 不同的是这里是通过函数的返回值来 replace 掉旧的节点\u003c/li\u003e\n\u003cli\u003e调用 transformSync, 将实现的类作为插件的形式传入\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e下面是两者在对 10000 条 import 语句下的表现:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/swc_vs_babel/example-1.png\" alt=\"alt\"\u003e\n\u003cimg src=\"/assets/swc_vs_babel/example-1.png\" alt=\"alt\"\u003e\u003c/p\u003e","theme":"fancy","tag":[null]}},"__N_SSG":true},"page":"/posts/[slug]","query":{"slug":"swc-vs-babel"},"buildId":"PAaIdI4HrRATEJvun4Ivk","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>