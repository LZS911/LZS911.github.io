---
title: 记录在工作中学到的新知识
layout: post
date: "2021-11-16"
image:
headerImage: false
tag:
  -
star: true
category: blog
author: LZS_911
description: blog
---

# 前言

**工作中除了 `CRUD` 外每接触到一次新的技术, 都值得进行一次记录**

---

## 1. `MutationObserver`

### 介绍

MutationObserver 接口提供了监视对 DOM 树所做更改的能力。它被设计为旧的 Mutation Events 功能的替代品，该功能是 DOM3 Events 规范的一部分。([MDN](https://developer.mozilla.org/zh-CN/docs/Web/API/MutationObserver))

举个简单的栗子:

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <div id="app" class="test">
      <div>新增的dom节点:</div>
      <div id="addDom">
        <button onclick="addDom()">addDom</button>
      </div>
      <hr />
      <div>
        <div>修改的dom节点:</div>
        <span id="changeDom">change to valve</span>
        <button onclick="changeValue()">changeValue</button>
      </div>
      <hr />
      <div>
        <div>对属性进行修改:</div>
        <input id="input" type="text" />
        <button onclick="changeAttributes()">changeAttributes</button>
      </div>
    </div>
    <hr />
    <div>
      <div>未订阅的dom:</div>
      <span id="change">修改成Valve</span></span>
      <button onclick="change()">change</button>
    </div>
  </body>

  <script>
    const sourceStr = "valve";
    const targetStr = "Tencent";
    const sourceReg = /Valve/gi;
    // 观察器的配置（需要观察什么变动）
    const config = {
      characterData: true,
      attributes: true,
      childList: true,
      subtree: true,
    };

    const isIncludesSource = (target) =>
      typeof target === "string"
        ? target.toLowerCase().includes(sourceStr)
        : false;

    const replaceNodeValue = (node) => {
      if (!node?.childNodes) {
        return;
      }
      node.childNodes.forEach((n) => {
        if (isIncludesSource(n.nodeValue)) {
          n.nodeValue = n.nodeValue.replace(sourceReg, targetStr);
        } else {
          replaceNodeValue(n);
        }
      });
    };

    // 当观察到变动时执行的回调函数
    const callback = (mutationsList) => {
      mutationsList.forEach((mutation) => {
        const target = mutation.target;
        if (mutation.type === "childList") {
          //对新增的节点进行监听
          const nodes = mutation.addedNodes;
          if (!!nodes.forEach) {
            nodes.forEach((node) => {
              if (isIncludesSource(node?.innerHTML)) {
                replaceNodeValue(node);
              }
            });
          }
        } else if (mutation.type === "characterData") {
          //对修改的节点文本进行监听
          if (!!target && !!target.data && isIncludesSource(target.nodeValue)) {
            target.nodeValue = target.nodeValue.replace(sourceReg, targetStr);
          }
          // 对属性的修改进行监听
        } else if (mutation.type === "attributes") {
          const attributeName = mutation.attributeName;
          if (
            !!target &&
            !!attributeName &&
            ["placeholder"].includes(attributeName) &&
            isIncludesSource(mutation?.target?.attributes?.placeholder?.value)
          ) {
            target.setAttribute(
              "placeholder",
              mutation?.target?.attributes?.placeholder?.value.replace(
                sourceReg,
                targetStr
              )
            );
          }
        }
      });
    };

    const addDom = () => {
      const parent = document.getElementById("addDom");
      const el = document.createElement("div");
      const children = document.createElement("p");
      children.innerHTML = "Valve";
      el.appendChild(children);
      parent.appendChild(el);
    };

    const changeValue = () => {
      const el = document.getElementById("changeDom");
      if (!!el) {
        el.firstChild.nodeValue = "Valve";
      }
    };

    const changeAttributes = () => {
      const el = document.getElementById("input");
      if (!!el) {
        el.placeholder = "Valve";
      }
    };

    const change = () => {
      const el = document.getElementById('change');
      if(!!el){
        el.firstChild.nodeValue = 'Valve'
      }
    }
    window.onload = () => {
      // 创建一个观察器实例并传入回调函数
      const observer = new MutationObserver(callback);
      const targetNode = document.getElementById("app");
      // 以上述配置开始观察目标节点
      observer.observe(targetNode, config);
    };
  </script>
</html>

```

[代码地址](https://codesandbox.io/s/compassionate-benji-09ddn?file=/index.html)

效果如下图:

![alt](https://raw.githubusercontent.com/LZS911/LZS911.github.io/main/assets/images/study/MutationObserver/MutationObserver-01.gif)

可以看到在我们可以监听到对 dom 的各种操作, 更多 `API` 相关知识可以从 [MDN](https://developer.mozilla.org/zh-CN/docs/Web/API/MutationObserver) 中进行了解.

### 契机

那么是什么具体的场景能在工作中有机会使用到这个 `API`呢? 时间线回到前天, 某甲方提出将产品界面中出现的某个文本全部替换成另一个文本, 并且不是在使用上的需求, 而是单纯进行产品展示. 最开始的方案很简单, 新建一个分支将代码中文本进行全局替换, 但这样没办法处理到后端返回的数据, 如果前后端都要进行处理, 那样便增加了开发成本. 于是便找到了这个 `API` 来对界面中的文本进行处理.

### 注意点

1. 对于界面上普通的文本展示和输入框的 `placeholder` 属性使用上方的示例代码都可以解决了, 但是项目中还包含着大量只读的输入框文本, 必须同时对输入框的 `value`属性进行处理.

[代码地址](https://codesandbox.io/s/festive-franklin-pbsib?file=/index.html)

这里需要注意的是 `setAttribute` 设置 `value`和使用 `property` 属性(`node.value='xxx'`)的区别

- `attribute` 是指定的默认值, 并且使用 `get`时可能得不到期望的值
- 使用 `property` 属性是访问或修改当前值, 当使用这种方式赋值时不会触发 `MutationObserver` 对属性的监听.

2. 考虑到 `antd` 的 `modal`组件默认挂载在 `app`同级节点, 也就是 `body`下, 所以需要将监听的目标节点需要设置为 `body`.
