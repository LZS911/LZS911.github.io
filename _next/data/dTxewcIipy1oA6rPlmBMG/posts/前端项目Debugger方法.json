{"pageProps":{"post":{"title":"前端项目Debugger方法","date":"2023-02-16","slug":"前端项目Debugger方法","author":"Ai.Haibara","content":"<h2 id=\"1-console\"><a aria-hidden=\"true\" tabindex=\"-1\" href=\"#1-console\"><span class=\"icon icon-link\"></span></a>1. Console</h2>\n<p><code>console</code> 对象提供了浏览器控制台调试的接口, 能够直接将内容输出在浏览器控制台上, 类似 c 语言中的 <code>printf</code>. 同时 <code>node.js</code> 也提供了 <code>node:console</code> 模块, 效果与浏览器类似. 具体 Api 介绍:</p>\n<ul>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Console\">Web</a></li>\n<li><a href=\"https://nodejs.org/api/console.html\">Node.js</a></li>\n</ul>\n<h2 id=\"2-浏览器开发者工具\"><a aria-hidden=\"true\" tabindex=\"-1\" href=\"#2-浏览器开发者工具\"><span class=\"icon icon-link\"></span></a>2. 浏览器开发者工具</h2>\n<p>当我们调试一个 web 项目时, 我们可以使用浏览器自带的 developer tools, 这里我们以 chrome 为例:</p>\n<p><img src=\"/assets/debugger_methods/example-1.gif\" alt=\"example-1\"></p>\n<h2 id=\"3-vscode-debugger\"><a aria-hidden=\"true\" tabindex=\"-1\" href=\"#3-vscode-debugger\"><span class=\"icon icon-link\"></span></a>3. vscode Debugger</h2>\n<p>vscode 提供了 “Run and Debug” 视窗, 默认情况它长这个样:</p>\n<p><img src=\"/assets/debugger_methods/example-2.png\" alt=\"example-2\"></p>\n<p>这里我们点击 <code>create launch.json file</code> 来创建一个配置文件后即可开始调试. 具体配置见: <a href=\"https://code.visualstudio.com/docs/editor/debugging#_run-and-debug-view\">https://code.visualstudio.com/docs/editor/debugging#_run-and-debug-view</a></p>\n<p>接下来看下使用 Debug 视窗调试一个 node 项目会带来哪些提升.</p>\n<h3 id=\"1-breakpoint\"><a aria-hidden=\"true\" tabindex=\"-1\" href=\"#1-breakpoint\"><span class=\"icon icon-link\"></span></a>1. Breakpoint</h3>\n<p>当我们开始调试并设置断点后可以看到以下画面:</p>\n<p><img src=\"/assets/debugger_methods/example-3.png\" alt=\"example-2\"></p>\n<p>设置断点后我们可以更方便的观察到运行环境中的变量以及一些全局方法和全局变量, 并且可以以更高的效率去阅读一些项目源码.</p>\n<h3 id=\"2-logpoint\"><a aria-hidden=\"true\" tabindex=\"-1\" href=\"#2-logpoint\"><span class=\"icon icon-link\"></span></a>2. LogPoint</h3>\n<p>添加 LogPoint 后, 当执行到该处时, 便会在 debug 控制台输出 log 信息, 在实现 console 功能的同时无需修改代码.</p>\n<p><img src=\"/assets/debugger_methods/example-4.gif\" alt=\"example-2\"></p>\n<h3 id=\"3-debugger-web项目\"><a aria-hidden=\"true\" tabindex=\"-1\" href=\"#3-debugger-web项目\"><span class=\"icon icon-link\"></span></a>3. Debugger Web项目</h3>\n<p>除了 node 项目, vscode Debugger 同时也是可以调试一个 web 项目. 同样, 我们需要创建一个 <code>launch.json</code> 文件, 环境我们这里以 chrome 为例. 创建配置文件将 url 的值配置为开发环境下项目的地址, 我们便可以开始 Debugger 一个 web 项目了.</p>\n<p><img src=\"/assets/debugger_methods/example-5.png\" alt=\"example-2\"></p>\n<p>当我们开始调试时, vscode 会帮助我们新开一个 chrome 窗口, 我们在这个窗口下的操作都触发我们添加的 Breakpoint 以及 LogPoint.</p>\n<p><img src=\"/assets/debugger_methods/example-6.gif\" alt=\"example-2\"></p>\n<h2 id=\"4-在调试过程中融入自动化操作\"><a aria-hidden=\"true\" tabindex=\"-1\" href=\"#4-在调试过程中融入自动化操作\"><span class=\"icon icon-link\"></span></a>4. 在调试过程中融入自动化操作</h2>\n<p>当我们在开发项目业务逻辑, 特别是长表单提交逻辑时, 每次调试都需要填一大堆东西, 并且在开始调试时, 都先需要进行登录操作, 然后进入到开发页面进行操作, 这个操作还是比较繁琐的. 这个时候我们是否能通过自动脚本在调试时自动执行这一部分流程呢?</p>\n<h3 id=\"1-选择一个自动化工具\"><a aria-hidden=\"true\" tabindex=\"-1\" href=\"#1-选择一个自动化工具\"><span class=\"icon icon-link\"></span></a>1. 选择一个自动化工具</h3>\n<p>这里我们选择 <a href=\"https://github.com/puppeteer/puppeteer\">Puppeteer</a>. Puppeteer 是一个 Node 库，它提供了一个高级 API 来通过 DevTools 协议控制 Chromium 或 Chrome. 和我们的调试环境完美适配, 接下来看怎样将其融合进调试流程中.</p>\n<h3 id=\"2-将-puppeteer-融合进调试流程\"><a aria-hidden=\"true\" tabindex=\"-1\" href=\"#2-将-puppeteer-融合进调试流程\"><span class=\"icon icon-link\"></span></a>2. 将 Puppeteer 融合进调试流程</h3>\n<p>首先来看一下一段 node 脚本:</p>\n<pre><code class=\"language-javascript\">const puppeteer = require(\"puppeteer\");\n\n(async () => {\n  const browser = await puppeteer.launch({\n    headless: false,\n    defaultViewport: {\n      width: 0,\n      height: 0,\n    },\n  });\n\n  const page = await browser.newPage();\n  await page.goto(\"http://localhost:4546/login\");\n  await page.waitForSelector(\"#emailAddress\");\n\n  const $emailAddress = await page.$(\"#emailAddress\");\n  await $emailAddress.type(\"demo@gmail.com\", {\n    delay: 100,\n  });\n\n  const $password = await page.$(\"#password\");\n  await $password.type(\"123456\", {\n    delay: 100,\n  });\n\n  const $button = await page.$('button[type=\"submit\"]');\n  await $button.click();\n})();\n</code></pre>\n<p>使用 Puppeteer 启动一个 chrome 窗口, headless 设置为 false 表示需要显示窗口, 同时设置视窗宽高. 打开新页面, 将其导航至指定的地址, 等待 <code>#emailAddress</code> 元素出现后, 输入邮箱地址和密码, 点击提交按钮.</p>\n<p>现在我们成功执行了一段浏览器自动化脚本, 但是存在一个问题: vscode debug 打开的 chrome 视窗与 Puppeteer 打开的并不相同, 在 Puppeteer 执行自动化脚本时, 并不会进入 vscode 中的 Breakpoint, 有没有办法使它们使用同一个chrome 视窗呢?</p>\n<p>现在我们回到调试的配置文件, 其中有一个关键字段: request, 它有两个值, <code>Launch</code> 以及 <code>Attach</code>, 创建后的默认值为 <code>Launch</code>, 其代表调试时新开一个窗口, 而 <code>Attach</code> 表示附加到某一浏览器中. 具体解释见: <a href=\"https://code.visualstudio.com/Docs/editor/debugging#_launch-versus-attach-configurations\">https://code.visualstudio.com/Docs/editor/debugging#_launch-versus-attach-configurations</a></p>\n<p>现在我们便可等 Puppeteer 新开窗口后, 将调试进程附加到上面, 便可以进行融合了, 我们来具体试一下:</p>\n<p>修改 Puppeteer 脚本:</p>\n<pre><code class=\"language-javascript\">const puppeteer = require(\"puppeteer\");\nconst readline = require(\"readline\");\n\n(async () => {\n  const browser = await puppeteer.launch({\n    headless: false,\n    defaultViewport: {\n      width: 0,\n      height: 0,\n    },\n    debuggingPort: 9222,\n  });\n\n  const page = await browser.newPage();\n\n  const rl = readline.createInterface({\n    input: process.stdin,\n    output: process.stdout,\n  });\n\n  rl.on(\"line\", async (str) => {\n    if (str === \"login\") {\n      await login(page);\n    }\n    if (str === \"operationRecord\") {\n      await testOperationRecord(page);\n    }\n  });\n})();\n\nconst login = async (page) => {\n  await page.goto(\"http://localhost:4546\");\n  await page.waitForSelector(\"#emailAddress\");\n  const $emailAddress = await page.$(\"#emailAddress\");\n  await $emailAddress.type(\"demo@gmail.com\", {\n    delay: 100,\n  });\n\n  const $password = await page.$(\"#password\");\n  await $password.type(\"123456\", {\n    delay: 100,\n  });\n\n  const $button = await page.$('button[type=\"submit\"]');\n  await $button.click();\n};\n</code></pre>\n<p>同时更改 <code>launch.file</code>:</p>\n<pre><code class=\"language-json\">{\n  \"version\": \"0.2.0\",\n  \"configurations\": [\n    {\n      \"type\": \"pwa-chrome\",\n      \"request\": \"attach\",\n      \"port\": 9222,\n      \"name\": \"Launch Chrome against localhost\",\n      \"webRoot\": \"${workspaceFolder}\"\n    }\n  ]\n}\n</code></pre>\n<p>最终效果如下:</p>\n<p><img src=\"/assets/debugger_methods/example-7.gif\" alt=\"example-2\"></p>","theme":"fancy","tag":[null]}},"__N_SSG":true}