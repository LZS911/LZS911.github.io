{"pageProps":{"post":{"title":"JavaScript 中的抽象类","date":"2025-03-05","slug":"JavaScript 中的抽象类","author":"LZS_911","content":"<p>在 JavaScript 中，抽象类的概念并不像 Java、TypeScript 和 Python 等其他语言那样得到原生支持。然而，我们可以通过编写自定义代码来模拟 JavaScript 中抽象类的行为。</p>\n<p>本文将解释什么是抽象类、抽象类与函数式编程的对比，以及如何在 JavaScript 中实现抽象类。鉴于 TypeScript 是一种基于 JavaScript 的编程语言，这里将用它来解释抽象类的概念，以便于理解。</p>\n<h2 id=\"什么是抽象类\"><a aria-hidden=\"true\" tabindex=\"-1\" href=\"#什么是抽象类\"><span class=\"icon icon-link\"></span></a>什么是抽象类？</h2>\n<p>在面向对象编程（OOP）中，所有的对象都是通过类来描述的。然而，并不是所有的类都用于描述具体的对象。如果一个类中没有包含足够的信息来描述一个具体的对象，这样的类就是<strong>抽象类</strong>。</p>\n<p>抽象类除了不能实例化对象之外，类的其他功能依然存在。成员变量、成员方法和构造方法的访问方式与普通类一样。</p>\n<p>由于抽象类不能实例化对象，因此抽象类必须被继承才能使用。这也是为什么通常在设计阶段就要决定是否要设计抽象类。</p>\n<p>父类包含了子类集合的常见方法，但由于父类本身是抽象的，因此不能直接使用这些方法。</p>\n<h3 id=\"示例typescript-中的抽象类\"><a aria-hidden=\"true\" tabindex=\"-1\" href=\"#示例typescript-中的抽象类\"><span class=\"icon icon-link\"></span></a>示例：TypeScript 中的抽象类</h3>\n<p>在 TypeScript 中，类、方法和字段可以是抽象的。抽象方法或抽象字段是尚未提供实现的方法或字段。这些成员必须存在于抽象类中，而抽象类不能直接实例化。</p>\n<p>抽象类的作用是作为子类的基类，子类会实现所有抽象成员。如果一个类没有任何抽象成员，则称其为<strong>具体类</strong>。</p>\n<p>以下是一个抽象类 <code>BaseConfigUtils</code> 的示例：</p>\n<pre><code class=\"hljs language-typescript\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">abstract</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">BaseConfigUtils</span>&#x3C;\n  T <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">BaseConfig</span>,\n  <span class=\"hljs-title class_\">InitOptions</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">BaseOptions</span>,\n  <span class=\"hljs-title class_\">ResolvedOptions</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">InitOptions</span>\n> {\n  <span class=\"hljs-comment\">// ...existing code...</span>\n\n  <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\"><span class=\"hljs-attr\">options</span>: <span class=\"hljs-title class_\">ConfigOptions</span>&#x3C;T, <span class=\"hljs-title class_\">InitOptions</span>, <span class=\"hljs-title class_\">ResolvedOptions</span>></span>) {\n    <span class=\"hljs-comment\">// ...existing code...</span>\n  }\n\n  <span class=\"hljs-keyword\">async</span> <span class=\"hljs-title function_\">resolveConfig</span>(<span class=\"hljs-attr\">opts</span>: <span class=\"hljs-built_in\">unknown</span>): <span class=\"hljs-title class_\">Promise</span>&#x3C;T> {\n    <span class=\"hljs-comment\">// ...existing code...</span>\n  }\n\n  <span class=\"hljs-keyword\">protected</span> <span class=\"hljs-keyword\">async</span> <span class=\"hljs-title function_\">handleNonInteractiveMode</span>(\n    <span class=\"hljs-attr\">opts</span>: <span class=\"hljs-title class_\">InitOptions</span>,\n    <span class=\"hljs-attr\">existingConfig</span>: T | <span class=\"hljs-literal\">null</span>\n  ): <span class=\"hljs-title class_\">Promise</span>&#x3C;T> {\n    <span class=\"hljs-comment\">// ...existing code...</span>\n  }\n\n  <span class=\"hljs-keyword\">protected</span> <span class=\"hljs-keyword\">abstract</span> <span class=\"hljs-title function_\">handleInteractiveMode</span>(\n    <span class=\"hljs-attr\">opts</span>: <span class=\"hljs-title class_\">InitOptions</span>,\n    <span class=\"hljs-attr\">existingConfig</span>: T | <span class=\"hljs-literal\">null</span>\n  ): <span class=\"hljs-title class_\">Promise</span>&#x3C;T>;\n\n  <span class=\"hljs-keyword\">protected</span> <span class=\"hljs-keyword\">abstract</span> <span class=\"hljs-title function_\">mergeConfig</span>(\n    <span class=\"hljs-attr\">opts</span>: <span class=\"hljs-title class_\">InitOptions</span>,\n    <span class=\"hljs-attr\">existingConfig</span>: T\n  ): <span class=\"hljs-title class_\">Promise</span>&#x3C;T>;\n\n  <span class=\"hljs-keyword\">protected</span> <span class=\"hljs-keyword\">abstract</span> <span class=\"hljs-title function_\">transformToConfig</span>(<span class=\"hljs-attr\">opts</span>: <span class=\"hljs-title class_\">ResolvedOptions</span>): T;\n\n  <span class=\"hljs-keyword\">protected</span> <span class=\"hljs-keyword\">abstract</span> <span class=\"hljs-title function_\">getConfigIdentifier</span>(<span class=\"hljs-attr\">opts</span>: <span class=\"hljs-title class_\">InitOptions</span>): <span class=\"hljs-built_in\">string</span>;\n\n  <span class=\"hljs-comment\">// ...existing code...</span>\n}\n</code></pre>\n<p>在这个示例中，<code>BaseConfigUtils</code> 定义了处理配置文件的结构。子类必须实现 <code>handleInteractiveMode</code>、<code>mergeConfig</code>、<code>transformToConfig</code> 和 <code>getConfigIdentifier</code> 等方法。</p>\n<h2 id=\"函数式编程方法\"><a aria-hidden=\"true\" tabindex=\"-1\" href=\"#函数式编程方法\"><span class=\"icon icon-link\"></span></a>函数式编程方法</h2>\n<p>函数式编程（FP）是一种将计算视为数学函数求值的范式，它避免改变状态和可变数据。FP 不使用类和继承，而是依赖纯函数和高阶函数。</p>\n<h3 id=\"示例typescript中的函数式编程\"><a aria-hidden=\"true\" tabindex=\"-1\" href=\"#示例typescript中的函数式编程\"><span class=\"icon icon-link\"></span></a>示例：TypeScript中的函数式编程</h3>\n<p>以下是使用函数式编程实现类似功能的示例：</p>\n<pre><code class=\"hljs language-typescript\"><span class=\"hljs-keyword\">type</span> <span class=\"hljs-title class_\">ConfigKey</span> = <span class=\"hljs-string\">'client'</span> | <span class=\"hljs-string\">'mocks'</span>;\n\n<span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">BaseConfig</span> {\n  [<span class=\"hljs-attr\">key</span>: <span class=\"hljs-built_in\">string</span>]: <span class=\"hljs-built_in\">string</span>;\n}\n\n<span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">BaseOptions</span> {\n  <span class=\"hljs-attr\">yes</span>: <span class=\"hljs-built_in\">boolean</span>;\n  <span class=\"hljs-attr\">cwd</span>: <span class=\"hljs-built_in\">string</span>;\n  [<span class=\"hljs-attr\">key</span>: <span class=\"hljs-built_in\">string</span>]: <span class=\"hljs-built_in\">unknown</span>;\n}\n\n<span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">ConfigOptions</span>&#x3C;T <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">BaseConfig</span>, <span class=\"hljs-title class_\">InitOptions</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">BaseOptions</span>, <span class=\"hljs-title class_\">ResolvedOptions</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">InitOptions</span>> {\n  <span class=\"hljs-attr\">configKey</span>: <span class=\"hljs-title class_\">ConfigKey</span>;\n  <span class=\"hljs-attr\">initOptionsSchema</span>: z.<span class=\"hljs-property\">ZodSchema</span>&#x3C;<span class=\"hljs-title class_\">InitOptions</span>>;\n  <span class=\"hljs-attr\">resolvedOptionsSchema</span>: z.<span class=\"hljs-property\">ZodSchema</span>&#x3C;<span class=\"hljs-title class_\">ResolvedOptions</span>>;\n  <span class=\"hljs-attr\">defaultConfig</span>: T;\n  <span class=\"hljs-attr\">command</span>: <span class=\"hljs-title class_\">Command</span>;\n  <span class=\"hljs-attr\">cwd</span>: <span class=\"hljs-built_in\">string</span>;\n  <span class=\"hljs-title function_\">handleInteractiveMode</span>(\n    <span class=\"hljs-attr\">opts</span>: <span class=\"hljs-title class_\">InitOptions</span>,\n    <span class=\"hljs-attr\">existingConfig</span>: T | <span class=\"hljs-literal\">null</span>\n  ): <span class=\"hljs-title class_\">Promise</span>&#x3C;T>;\n  <span class=\"hljs-title function_\">transformToConfig</span>(<span class=\"hljs-attr\">opts</span>: <span class=\"hljs-title class_\">ResolvedOptions</span>): T;\n  <span class=\"hljs-title function_\">getConfigIdentifier</span>(<span class=\"hljs-attr\">opts</span>: <span class=\"hljs-title class_\">InitOptions</span>): <span class=\"hljs-built_in\">string</span>;\n  <span class=\"hljs-title function_\">mergeConfig</span>(\n    <span class=\"hljs-attr\">opts</span>: <span class=\"hljs-title class_\">InitOptions</span>,\n    <span class=\"hljs-attr\">existingConfig</span>: T\n  ): <span class=\"hljs-title class_\">Promise</span>&#x3C;T>;\n}\n\n<span class=\"hljs-keyword\">const</span> resolveConfig = <span class=\"hljs-keyword\">async</span> &#x3C;T <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">BaseConfig</span>, <span class=\"hljs-title class_\">InitOptions</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">BaseOptions</span>, <span class=\"hljs-title class_\">ResolvedOptions</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">InitOptions</span>>(\n  <span class=\"hljs-attr\">options</span>: <span class=\"hljs-title class_\">ConfigOptions</span>&#x3C;T, <span class=\"hljs-title class_\">InitOptions</span>, <span class=\"hljs-title class_\">ResolvedOptions</span>>,\n  <span class=\"hljs-attr\">opts</span>: <span class=\"hljs-built_in\">unknown</span>\n): <span class=\"hljs-title class_\">Promise</span>&#x3C;T> => {\n  <span class=\"hljs-keyword\">const</span> { transformToConfig, getConfigIdentifier, mergeConfig, handleInteractiveMode } = options;\n  <span class=\"hljs-keyword\">const</span> validatedOpts = <span class=\"hljs-keyword\">await</span> options.<span class=\"hljs-property\">initOptionsSchema</span>.<span class=\"hljs-title function_\">parseAsync</span>(opts).<span class=\"hljs-title function_\">catch</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">error</span>) =></span> {\n    <span class=\"hljs-title function_\">handleSchemaError</span>(error, options.<span class=\"hljs-property\">command</span>);\n  });\n\n  <span class=\"hljs-keyword\">const</span> existingConfig = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title function_\">getRawConfigs</span>(options.<span class=\"hljs-property\">cwd</span>, options.<span class=\"hljs-property\">configKey</span>, <span class=\"hljs-title function_\">getConfigIdentifier</span>(validatedOpts));\n\n  <span class=\"hljs-keyword\">if</span> (validatedOpts.<span class=\"hljs-property\">yes</span>) {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title function_\">handleNonInteractiveMode</span>(options, validatedOpts, existingConfig);\n  }\n\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title function_\">handleInteractiveMode</span>(options, validatedOpts, existingConfig);\n};\n\n<span class=\"hljs-keyword\">const</span> handleNonInteractiveMode = <span class=\"hljs-keyword\">async</span> &#x3C;T <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">BaseConfig</span>, <span class=\"hljs-title class_\">InitOptions</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">BaseOptions</span>, <span class=\"hljs-title class_\">ResolvedOptions</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">InitOptions</span>>(\n  <span class=\"hljs-attr\">options</span>: <span class=\"hljs-title class_\">ConfigOptions</span>&#x3C;T, <span class=\"hljs-title class_\">InitOptions</span>, <span class=\"hljs-title class_\">ResolvedOptions</span>>,\n  <span class=\"hljs-attr\">opts</span>: <span class=\"hljs-title class_\">InitOptions</span>,\n  <span class=\"hljs-attr\">existingConfig</span>: T | <span class=\"hljs-literal\">null</span>\n): <span class=\"hljs-title class_\">Promise</span>&#x3C;T> => {\n  <span class=\"hljs-keyword\">if</span> (existingConfig) {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title function_\">mergeConfig</span>(opts, existingConfig);\n  }\n\n  <span class=\"hljs-keyword\">try</span> {\n    <span class=\"hljs-keyword\">const</span> validatedOpts = <span class=\"hljs-keyword\">await</span> options.<span class=\"hljs-property\">resolvedOptionsSchema</span>.<span class=\"hljs-title function_\">parseAsync</span>(opts);\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title function_\">transformToConfig</span>(validatedOpts);\n  } <span class=\"hljs-keyword\">catch</span> (error) {\n    <span class=\"hljs-title function_\">handleSchemaError</span>(error, options.<span class=\"hljs-property\">command</span>);\n  }\n};\n\n<span class=\"hljs-comment\">// 定义其他函数，如 getRawConfigs</span>\n</code></pre>\n<h2 id=\"抽象类与函数式编程的比较\"><a aria-hidden=\"true\" tabindex=\"-1\" href=\"#抽象类与函数式编程的比较\"><span class=\"icon icon-link\"></span></a>抽象类与函数式编程的比较</h2>\n<h3 id=\"抽象类\"><a aria-hidden=\"true\" tabindex=\"-1\" href=\"#抽象类\"><span class=\"icon icon-link\"></span></a>抽象类</h3>\n<ul>\n<li><strong>优点</strong>：\n<ul>\n<li>结构清晰，组织有序。</li>\n<li>强制一致的接口。</li>\n<li>对于熟悉面向对象编程（OOP）的开发人员来说更容易理解。</li>\n</ul>\n</li>\n<li><strong>缺点</strong>：\n<ul>\n<li>可能导致复杂的继承层次结构。</li>\n<li>在组合方面灵活性较差。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"函数式编程\"><a aria-hidden=\"true\" tabindex=\"-1\" href=\"#函数式编程\"><span class=\"icon icon-link\"></span></a>函数式编程</h3>\n<ul>\n<li><strong>优点</strong>：\n<ul>\n<li>提倡不变性和纯函数。</li>\n<li>更容易组合和重用函数。</li>\n<li>避免了继承的陷阱。</li>\n</ul>\n</li>\n<li><strong>缺点</strong>：\n<ul>\n<li>对于习惯于 OOP 的开发人员来说可能更难理解。</li>\n<li>在管理状态和依赖项时可能会导致更多的样板代码。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"javascript-中的抽象类\"><a aria-hidden=\"true\" tabindex=\"-1\" href=\"#javascript-中的抽象类\"><span class=\"icon icon-link\"></span></a>JavaScript 中的抽象类</h2>\n<pre><code class=\"hljs language-typescript\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Base</span> {\n  <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\">name</span>) {\n    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">constructor</span> == <span class=\"hljs-title class_\">Base</span>) {\n      <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Error</span>(<span class=\"hljs-string\">\"Class is of abstract type and can't be instantiated\"</span>);\n    }\n\n    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">getName</span> == <span class=\"hljs-literal\">undefined</span>) {\n      <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Error</span>(<span class=\"hljs-string\">'getName method must be implemented'</span>);\n    }\n    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">name</span> = name;\n  }\n\n  <span class=\"hljs-title function_\">printName</span>(<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">'Hello, '</span> + <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-title function_\">getName</span>());\n  }\n}\n\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Derived</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_ inherited__\">Base</span> {\n  <span class=\"hljs-title function_\">getName</span>(<span class=\"hljs-params\"></span>) {\n     <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">'world'</span>;\n  }\n}\n\n<span class=\"hljs-comment\">// const b = new Base();</span>\n<span class=\"hljs-keyword\">const</span> d = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Derived</span>();\n\nd.<span class=\"hljs-title function_\">printName</span>();\n</code></pre>\n<h2 id=\"结论\"><a aria-hidden=\"true\" tabindex=\"-1\" href=\"#结论\"><span class=\"icon icon-link\"></span></a>结论</h2>\n<p>抽象类和函数式编程各有优缺点。抽象类提供了一种清晰且结构化的方法来强制接口和共享行为，而函数式编程则提供了灵活性并提倡不变性。选择哪种方法取决于项目的具体需求和团队对每种范式的熟悉程度。</p>\n<p>如果想要在 JavaScript 中创建抽象类，建议使用 TypeScript，因为它不仅提供了类型安全性，还原生支持抽象类的概念。</p>","theme":"condensed-night-purple","tag":null}},"__N_SSG":true}