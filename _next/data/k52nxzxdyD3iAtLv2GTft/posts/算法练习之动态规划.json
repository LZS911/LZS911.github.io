{"pageProps":{"post":{"title":"算法练习之动态规划","date":"2021-11-12","slug":"算法练习之动态规划","author":"LZS_911","content":"<h3 id=\"粉刷房间\"><a aria-hidden=\"true\" tabindex=\"-1\" href=\"#粉刷房间\"><span class=\"icon icon-link\"></span></a>粉刷房间</h3>\n<hr>\n<h4 id=\"题目描述\"><a aria-hidden=\"true\" tabindex=\"-1\" href=\"#题目描述\"><span class=\"icon icon-link\"></span></a>题目描述</h4>\n<pre><code>假如有一排房子，共 n 个，每个房子可以被粉刷成红色、蓝色或者绿色这三种颜色中的一种，你需要粉刷所有的房子并且使其相邻的两个房子颜色不能相同。\n\n当然，因为市场上不同颜色油漆的价格不同，所以房子粉刷成不同颜色的花费成本也是不同的。每个房子粉刷成不同颜色的花费是以一个 n x 3 的正整数矩阵 costs 来表示的。\n\n例如，costs[0][0] 表示第 0 号房子粉刷成红色的成本花费；costs[1][2] 表示第 1 号房子粉刷成绿色的花费，以此类推。\n\n请计算出粉刷完所有房子最少的花费成本。\n</code></pre>\n<h4 id=\"解题思路\"><a aria-hidden=\"true\" tabindex=\"-1\" href=\"#解题思路\"><span class=\"icon icon-link\"></span></a>解题思路</h4>\n<ol>\n<li>递归暴力法</li>\n</ol>\n<pre><code class=\"hljs language-typescript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">minCost</span>(<span class=\"hljs-params\"><span class=\"hljs-attr\">costs</span>: <span class=\"hljs-built_in\">number</span>[][]</span>) {\n  <span class=\"hljs-keyword\">const</span> len = costs.<span class=\"hljs-property\">length</span>;\n\n  <span class=\"hljs-keyword\">if</span> (len === <span class=\"hljs-number\">1</span>) {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">min</span>(...costs[<span class=\"hljs-number\">0</span>]);\n  }\n\n  <span class=\"hljs-keyword\">const</span> fn = (<span class=\"hljs-attr\">prevIndex</span>: <span class=\"hljs-built_in\">number</span>, <span class=\"hljs-attr\">count</span>: <span class=\"hljs-built_in\">number</span>, <span class=\"hljs-attr\">res</span>: <span class=\"hljs-built_in\">number</span>): <span class=\"hljs-function\"><span class=\"hljs-params\">number</span> =></span> {\n    <span class=\"hljs-keyword\">if</span> (count === len) {\n      <span class=\"hljs-keyword\">return</span> res;\n    }\n    <span class=\"hljs-keyword\">const</span> map = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Map</span>&#x3C;<span class=\"hljs-built_in\">number</span>, <span class=\"hljs-built_in\">number</span>[]>([\n      [<span class=\"hljs-number\">0</span>, [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>]],\n      [<span class=\"hljs-number\">1</span>, [<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">2</span>]],\n      [<span class=\"hljs-number\">2</span>, [<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>]],\n    ]);\n    <span class=\"hljs-keyword\">const</span> arr = map.<span class=\"hljs-title function_\">get</span>(prevIndex)!;\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">min</span>(...arr.<span class=\"hljs-title function_\">map</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">v</span>) =></span> <span class=\"hljs-title function_\">fn</span>(v, count + <span class=\"hljs-number\">1</span>, res + costs[count][v])));\n  };\n\n  <span class=\"hljs-keyword\">const</span> r = <span class=\"hljs-title function_\">fn</span>(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>, costs[<span class=\"hljs-number\">0</span>][<span class=\"hljs-number\">0</span>]);\n  <span class=\"hljs-keyword\">const</span> g = <span class=\"hljs-title function_\">fn</span>(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">1</span>, costs[<span class=\"hljs-number\">0</span>][<span class=\"hljs-number\">1</span>]);\n  <span class=\"hljs-keyword\">const</span> b = <span class=\"hljs-title function_\">fn</span>(<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">1</span>, costs[<span class=\"hljs-number\">0</span>][<span class=\"hljs-number\">2</span>]);\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">min</span>(r, g, b);\n}\n</code></pre>\n<p>不需要思考任何算法的一种方式, 直接递归计算出所有可能, 但是中间会包含很多重复计算, 执行 <code>LeetCode</code> 测试时会超时. 所以需要进一步思考最优解.</p>\n<ol start=\"2\">\n<li>动态规划</li>\n</ol>\n<pre><code class=\"hljs language-typescript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">minCost</span>(<span class=\"hljs-params\"><span class=\"hljs-attr\">costs</span>: <span class=\"hljs-built_in\">number</span>[][]</span>) {\n  <span class=\"hljs-keyword\">let</span> [r, b, g] = costs[<span class=\"hljs-number\">0</span>];\n  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i = <span class=\"hljs-number\">1</span>; i &#x3C; costs.<span class=\"hljs-property\">length</span>; ++i) {\n    [r, b, g] = [\n      <span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">min</span>(b, g) + costs[i][<span class=\"hljs-number\">0</span>],\n      <span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">min</span>(r, g) + costs[i][<span class=\"hljs-number\">1</span>],\n      <span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">min</span>(r, b) + costs[i][<span class=\"hljs-number\">2</span>],\n    ];\n  }\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">min</span>(r, g, b);\n}\n</code></pre>\n<p>大致思路:</p>\n<ol>\n<li>定义变量 r、b、g 分别表示粉刷至某一间房时红色、蓝色、绿色所需粉刷的最小花费</li>\n</ol>\n<ul>\n<li>let [r, b, g] = costs[0] 即表示粉刷第一间时的最小花费</li>\n</ul>\n<ol start=\"2\">\n<li>从第二间房开始遍历, 第二间房可粉刷三种任意颜色, 但限制条件为粉刷红色时, 前一间房子的粉刷只能为绿色或蓝色, 依次类推, 得到</li>\n</ol>\n<pre><code class=\"hljs language-typescript\">[r, b, g] = [\n  <span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">min</span>(b, g) + costs[i][<span class=\"hljs-number\">0</span>],\n  <span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">min</span>(r, g) + costs[i][<span class=\"hljs-number\">1</span>],\n  <span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">min</span>(r, b) + costs[i][<span class=\"hljs-number\">2</span>],\n];\n</code></pre>\n<p><strong>这里使用了 ES6 的数组解构, 类似于对象解构, 赋值语句左侧为粉刷到第 <code>i</code> 间房对应某一种颜色时的总最小花费, 右侧 <code>Math.min(b, g)</code> 表示粉刷到上一间房使用蓝色或绿色时的最小花费, <code>costs[i][0]</code> 表示粉刷第 <code>i</code>间房时使用红色的情况, 然后继续赋值给 r, 后续依次类推. 当循环结束时, 最后得到的 <code>r、b、g</code> 即为最后一间房子粉刷某一种情况的总花费, 最后返回最小值即可.</strong></p>\n<hr>\n<h3 id=\"todo持续更新\"><a aria-hidden=\"true\" tabindex=\"-1\" href=\"#todo持续更新\"><span class=\"icon icon-link\"></span></a>.........<em>todo(持续更新)</em></h3>","ogImage":{"url":"/assets/blog/image/cover.jpg"},"coverImage":"/assets/blog/image/cover.jpg","theme":"awesome-green","tag":[null]}},"__N_SSG":true}