{"pageProps":{"post":{"title":"如何实现一个深拷贝?","date":"2021-12-06","slug":"如何实现一个深拷贝","author":"LZS_911","content":"<h2 id=\"赋值浅拷贝\"><a aria-hidden=\"true\" tabindex=\"-1\" href=\"#赋值浅拷贝\"><span class=\"icon icon-link\"></span></a>赋值、浅拷贝</h2>\n<hr>\n<p>首先, 我们来看一个概念性的问题, 赋值、浅拷贝、深拷贝之间有什么区别?</p>\n<ol>\n<li>\n<p>赋值:</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">const</span> obj = { <span class=\"hljs-attr\">bar</span>: <span class=\"hljs-string\">'foo'</span> };\n<span class=\"hljs-keyword\">const</span> obj2 = obj;\nobj2.<span class=\"hljs-property\">bar</span> = <span class=\"hljs-string\">'baz'</span>;\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(obj); <span class=\"hljs-comment\">//{ bar: 'baz' }</span>\n</code></pre>\n<p>当我们复制引用类型的变量时，实际上复制的是栈中存储的地址，所以复制出来的 <code>obj2</code> 实际上和 <code>obj</code> 指向的堆中同一个对象。因此， 我们改变其中任何一个变量的值，另一个变量都会受到影响，这就是为什么会有深拷贝和浅拷贝的原因。</p>\n</li>\n<li>\n<p>浅拷贝:</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">const</span> foo = { <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">'foo'</span> };\n<span class=\"hljs-keyword\">const</span> obj = { <span class=\"hljs-attr\">bar</span>: <span class=\"hljs-string\">'str'</span>, <span class=\"hljs-attr\">baz</span>: foo };\n<span class=\"hljs-keyword\">const</span> obj2 = { ...obj };\nobj2.<span class=\"hljs-property\">bar</span> = <span class=\"hljs-string\">'number'</span>;\nobj2.<span class=\"hljs-property\">baz</span>.<span class=\"hljs-property\">name</span> = <span class=\"hljs-string\">'foo2'</span>;\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(obj); <span class=\"hljs-comment\">//{ bar: 'str', baz: { name: 'foo2' } }</span>\n</code></pre>\n<p>创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。如果属性是基本类型，拷贝的就是基本类型的值，如果属性是引用类型，拷贝的就是内存地址 ，所以如果其中一个对象改变了这个地址，就会影响到另一个对象。</p>\n</li>\n</ol>\n<p>讲个题外话: 值传递和引用传递</p>\n<p>先看两段代码:</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">setName</span>(<span class=\"hljs-params\">name</span>) {\n  name = <span class=\"hljs-string\">'foo'</span>;\n}\n\n<span class=\"hljs-keyword\">const</span> bar = <span class=\"hljs-string\">'bar'</span>;\n\n<span class=\"hljs-title function_\">setName</span>(bar);\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(bar); <span class=\"hljs-comment\">//'bar'</span>\n</code></pre>\n<p>很明显，上面的执行结果是 <code>bar</code>，即函数参数仅仅是被传入变量赋值给了的一个局部变量，改变这个局部变量不会对外部变量产生影响.</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">setName</span>(<span class=\"hljs-params\">obj</span>) {\n  obj.<span class=\"hljs-property\">name</span> = <span class=\"hljs-string\">'foo'</span>;\n}\n\n<span class=\"hljs-keyword\">const</span> obj = { <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">'baz'</span> };\n\n<span class=\"hljs-title function_\">setName</span>(obj);\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(obj); <span class=\"hljs-comment\">//{name: 'foo'; }</span>\n</code></pre>\n<p>上面的代码可能让你产生疑惑，是不是参数是引用类型就是引用传递呢？</p>\n<p>当函数参数是引用类型时，我们同样将参数复制了一个副本到局部变量，只不过复制的这个副本是指向堆内存中的地址而已，我们在函数内部对对象的属性进行操作，实际上和外部变量指向堆内存中的值相同，但是这并不代表着引用传递，下面我们再看一段代码:</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">const</span> obj = {};\n\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">setName</span>(<span class=\"hljs-params\">o</span>) {\n  o.<span class=\"hljs-property\">name</span> = <span class=\"hljs-string\">'bar'</span>;\n  o = { <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">'baz'</span> };\n}\n<span class=\"hljs-title function_\">setName</span>(obj);\n\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(obj);\n</code></pre>\n<p>最后 输出为 <code>{name: 'bar'}</code>, 函数参数传递的并不是变量的引用，而是变量拷贝的副本，当变量是原始类型时，这个副本就是值本身，当变量是引用类型时，这个副本是指向堆内存的地址.</p>\n<h2 id=\"深拷贝\"><a aria-hidden=\"true\" tabindex=\"-1\" href=\"#深拷贝\"><span class=\"icon icon-link\"></span></a>深拷贝</h2>\n<hr>\n<p>回到主题, 来实现我们的深拷贝.</p>\n<ol>\n<li>\n<p>乞丐版:</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">deepClone</span> = (<span class=\"hljs-params\">obj</span>) => <span class=\"hljs-title class_\">JSON</span>.<span class=\"hljs-title function_\">parse</span>(<span class=\"hljs-title class_\">JSON</span>.<span class=\"hljs-title function_\">stringify</span>(obj));\n</code></pre>\n<p>最简易实现方式, 但对于值为 <code>function、undefined、symbol</code> 类型时无法处理</p>\n</li>\n<li>\n<p>合格版</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">deepClone</span> = (<span class=\"hljs-params\">source</span>) => {\n  <span class=\"hljs-keyword\">if</span> (source === <span class=\"hljs-literal\">null</span>) {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">null</span>;\n  }\n  <span class=\"hljs-keyword\">if</span> (source === <span class=\"hljs-literal\">undefined</span>) {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">undefined</span>;\n  }\n\n  <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> source === <span class=\"hljs-string\">'object'</span>) {\n    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-title class_\">Array</span>.<span class=\"hljs-title function_\">isArray</span>(source)) {\n      <span class=\"hljs-keyword\">const</span> clone = [];\n      source.<span class=\"hljs-title function_\">forEach</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">v</span>) =></span> {\n        clone.<span class=\"hljs-title function_\">push</span>(<span class=\"hljs-title function_\">deepClone</span>(v));\n      });\n      <span class=\"hljs-keyword\">return</span> clone;\n    }\n    <span class=\"hljs-keyword\">const</span> clone = {};\n    <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">keys</span>(source).<span class=\"hljs-title function_\">forEach</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">key</span>) =></span> {\n      clone[key] = <span class=\"hljs-title function_\">deepClone</span>(source[key]);\n    });\n    <span class=\"hljs-keyword\">return</span> clone;\n  }\n  <span class=\"hljs-keyword\">return</span> source;\n};\n</code></pre>\n<p>能正确的处理 <code>function、undefined、symbol, array</code> 等类型, 但是当存在循环引用是, 会进入死循环.</p>\n</li>\n<li>\n<p>较完整版</p>\n<pre><code class=\"hljs language-typescript\"><span class=\"hljs-keyword\">const</span> isArray = &#x3C;T>(<span class=\"hljs-attr\">source</span>: <span class=\"hljs-built_in\">unknown</span>): source is <span class=\"hljs-title class_\">Array</span>&#x3C;T> =>\n  <span class=\"hljs-title class_\">Array</span>.<span class=\"hljs-title function_\">isArray</span>(source);\n\n<span class=\"hljs-keyword\">const</span> isMap = (<span class=\"hljs-attr\">source</span>: <span class=\"hljs-built_in\">unknown</span>): source is <span class=\"hljs-title class_\">Map</span> =>\n  <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">toString</span>.<span class=\"hljs-title function_\">call</span>(source) === <span class=\"hljs-string\">'[object Map]'</span>;\n\n<span class=\"hljs-keyword\">const</span> isSet = &#x3C;T>(<span class=\"hljs-attr\">source</span>: <span class=\"hljs-built_in\">unknown</span>): source is <span class=\"hljs-title class_\">Set</span>&#x3C;T> =>\n  <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">toString</span>.<span class=\"hljs-title function_\">call</span>(source) === <span class=\"hljs-string\">'[object Set]'</span>;\n\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">isObject</span> = (<span class=\"hljs-params\"><span class=\"hljs-attr\">source</span>: <span class=\"hljs-built_in\">unknown</span></span>) => {\n  <span class=\"hljs-keyword\">const</span> <span class=\"hljs-keyword\">type</span> = <span class=\"hljs-keyword\">typeof</span> source;\n  <span class=\"hljs-keyword\">return</span> source !== <span class=\"hljs-literal\">null</span> &#x26;&#x26; <span class=\"hljs-keyword\">type</span> === <span class=\"hljs-string\">'object'</span>;\n};\n\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">initData</span> = (<span class=\"hljs-params\"><span class=\"hljs-attr\">source</span>: <span class=\"hljs-built_in\">any</span></span>) => {\n  <span class=\"hljs-keyword\">const</span> { constructor } = source;\n  <span class=\"hljs-keyword\">if</span> (!!constructor) {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\"></span>);\n  }\n  <span class=\"hljs-keyword\">return</span>;\n};\n\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">deepClone</span> = (<span class=\"hljs-params\"><span class=\"hljs-attr\">source</span>: <span class=\"hljs-built_in\">unknown</span>, map = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">WeakMap</span>()</span>) => {\n  <span class=\"hljs-keyword\">if</span> (!<span class=\"hljs-title function_\">isObject</span>(source)) {\n    <span class=\"hljs-keyword\">return</span> source;\n  }\n  <span class=\"hljs-keyword\">const</span> clone = <span class=\"hljs-title function_\">initData</span>(source);\n  <span class=\"hljs-keyword\">if</span> (!clone) {\n    <span class=\"hljs-keyword\">return</span> source;\n  }\n  <span class=\"hljs-keyword\">if</span> (!!map.<span class=\"hljs-title function_\">has</span>(source <span class=\"hljs-keyword\">as</span> <span class=\"hljs-title class_\">Object</span>)) {\n    <span class=\"hljs-keyword\">return</span> map.<span class=\"hljs-title function_\">get</span>(source <span class=\"hljs-keyword\">as</span> <span class=\"hljs-title class_\">Object</span>);\n  }\n  map.<span class=\"hljs-title function_\">set</span>(source <span class=\"hljs-keyword\">as</span> <span class=\"hljs-title class_\">Object</span>, clone);\n\n  <span class=\"hljs-keyword\">if</span> (isArray&#x3C;<span class=\"hljs-built_in\">any</span>>(source)) {\n    source.<span class=\"hljs-title function_\">forEach</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">v</span>) =></span> {\n      (clone <span class=\"hljs-keyword\">as</span> <span class=\"hljs-title class_\">Array</span>&#x3C;<span class=\"hljs-built_in\">any</span>>).<span class=\"hljs-title function_\">push</span>(<span class=\"hljs-title function_\">deepClone</span>(v, map));\n    });\n    <span class=\"hljs-keyword\">return</span> clone;\n  }\n\n  <span class=\"hljs-keyword\">if</span> (isMap&#x3C;<span class=\"hljs-built_in\">any</span>, <span class=\"hljs-built_in\">any</span>>(source)) {\n    source.<span class=\"hljs-title function_\">forEach</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">v, key</span>) =></span> {\n      (clone <span class=\"hljs-keyword\">as</span> <span class=\"hljs-title class_\">Map</span>&#x3C;<span class=\"hljs-built_in\">any</span>, <span class=\"hljs-built_in\">any</span>>).<span class=\"hljs-title function_\">set</span>(key, <span class=\"hljs-title function_\">deepClone</span>(v, map));\n    });\n    <span class=\"hljs-keyword\">return</span> clone;\n  }\n\n  <span class=\"hljs-keyword\">if</span> (isSet&#x3C;<span class=\"hljs-built_in\">any</span>>(source)) {\n    source.<span class=\"hljs-title function_\">forEach</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">v</span>) =></span> {\n      (clone <span class=\"hljs-keyword\">as</span> <span class=\"hljs-title class_\">Set</span>&#x3C;<span class=\"hljs-built_in\">any</span>>).<span class=\"hljs-title function_\">add</span>(<span class=\"hljs-title function_\">deepClone</span>(v, map));\n    });\n    <span class=\"hljs-keyword\">return</span> clone;\n  }\n\n  <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">keys</span>(source <span class=\"hljs-keyword\">as</span> <span class=\"hljs-built_in\">any</span>).<span class=\"hljs-title function_\">forEach</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">v</span>) =></span> {\n    clone[v] = <span class=\"hljs-title function_\">deepClone</span>((source <span class=\"hljs-keyword\">as</span> <span class=\"hljs-built_in\">any</span>)[v], map);\n  });\n  <span class=\"hljs-keyword\">return</span> clone;\n};\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> deepClone;\n</code></pre>\n</li>\n</ol>\n<p>解决循环引用问题，我们可以额外开辟一个存储空间，来存储当前对象和拷贝对象的对应关系，当需要拷贝当前对象时，先去存储空间中找，有没有拷贝过这个对象，如果有的话直接返回，如果没有的话继续拷贝，这样就巧妙化解的循环引用的问题。</p>\n<p>这个存储空间，需要可以存储 <code>key-value</code> 形式的数据，且 <code>key</code> 可以是一个引用类型，我们可以选择 <code>WeakMap</code> 这种数据结构：\n\b</p>\n<ul>\n<li>检查 <code>map</code> 中有无克隆过的对象</li>\n<li>有 - 直接返回</li>\n<li>没有 - 将当前对象作为 <code>key</code>，克隆对象作为 <code>value</code> 进行存储</li>\n<li>继续克隆</li>\n</ul>\n<p>当然, 这里只考虑了 <code>Array</code> 、 <code>Object</code>、 <code>Map</code> 和 <code>Set</code> 四种可继续遍历类型, 还有其他类型, 这里不继续研究了...</p>\n<h2 id=\"map-与-weakmap\"><a aria-hidden=\"true\" tabindex=\"-1\" href=\"#map-与-weakmap\"><span class=\"icon icon-link\"></span></a><a href=\"https://es6.ruanyifeng.com/#docs/set-map#Map\"><code>Map</code> 与 <code>WeakMap</code></a></h2>\n<hr>\n<p><code>Map</code> 是 <code>ES6</code> 中新增数据类型, 主要为了解决传统 <code>Object</code> 只能使用字符串作为键值, 并且不能够很方便的获取键的长度.</p>\n<p><code>WeakMap</code> 与 <code>Map</code> 的区别有两点:</p>\n<ol>\n<li>\n<p><code>WeakMap</code> 只接受对象作为键名（<code>null</code> 除外），不接受其他类型的值作为键名。</p>\n</li>\n<li>\n<p><code>WeakMap</code> 的键名所指向的对象，不计入垃圾回收机制。</p>\n</li>\n</ol>\n<p>利用第 2 点便不用担心当我们要拷贝的对象非常庞大时，使用 Map 会对内存造成非常大的额外消耗，而且我们需要手动清除 Map 的属性才能释放这块内存，而 WeakMap 会帮我们巧妙化解这个问题。</p>\n<p>测试代码地址: <a href=\"https://github.com/LZS911/vue3-ts-vite2-ly-component/tree/master/src/utils/deepClone\">https://github.com/LZS911/vue3-ts-vite2-ly-component/tree/master/src/utils/deepClone</a></p>","ogImage":{"url":"/assets/blog/image/cover.jpg"},"coverImage":"/assets/blog/image/cover.jpg","theme":"vuepress","tag":["javascript"]}},"__N_SSG":true}