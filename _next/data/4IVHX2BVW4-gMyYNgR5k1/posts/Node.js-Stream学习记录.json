{"pageProps":{"post":{"title":"Node.js-Stream学习记录","date":"2024-12-20","slug":"Node.js-Stream学习记录","author":"Ai.Haibara","content":"<h2 id=\"什么是-stream流\"><a aria-hidden=\"true\" tabindex=\"-1\" href=\"#什么是-stream流\"><span class=\"icon icon-link\"></span></a>什么是 Stream（流）</h2>\n<p>先看一下 Node 官网中对于 Stream 的介绍</p>\n<blockquote>\n<p>A stream is an abstract interface for working with streaming data in Node.js.</p>\n</blockquote>\n<p>其实我们写的 Node.js 代码经常会用到流。</p>\n<p>来看一段代码</p>\n<pre><code>// src/test.mjs\nimport http from 'node:http';\nimport fs from 'node:fs';\nimport path from 'node:path';\n\nconst server = http.createServer(async function (req, res) {\n  const data = fs.readFileSync(\n    path.join(import.meta.dirname, '..', 'package.json'),\n    'utf-8'\n  );\n  res.end(data);\n});\n\nserver.listen(8000);\n</code></pre>\n<p>我们跑了个 http 服务。</p>\n<p>用 fs.readFileSync 读取项目中 package.json 的内容返回。</p>\n<p>启动服务后使用 curl 访问下</p>\n<pre><code>curl -i http://localhost:8000\n</code></pre>\n<p><img src=\"https://github.com/user-attachments/assets/775ccae6-26e8-4149-abbe-8244ce84b035\" alt=\"image\"></p>\n<p>因为是全部读完返回的，所以可以知道 Content-Length，也就是响应体的长度。</p>\n<p>当文件比较小的时候，这样读取、返回没啥问题。</p>\n<p>那如果文件非常大呢？</p>\n<p>比如有好几百 M，这时候全部读取完再返回是不是就合适了？</p>\n<p>因为要等好久才能读取完文件，之后才有响应。</p>\n<p>这就需要用到流了：</p>\n<pre><code>//更新 src/test.mjs\nimport http from 'node:http';\nimport fs from 'node:fs';\nimport path from 'node:path';\n\nconst server = http.createServer(async function (req, res) {\n  const readStream = fs.createReadStream(\n    path.join(import.meta.dirname, '..', 'package.json'),\n    'utf-8'\n  );\n  readStream.pipe(res);\n});\n\nserver.listen(8000);\n</code></pre>\n<p><img src=\"https://github.com/user-attachments/assets/7d9096be-3d6b-4640-ac7d-09a3700b32b2\" alt=\"image\"></p>\n<p>结果一样，但是因为现在是流式返回的，并不知道响应体的 Content-Length。</p>\n<p>所以是用 Transfer-Encoding: chunked 的方式返回流式内容。</p>\n<p>从服务器下载一个文件的时候，如何知道文件下载完了呢？</p>\n<p>有两种方式：</p>\n<p>一种是 header 里带上 Content-Length，浏览器下载到这个长度就结束。</p>\n<p><img src=\"https://github.com/user-attachments/assets/05f39e48-2f39-4fdd-9c51-2a1f4736991e\" alt=\"image\"></p>\n<p>另一种是设置 transfer-encoding:chunked，它是不固定长度的，服务器不断返回内容，直到返回一个空的内容代表结束。</p>\n<p>比如这样：</p>\n<pre><code>5\nHello\n1\n,\n5\nWorld\n1\n!\n0\n</code></pre>\n<p>这里分了 “Hello” “,” “World”“!” 这 4 个块，长度分别为 5、1、5、1</p>\n<p>最后以一个长度为 0 的块代表传输结束。</p>\n<p>这样，不管内容多少都可以分块返回，就不用指定 Content-Length 了。</p>\n<p>这就是大文件的流式传输的原理，就是 transfer-encoding:chunked。</p>\n<p>当然，这是 http 传输时的流，在用 shell 命令的时候，也经常会用到流：</p>\n<p>比如</p>\n<pre><code>ls | grep pack\n</code></pre>\n<p><img src=\"https://github.com/user-attachments/assets/e7d69e47-5a8a-4717-b3e7-7251d5924dc6\" alt=\"image\"></p>\n<p>ls 命令的输出流，作为 grep 命令的输入流。</p>\n<p>当然，我们也可以把 grep 命令的输出流，作为 node 脚本的输入流。</p>\n<pre><code>//src/read.mjs\nprocess.stdin.on('readable', function () {\n    const buf = process.stdin.read();\n    console.log(buf?.toString('utf-8'));\n});\n</code></pre>\n<p>process.stdin 就是输入流，监听 readable 事件，用 read 读取数据。</p>\n<p>执行一下</p>\n<pre><code>ls | grep pack | node src/read.mjs\n</code></pre>\n<p><img src=\"https://github.com/user-attachments/assets/e51ce88c-f842-4e5c-8758-4d203085a0ac\" alt=\"image\"></p>\n<p>可以看到，我们的 node 脚本接收到了 grep 的输出流作为输入流。</p>\n<p>这就是管道 pipe 的含义。</p>\n<p>综上，可以小结下我们对流的认识：</p>\n<p><strong>流就是分段的传输内容，比如从服务端像浏览器返回响应数据的流，读取文件的流等。</strong></p>\n<p><strong>流和流之间可以通过管道 pipe 连接，上个流的输出作为下个流的输入。</strong></p>\n<h2 id=\"流的类型\"><a aria-hidden=\"true\" tabindex=\"-1\" href=\"#流的类型\"><span class=\"icon icon-link\"></span></a>流的类型</h2>\n<p>在 node 里，流一共有 4 种：可读流 Readable、可写流 Writable、双工流 Duplex、转换流 Transform。</p>\n<pre><code>import stream from 'node:stream';\n\n// 可读流\nconst Readable = stream.Readable;\n// 可写流\nconst Writable = stream.Writable;\n// 双工流\nconst Duplex = stream.Duplex;\n// 转换流\nconst Transform = stream.Transform;\n</code></pre>\n<p>其余的流都是基于这 4 种流封装出来的。</p>\n<h3 id=\"readable\"><a aria-hidden=\"true\" tabindex=\"-1\" href=\"#readable\"><span class=\"icon icon-link\"></span></a>Readable</h3>\n<p>Readable 要实现 _read 方法，通过 push 返回具体的数据。</p>\n<pre><code>//readable.mjs\nimport { Readable } from 'node:stream';\n\nconst readableStream = new Readable();\n\nreadableStream._read = function() {\n    this.push('阿门阿前一棵葡萄树，');\n    this.push('阿东阿东绿的刚发芽，');\n    this.push('阿东背着那重重的的壳呀，');\n    this.push('一步一步地往上爬。')\n    this.push(null);\n}\n\nreadableStream.on('data', (data)=> {\n    console.log(data.toString())\n});\n\nreadableStream.on('end', () => {\n    console.log('done');\n});\n</code></pre>\n<p>当 push 一个 null 时，就代表结束流。</p>\n<p>执行一下</p>\n<pre><code>node src/readable.mjs\n</code></pre>\n<p><img src=\"https://github.com/user-attachments/assets/184fe685-1a0b-4a88-b846-c4ebe37a705c\" alt=\"image\"></p>\n<p>创建 Readable 流也可以通过继承的方式：</p>\n<pre><code>// src/readable2.mjs\nimport { Readable } from 'node:stream';\n\nclass ReadableDong extends Readable {\n\n    _read() {\n        this.push('阿门阿前一棵葡萄树，');\n        this.push('阿东阿东绿的刚发芽，');\n        this.push('阿东背着那重重的的壳呀，');\n        this.push('一步一步地往上爬。')\n        this.push(null);\n    }\n\n}\n\nconst readableStream = new ReadableDong();\n\nreadableStream.on('data', (data)=> {\n    console.log(data.toString())\n});\n\nreadableStream.on('end', () => {\n    console.log('done');\n});\n\n</code></pre>\n<p><img src=\"https://github.com/user-attachments/assets/267137eb-e992-4c71-9bd3-3325e05a74a7\" alt=\"image\"></p>\n<p>可读流是生成内容的，那么很自然可以和生成器结合：</p>\n<pre><code>// src/readable3.mjs\n\nimport { Readable } from 'node:stream';\n\nclass ReadableDong extends Readable {\n\n    constructor(iterator) {\n        super();\n        this.iterator = iterator;\n    }\n\n    _read() {\n        const next = this.iterator.next();\n        if(next.done) {\n            return this.push(null);\n        } else {\n            this.push(next.value)\n        }\n    }\n\n}\n\nfunction *songGenerator() {\n    yield '阿门阿前一棵葡萄树，';\n    yield '阿东阿东绿的刚发芽，';\n    yield '阿东背着那重重的的壳呀，';\n    yield '一步一步地往上爬。';\n}\n\nconst songIterator = songGenerator();\n\nconst readableStream = new ReadableDong(songIterator);\n\nreadableStream.on('data', (data)=> {\n    console.log(data.toString())\n});\n\nreadableStream.on('end', () => {\n    console.log('done');\n});\n</code></pre>\n<ul>\n<li>和 yield 是 js 的 generator 的语法，它是异步返回 yield 后的内容，通过 iterator 的 next 来取下一个。</li>\n</ul>\n<p><img src=\"https://github.com/user-attachments/assets/c2290823-cc7b-45b7-b2d6-cbcd5febfaaf\" alt=\"image\"></p>\n<p>我们封装个工厂方法：</p>\n<pre><code>function createReadStream(iterator) {\n  return new ReadableDong(iterator);\n}\n\nconst readableStream = createReadStream(songIterator);\n\nreadableStream.on('data', (data) => {\n  console.log(data.toString());\n});\n\nreadableStream.on('end', () => {\n  console.log('done');\n});\n</code></pre>\n<p>是不是就和 fs.createReadStream 很像了？</p>\n<pre><code>// 创建 src/fsReadStream.mjs\nimport fs from 'node:fs';\nimport path from 'node:path';\n\nconst readStream = fs.createReadStream(\n  path.join(import.meta.dirname, '..', 'package.json'),\n  'utf-8'\n);\n\nreadStream.on('data', (data) => {\n  console.log(data.toString());\n});\n\nreadStream.on('end', () => {\n  console.log('done');\n});\n</code></pre>\n<p><img src=\"https://github.com/user-attachments/assets/1e7bb2ed-6be6-479f-a4fe-f3318766f17d\" alt=\"image\"></p>\n<p>其实文件的 ReadStream 就是基于 stream 的 Readable 封装出来的。</p>\n<p>这就是可读流。</p>\n<p>http 服务的 request 就是 Readable 的实例：</p>\n<p><img src=\"https://github.com/user-attachments/assets/bca3ed3c-fd44-4ff4-974e-7e5830ae21b7\" alt=\"image\"></p>\n<p>所以我们可以这样写：</p>\n<pre><code>// src/test2.mjs\nimport http from 'node:http';\nimport fs from 'node:fs';\n\nconst server = http.createServer(async function (req, res) {\n    const writeStream = fs.createWriteStream('aaa.txt', 'utf-8');\n    req.pipe(writeStream);\n    res.end('done');\n});\n\nserver.listen(8000);\n</code></pre>\n<p>启动服务后访问一下</p>\n<pre><code>curl -X POST -d \"a=1&#x26;b=2\" http://localhost:8000\n</code></pre>\n<p><img src=\"https://github.com/user-attachments/assets/df08f683-77d2-4252-84fe-742c42d5c230\" alt=\"image\"></p>\n<p>可以看到，从 request 的流中读出的内容写入了文件的 WriteStream</p>\n<h3 id=\"writable\"><a aria-hidden=\"true\" tabindex=\"-1\" href=\"#writable\"><span class=\"icon icon-link\"></span></a>Writable</h3>","theme":"fancy","tag":[null]}},"__N_SSG":true}