{"pageProps":{"post":{"title":"如何实现一个EventEmit?","date":"2022-09-07","slug":"如何实现一个事件监听器EventEmit","author":"LZS_911","content":"<h2>EventEmit 简介</h2>\n<p><code>node.js</code> 所有的异步 <code>I/O</code> 操作在完成时都会发送一个事件到事件队列. 一个 <code>fs.readStream</code> 对象会在文件被打开的时候触发一个事件. 所有这些产生事件的对象都是 <code>events.EventEmitter</code> 的实例.</p>\n<p><code>EventEmit</code> 是 <code>node.js</code> 内置模块 <code>events</code> 提供的一个 <code>class</code>, 在 <code>node.js</code> 环境中可以直接 <code>require</code> 后使用. 在 <code>web</code> 环境中我们可以使用第三方 <code>npm</code> 包或者原生的 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/EventTarget\">EventTarget</a>. 当然, 也可以自己实现一个类似 <code>node.js</code> 的简易版本.</p>\n<p>我们先来看下 <code>EventEmit</code> 的基本使用方法:</p>\n<pre><code class=\"language-javascript\">const { EventEmitter } = require('node:events');\n\nconst event = new EventEmitter();\n\nconst fn = () => {\n  console.log('event 事件触发!');\n};\n\n//为指定事件注册一个监听器\nevent.addListener('event', fn);\n\n//触发监听器\nevent.emit('event');\n\n//移除监听器\nevent.removeListener('event', fn);\n</code></pre>\n<p>其中, 当我们添加新的监听器时, <code>newListener</code> 事件会触发, <code>当监听器被移除时，removeListener</code> 事件被触发.</p>\n<h3>实现的 Api 介绍</h3>\n<ol>\n<li>\n<p><code>emitter.addListener(eventName, listener)</code> 为指定事件注册一个监听器，接受一个 <code>string</code> (或 <code>symbol</code>) 类型的 <code>eventName</code> 和一个回调函数. 返回值为 <code>EventEmit</code> 的实例, 以便链式调用.</p>\n<ul>\n<li><code>eventName</code> <code>&#x3C;string></code> | <code>&#x3C;symbol></code></li>\n<li><code>listener</code> <code>&#x3C;Function></code></li>\n<li><code>Returns</code> <code>&#x3C;EventEmit></code></li>\n</ul>\n</li>\n<li>\n<p><code>emitter.emit(eventName, [...args])</code> 同步调用为名为 <code>eventName</code> 的事件注册的每个监听器, 按照它们注册的顺序, 将提供的参数传递给每个侦听器, 如果存在该监听器, 则返回 <code>True</code>, 否则返回 <code>False</code></p>\n<ul>\n<li><code>eventName</code> <code>&#x3C;string></code> | <code>&#x3C;symbol></code></li>\n<li><code>...args</code> <code>&#x3C;any></code></li>\n<li><code>Returns</code> <code>&#x3C;boolean></code></li>\n</ul>\n</li>\n<li>\n<p><code>emitter.once(eventName, listener)</code> 和 <code>addListener</code> 类似, 但只触发一次, 随后便解除事件监听.</p>\n</li>\n<li>\n<p><code>emitter.removeListener(eventName, listener)</code> 移除指定事件的某个监听回调.</p>\n<ul>\n<li><code>eventName</code> <code>&#x3C;string></code> | <code>&#x3C;symbol></code></li>\n<li><code>listener</code> <code>&#x3C;Function></code></li>\n<li><code>Returns</code> <code>&#x3C;EventEmit></code></li>\n</ul>\n</li>\n<li>\n<p><code>emitter.removeAllListeners([eventName])</code> 删除所有监听器, 或删除指定 <code>eventName</code> 的监听器.</p>\n<ul>\n<li><code>eventName</code> <code>&#x3C;string></code> | <code>&#x3C;symbol></code></li>\n<li><code>Returns</code> <code>&#x3C;EventEmitter></code></li>\n</ul>\n</li>\n<li>\n<p><code>emitter.setMaxListeners(n)</code> 用于修改监听器的默认限制的数量. (默认大于 10 个监听回调时会产生警告)</p>\n<ul>\n<li><code>n</code> <code>&#x3C;integer></code></li>\n<li><code>Returns</code> <code>&#x3C;EventEmitter></code></li>\n</ul>\n</li>\n<li>\n<p><code>emitter.getMaxListeners()</code> 获取限制监听器的数量</p>\n</li>\n<li>\n<p><code>emitter.listeners(eventName)</code> 返回名为 <code>eventName</code> 的事件的监听器数组的副本.</p>\n<ul>\n<li><code>eventName</code> <code>&#x3C;string></code> | <code>&#x3C;symbol></code></li>\n<li><code>Returns</code> <code>&#x3C;Function></code></li>\n</ul>\n</li>\n<li>\n<p><code>emitter.listenerCount(eventName)</code> 返回监听名为 <code>eventName</code> 的事件的监听器数量</p>\n</li>\n<li>\n<p><code>emitter.on</code> <code>emitter.addListener</code>的别名函数</p>\n</li>\n<li>\n<p><code>emitter.off</code> <code>emitter.removeListener</code>的别名函数</p>\n</li>\n</ol>\n<h3>构造函数</h3>\n<pre><code class=\"language-javascript\">  #maxListeners = 10;\n  constructor() {\n    this.listeners = Object.create(null);\n    this.#maxListeners = 10;\n  }\n</code></pre>\n<p>其中 <code>listeners</code> 的结构如下:</p>\n<pre><code class=\"language-JSON\">{\n  \"event1\": [f1,f2,f3]，\n  \"event2\": [f4,f5]，\n  ...\n}\n</code></pre>\n<h3>addListener 方法</h3>\n<ol>\n<li>\n<p>判断该事件监听器数组是否初始化，若未初始化，则将 <code>listeners[event]</code> 初始化为数组，并加入监听器 <code>cb</code>, 并触发 <code>newListener</code> 事件.</p>\n</li>\n<li>\n<p>判断该事件的监听器数量是否已超限，超限则报警告.</p>\n</li>\n<li>\n<p>判断数组中是否已存在 <code>cb</code>, 不存在则添加，已存在则不做操作.</p>\n</li>\n<li>\n<p>指定 <code>on</code> 等于 <code>addListener</code> 方法</p>\n</li>\n</ol>\n<pre><code class=\"language-javascript\">  addListener(eventName, cb) {\n    if (\n      !this.listeners[eventName || !Array.isArray(this.listeners[eventName])]\n    ) {\n      this.listeners[eventName] = [cb];\n      if (eventName !== \"newListener\") {\n        this.emit(\"newListener\");\n      }\n      return this;\n    }\n    if (this.listeners[eventName].length >= this.#maxListeners) {\n      console.error(\n        \"MaxListenersExceededWarning: Possible EventEmitter memory leak detected. %d event6 listeners added to [EventEmitter]. Use emitter.setMaxListeners() to increase limit\",\n        this.#maxListeners\n      );\n    }\n\n    this.listeners[eventName].push(cb);\n    return this;\n  }\n\n</code></pre>\n<h3>emit 方法</h3>\n<p>遍历监听器,通过 <code>apply</code> 方法把上面得到的 <code>args</code> 参数传进去, 需要注意的是不要漏了返回值.</p>\n<pre><code class=\"language-javascript\">  emit(eventName, ...args) {\n    const isExistEvent =\n      this.listeners[eventName] &#x26;&#x26; this.listeners[eventName].length > 0;\n\n    if (isExistEvent) {\n      this.listeners[eventName].forEach((cb) => {\n        cb.apply(null, args);\n      });\n    }\n    return isExistEvent;\n  }\n</code></pre>\n<h3>removeListener 方法</h3>\n<pre><code class=\"language-javascript\">  removeListener(eventName, listener) {\n    const index = (this.listeners[eventName] || []).indexOf(listener);\n    if (index !== -1) {\n      this.listeners[eventName].splice(index, 1);\n      if (eventName !== \"removeListener\") {\n        this.emit(\"removeListener\");\n      }\n    }\n    return this;\n  }\n</code></pre>\n<h3>once 方法</h3>\n<p><code>once</code> 方法是 <code>on</code> 方法和 <code>removeListener</code> 方法的结合：用 <code>on</code> 方法监听，在回调结束的最后位置，通过<code>removeListener</code> 删掉监听函数自身</p>\n<pre><code class=\"language-javascript\">  once(eventName, listener) {\n    const fn = (...args) => {\n      listener.apply(null, args);\n      this.removeListener(eventName, fn);\n    };\n    this.on(eventName, fn);\n    return this;\n  }\n</code></pre>\n<h3>removeAllListeners 方法</h3>\n<pre><code class=\"language-javascript\">  removeAllListeners(eventNames = []) {\n    if (eventNames.length === 0) {\n      this.listeners = Object.create(null);\n    } else {\n      eventNames.forEach((v) => {\n        this.listeners[v] = null;\n      });\n    }\n    return this;\n  }\n</code></pre>\n<h3>setMaxListeners、getMaxListeners、listenerCount、on、off 方法</h3>\n<pre><code class=\"language-javascript\">  setMaxListeners(maxListeners) {\n    this.#maxListeners = maxListeners;\n  }\n  getMaxListeners() {\n    return this.#maxListeners;\n  }\n  listenerCount(eventName) {\n    return this.listeners[eventName]?.length ?? 0;\n  }\n\n  EventEmitter.prototype.on = EventEmitter.prototype.addListener;\n  EventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n</code></pre>\n<h4>完整代码地址: <a href=\"https://github.com/LZS911/EventEmit\">https://github.com/LZS911/EventEmit</a></h4>","ogImage":{"url":"/assets/blog/image/cover.jpg"},"coverImage":"/assets/blog/image/cover.jpg","theme":"geek-black","tag":["node","javascript","EventEmit"]}},"__N_SSG":true}