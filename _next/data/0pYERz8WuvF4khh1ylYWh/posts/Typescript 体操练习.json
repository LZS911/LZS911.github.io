{"pageProps":{"post":{"title":"Typescript 体操练习","date":"2022-09-26","slug":"Typescript 体操练习","author":"LZS_911","content":"<h2>1. 将下划线模式的 string 类型转化成驼峰类型</h2>\n<pre><code class=\"language-Typescript\">type TransformToCamelCase&#x3C;T extends string> =\n  T extends `${infer Left}_${infer Rest}`\n    ? `${Left}${TransformToCamelCase&#x3C;Capitalize&#x3C;Rest>>}`\n    : T;\n\ntype res1 = TransformToCamelCase&#x3C;'aa_bb_cc_dd'>; //type res1 = \"aaBbCcDd\"\n\n</code></pre>\n<p>注意点:</p>\n<p>需要递归继续处理剩余的部分.</p>\n<h3>应用: 当服务端定义的实体中的 <code>key</code> 的模式为下环线, 但前端代码中需要使用驼峰模式时</h3>\n<p>实现:</p>\n<pre><code class=\"language-Typescript\">type CamelCase&#x3C;T extends Record&#x3C;string, any>> = T extends any\n  ? {\n      [key in keyof T as TransformToCamelCase&#x3C;\n        key &#x26; string\n      >]: T[key] extends Array&#x3C;infer Element>\n        ? Array&#x3C;\n            Element extends string\n              ? TransformToCamelCase&#x3C;Element>\n              : CamelCase&#x3C;Element>\n          >\n        : T[key] extends Record&#x3C;string, any>\n        ? CamelCase&#x3C;T[key]>\n        : T[key];\n    }\n  : never;\n</code></pre>\n<p>注意点:</p>\n<ol>\n<li>当某项 <code>key</code> 的类型仍然满足 <code>Record&#x3C;string, any></code> 时, 需要递归继续.</li>\n<li>因为 <code>Typescript</code> 不会去计算递归中的表达式, 所以需要加上一个一定为 <code>true</code> 的判断, 让他去执行, 也就是 <code>T extends any</code>.</li>\n<li>需要注意 <code>Array</code> 的情况.</li>\n</ol>\n<h2>2. 将索引类型转化为联合类型</h2>\n<ul>\n<li>索引类型是一个聚合了多个元素的类型，对象、类、元组等都是索引类型, 举个栗子:</li>\n</ul>\n<pre><code class=\"language-Typescript\">type ExampleType = {\n  name: string;\n  sex: boolean;\n  age: number;\n  hobbies: string[];\n}\n</code></pre>\n<ul>\n<li>联合类型. 顾名思义, 它是一个联合了多种类型的集合, 取值可以取其中任意一种类型.</li>\n</ul>\n<pre><code class=\"language-Typescript\">type UnionTypes = { name: string } | { sex: boolean } | { age: number} | { hobbies: string[] };\n</code></pre>\n<ul>\n<li>\n<p>需求: 实现一个工具类, 将 <code>ExampleType</code> 转化为 <code>UnionTypes</code></p>\n</li>\n<li>\n<p>实现:</p>\n<pre><code class=\"language-Typescript\">type SpiltObj&#x3C;T> = {\n  [key in keyof T]: {\n    [key2 in key]:T[key2]\n  }\n}[keyof T]\n</code></pre>\n</li>\n<li>\n<p>拆分, 先看第一部分</p>\n<pre><code class=\"language-Typescript\">type SpiltObj&#x3C;T> = {\n  [key in keyof T]: {\n    [key2 in key]:T[key2]\n  }\n}\n</code></pre>\n<pre><code class=\"language-Typescript\">  type Res = SpiltObj&#x3C;ExampleType>\n\n  /** type Res = {\n   name: string;\n   } | {\n       sex: boolean;\n   } | {\n       age: number;\n   } | {\n       hobbies: string[];\n   } **/\n</code></pre>\n<p>第二部分</p>\n<pre><code class=\"language-Typescript\">  type ExampleType = {\n    name: string;\n    sex: boolean;\n    age: number;\n    hobbies: string[];\n  }\n\n  type res = ExampleType[keyof ExampleType]\n\n  //type res = string | number | boolean | string[]\n</code></pre>\n</li>\n<li>\n<p>拓展, 实现一个工具类, 拿到索性类型键值路径的联合类型</p>\n<pre><code class=\"language-Typescript\">type Template = {\n  aa: {\n    bb: string;\n  };\n  cc: number;\n  dd: {\n    ee: {\n      ff: string;\n    }\n  };\n  gg: {\n    hh: number\n  };\n}\n\ntype demo = 'aa' | 'cc' | 'dd' | 'gg' | 'aa.bb' |'dd.ee' | 'dd.ee.ff' | 'gg.hh'\n\ntype TemplateKeyPath&#x3C;T> ={\n   [key in keyof T]: key extends string ? T[key] extends Record&#x3C;string, any> ? key | `${key}.${TemplateKeyPath&#x3C;T[key]>}` : key : never;\n}[keyof T]\n\ntype res2 = TemplateKeyPath&#x3C;Template>\n//type res2 = \"aa\" | \"cc\" | \"dd\" | \"gg\" | \"aa.bb\" | \"dd.ee\" | \"dd.ee.ff\" | \"gg.hh\"\n</code></pre>\n</li>\n</ul>","ogImage":{"url":"/assets/blog/image/cover.jpg"},"coverImage":"/assets/blog/image/cover.jpg","theme":"fancy","tag":["Typescript"]}},"__N_SSG":true}