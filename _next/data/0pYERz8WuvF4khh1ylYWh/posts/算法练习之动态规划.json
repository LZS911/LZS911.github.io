{"pageProps":{"post":{"title":"算法练习之动态规划","date":"2021-11-12","slug":"算法练习之动态规划","author":"LZS_911","content":"<h3>粉刷房间</h3>\n<hr>\n<h4>题目描述</h4>\n<pre><code>假如有一排房子，共 n 个，每个房子可以被粉刷成红色、蓝色或者绿色这三种颜色中的一种，你需要粉刷所有的房子并且使其相邻的两个房子颜色不能相同。\n\n当然，因为市场上不同颜色油漆的价格不同，所以房子粉刷成不同颜色的花费成本也是不同的。每个房子粉刷成不同颜色的花费是以一个 n x 3 的正整数矩阵 costs 来表示的。\n\n例如，costs[0][0] 表示第 0 号房子粉刷成红色的成本花费；costs[1][2] 表示第 1 号房子粉刷成绿色的花费，以此类推。\n\n请计算出粉刷完所有房子最少的花费成本。\n</code></pre>\n<h4>解题思路</h4>\n<ol>\n<li>递归暴力法</li>\n</ol>\n<pre><code class=\"language-typescript\">function minCost(costs: number[][]) {\n  const len = costs.length;\n\n  if (len === 1) {\n    return Math.min(...costs[0]);\n  }\n\n  const fn = (prevIndex: number, count: number, res: number): number => {\n    if (count === len) {\n      return res;\n    }\n    const map = new Map&#x3C;number, number[]>([\n      [0, [1, 2]],\n      [1, [0, 2]],\n      [2, [0, 1]],\n    ]);\n    const arr = map.get(prevIndex)!;\n    return Math.min(...arr.map((v) => fn(v, count + 1, res + costs[count][v])));\n  };\n\n  const r = fn(0, 1, costs[0][0]);\n  const g = fn(1, 1, costs[0][1]);\n  const b = fn(2, 1, costs[0][2]);\n  return Math.min(r, g, b);\n}\n</code></pre>\n<p>不需要思考任何算法的一种方式, 直接递归计算出所有可能, 但是中间会包含很多重复计算, 执行 <code>LeetCode</code> 测试时会超时. 所以需要进一步思考最优解.</p>\n<ol start=\"2\">\n<li>动态规划</li>\n</ol>\n<pre><code class=\"language-typescript\">function minCost(costs: number[][]) {\n  let [r, b, g] = costs[0];\n  for (let i = 1; i &#x3C; costs.length; ++i) {\n    [r, b, g] = [\n      Math.min(b, g) + costs[i][0],\n      Math.min(r, g) + costs[i][1],\n      Math.min(r, b) + costs[i][2],\n    ];\n  }\n  return Math.min(r, g, b);\n}\n</code></pre>\n<p>大致思路:</p>\n<ol>\n<li>定义变量 r、b、g 分别表示粉刷至某一间房时红色、蓝色、绿色所需粉刷的最小花费</li>\n</ol>\n<ul>\n<li>let [r, b, g] = costs[0] 即表示粉刷第一间时的最小花费</li>\n</ul>\n<ol start=\"2\">\n<li>从第二间房开始遍历, 第二间房可粉刷三种任意颜色, 但限制条件为粉刷红色时, 前一间房子的粉刷只能为绿色或蓝色, 依次类推, 得到</li>\n</ol>\n<pre><code class=\"language-typescript\">[r, b, g] = [\n  Math.min(b, g) + costs[i][0],\n  Math.min(r, g) + costs[i][1],\n  Math.min(r, b) + costs[i][2],\n];\n</code></pre>\n<p><strong>这里使用了 ES6 的数组解构, 类似于对象解构, 赋值语句左侧为粉刷到第 <code>i</code> 间房对应某一种颜色时的总最小花费, 右侧 <code>Math.min(b, g)</code> 表示粉刷到上一间房使用蓝色或绿色时的最小花费, <code>costs[i][0]</code> 表示粉刷第 <code>i</code>间房时使用红色的情况, 然后继续赋值给 r, 后续依次类推. 当循环结束时, 最后得到的 <code>r、b、g</code> 即为最后一间房子粉刷某一种情况的总花费, 最后返回最小值即可.</strong></p>\n<hr>\n<h3>.........<em>todo(持续更新)</em></h3>","ogImage":{"url":"/assets/blog/image/cover.jpg"},"coverImage":"/assets/blog/image/cover.jpg","theme":"awesome-green","tag":[null]}},"__N_SSG":true}