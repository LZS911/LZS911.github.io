{"pageProps":{"post":{"title":"Docker化一个React+Nest的Monorepo应用","date":"2023-04-25","slug":"Docker化一个React+Nest的Monorepo应用","author":"Ai.Haibara","content":"<h2 id=\"目标\"><a aria-hidden=\"true\" tabindex=\"-1\" href=\"#目标\"><span class=\"icon icon-link\"></span></a>目标</h2>\n<p>使用 <code>Docker</code> 和 <code>Docker Compose</code> 将一个使用 <a href=\"https://react.dev/\">React</a> + <a href=\"https://nestjs.com/\">NestJS</a> + <a href=\"https://www.postgresql.org/\">PostgreSQL</a> + <a href=\"https://www.prisma.io/\">prisma</a> 构建的 Web 应用程序 <strong>Dockerize</strong>。</p>\n<h2 id=\"前置准备\"><a aria-hidden=\"true\" tabindex=\"-1\" href=\"#前置准备\"><span class=\"icon icon-link\"></span></a>前置准备</h2>\n<ul>\n<li>安装 <a href=\"https://nodejs.org/en\">Node.js</a>, 且保证 Node.js 版本为 v14.17.0 或者更高版本.</li>\n<li>安装 <a href=\"https://docs.nestjs.com/cli/overview\">Nest.js CLI</a></li>\n<li>安装 <a href=\"https://pnpm.io/\">Pnpm</a></li>\n<li>安装 <a href=\"https://docs.docker.com/engine/install/\">Docker Engine</a></li>\n<li>安装 <a href=\"https://docs.docker.com/compose/install/\">Docker Compose</a></li>\n<li>安装 <a href=\"https://opensource.com/article/18/8/what-how-makefile\">Make</a></li>\n</ul>\n<h2 id=\"项目结构\"><a aria-hidden=\"true\" tabindex=\"-1\" href=\"#项目结构\"><span class=\"icon icon-link\"></span></a>项目结构</h2>\n<h3 id=\"使用-pnpm-的-workspace-功能构建一个-monorepo\"><a aria-hidden=\"true\" tabindex=\"-1\" href=\"#使用-pnpm-的-workspace-功能构建一个-monorepo\"><span class=\"icon icon-link\"></span></a>使用 Pnpm 的 <a href=\"https://pnpm.io/workspaces\">Workspace</a> 功能构建一个 Monorepo</h3>\n<p>对于一个 <code>Monorepo</code>, 我们需要创建在项目根路径创建一个 <code>packages</code> 文件夹. <code>packages</code> 里面包含了由 <a href=\"https://www.npmjs.com/package/create-vite\">create-vite</a> 创建的 <code>React</code> 项目以及由 <code>Nest.js CLI</code> 创建的后端服务. 当然, 在项目根路径也需要创建一些全局的配置文件.</p>\n<p>具体操作步骤如下:</p>\n<ul>\n<li>\n<p>在根目录初始化一个新的 git 仓库并创建以下文件:</p>\n<pre><code class=\"language-sh\">.dockerignore\n.gitignore\n.env\n.docker-compose.yaml\nMakefile\n</code></pre>\n</li>\n<li>\n<p>创建 packages 文件用于存放前后端项目:</p>\n<pre><code class=\"language-sh\">mkdir packages &#x26;&#x26; cd packages\n</code></pre>\n</li>\n<li>\n<p>创建前端项目, 并添加 Dockerfile.local 以及 Dockerfile.production 文件</p>\n<pre><code class=\"language-sh\">pnpm create vite\n</code></pre>\n</li>\n<li>\n<p>创建后端项目, 并且在执行完后手动删除 node_modules, 同时也添加 Dockerfile.local 以及 Dockerfile.production 文件</p>\n<pre><code class=\"language-sh\">nest new backend\n</code></pre>\n</li>\n<li>\n<p>重新配置 tsconfig.json:</p>\n<p>首先在项目根目录执行: <code>tsc --init</code>, 初始化一份 <code>tsconfig.json</code>, 并且将文件内容修改至以下内容:</p>\n<pre><code class=\"language-json\">  {\n   \"compilerOptions\": {\n     \"module\": \"commonjs\",\n     \"declaration\": true,\n     \"removeComments\": true,\n     \"emitDecoratorMetadata\": true,\n     \"experimentalDecorators\": true,\n     \"allowSyntheticDefaultImports\": true,\n     \"target\": \"es2017\",\n     \"sourceMap\": true,\n     \"outDir\": \"./dist\",\n     \"baseUrl\": \"./\",\n     \"incremental\": true,\n     \"skipLibCheck\": true,\n     \"strictNullChecks\": false,\n     \"noImplicitAny\": false,\n     \"strictBindCallApply\": false,\n     \"forceConsistentCasingInFileNames\": true,\n     \"noFallthroughCasesInSwitch\": false,\n     \"strict\": true,\n     \"jsx\": \"react-jsx\"\n   },\n   \"include\": [\"packages/*/src\"]\n  }\n</code></pre>\n<p>最后将前后端项目中由工具创建的 <code>tsconfig.json</code> 文件内容修改至以下内容:</p>\n<pre><code class=\"language-json\">  {\n   \"extends\": \"../../tsconfig.json\",\n   \"include\": [\"./src\"]\n  }\n</code></pre>\n</li>\n<li>\n<p>创建 pnpm-workspace.yml, 填充以下内容:</p>\n<pre><code class=\"language-yml\">  packages:\n - 'packages/**'\n</code></pre>\n</li>\n<li>\n<p>在根目录创建 package.json 文件, 并且将前后端相同的依赖项提取至其中. 执行 <code>pnpm install -r</code> , 完成依赖的安装.</p>\n</li>\n</ul>\n<p>最后, 得到的项目结构应如下图所示</p>\n<p><img src=\"/assets/docker-react-nest/example1.png\" alt=\"alt\"></p>\n<h2 id=\"dockerize\"><a aria-hidden=\"true\" tabindex=\"-1\" href=\"#dockerize\"><span class=\"icon icon-link\"></span></a>Dockerize</h2>\n<h3 id=\"backend-dockerfile\"><a aria-hidden=\"true\" tabindex=\"-1\" href=\"#backend-dockerfile\"><span class=\"icon icon-link\"></span></a>Backend Dockerfile</h3>\n<p>回到本文主题, 现在, 我们的 Backend 文件夹中包含了两个 Dockerfile 文件. 其中一个用于在本地运行项目, 它用于docker-compose.yaml 文件, 而另一个用于生产环境.</p>\n<p>现在将以下内容填充至 Dockerfile.local:</p>\n<pre><code class=\"language-dockerfile\">#获取node镜像源\nFROM node:16.16.0-alpine\n\n#设置工作目录\nWORKDIR /projects\n\n# 将 pnpm-lock.yaml 拷贝至工作目录, 为后续的 pnpm fetch 做准备\nCOPY ./pnpm-lock.yaml ./\n\n# 安装 pnpm, 并且固定版本, 也可以考虑在获取node镜像源时直接获取带有pnpm的镜像, 这样就能省略这一步了\nRUN npm install -g pnpm@8.3.1\n\n# pnpm fetch 通过提供仅使用锁定文件中的信息将包加载到虚拟存储中的能力，完美地解决了上述问题. 具体见: https://pnpm.io/cli/fetch\nRUN pnpm fetch\n\nCOPY . .\n\n# 安装依赖, 关于 --offline 见: https://pnpm.io/cli/fetch\nRUN pnpm install -r --offline\n\n# https://zhuanlan.zhihu.com/p/89335014\nVOLUME [\"/projects/node_modules/\", \"/projects/packages/backend/node_modules/\", \"/projects/.pnpm-store/\"]\n\n# https://yeasy.gitbook.io/docker_practice/image/dockerfile/expose\nEXPOSE $BACKEND_PORT\n\n# 启动后端服务\nCMD rm -rf dist &#x26;&#x26; cd packages/backend &#x26;&#x26; pnpm start:debug\n</code></pre>\n<h3 id=\"frontend-dockerfile\"><a aria-hidden=\"true\" tabindex=\"-1\" href=\"#frontend-dockerfile\"><span class=\"icon icon-link\"></span></a>Frontend Dockerfile</h3>\n<p>前端文件夹下的 Dockerfile:</p>\n<pre><code class=\"language-dockerfile\">#获取node镜像源\nFROM node:16.16.0-alpine\n\n#设置工作目录\nWORKDIR /app\n\n# 将 pnpm-lock.yaml 拷贝至工作目录, 为后续的 pnpm fetch 做准备\nCOPY ./pnpm-lock.yaml ./\n\n# 安装 pnpm, 并且固定版本, 也可以考虑在获取node镜像源时直接获取带有pnpm的镜像, 这样就能省略这一步了\nRUN npm install -g pnpm@8.3.1\n\n# pnpm fetch 通过提供仅使用锁定文件中的信息将包加载到虚拟存储中的能力，完美地解决了上述问题. 具体见: https://pnpm.io/cli/fetch\nRUN pnpm fetch\n\nCOPY . .\n\n# 安装依赖, 关于 --offline 见: https://pnpm.io/cli/fetch\nRUN pnpm install -r --offline\n\n# https://zhuanlan.zhihu.com/p/89335014\nVOLUME [\"/app/node_modules/\", \"/app/packages/frontend/node_modules/\", \"/app/.pnpm-store/\"]\n\n# 启动前端服务\nCMD cd packages/frontend &#x26;&#x26; pnpm start\n\n</code></pre>\n<h3 id=\"创建-docker-compose-文件并运行项目\"><a aria-hidden=\"true\" tabindex=\"-1\" href=\"#创建-docker-compose-文件并运行项目\"><span class=\"icon icon-link\"></span></a>创建 Docker Compose 文件并运行项目</h3>\n<ol>\n<li>\n<p>配置环境变量: 将以下内容填充至 <code>&#x3C;rootDir>/.env</code></p>\n<pre><code class=\"language-sh\">   NODE_ENV=development\n   FRONTEND_PORT=7879\n   BACKEND_PORT=7878\n   JWT_SECRET=jwt_secret_key_here\n   JWT_EXPIRES_IN=30d\n   DB_HOST=bp-pg-db\n   DB_NAME=bp-pg-db\n   DB_USER=postgres\n   DB_PASSWORD=root\n   DB_PORT=5432\n   PGADMIN_DEFAULT_EMAIL=admin@backend.com\n   PGADMIN_DEFAULT_PASSWORD=pass@123\n   PGADMIN_PORT=5055\n</code></pre>\n</li>\n<li>\n<p>将以下内容填充至 <code>&#x3C;rootDIr>/docker-compose.yml</code></p>\n<pre><code class=\"language-yml\">    version: '3.9'\n    services:\n      frontend:\n        container_name: frontend\n        build:\n          context: ./\n          dockerfile: ./packages/frontend/Dockerfile.local\n        restart: always\n        env_file: .env\n        ports:\n          - '${FRONTEND_PORT}:${FRONTEND_PORT}'\n        volumes:\n          - .:/app\n        networks:\n          bp-network:\n            ipv4_address: 172.25.0.3\n      backend:\n        container_name: backend\n        build:\n          context: ./\n          dockerfile: ./packages/backend/Dockerfile.local\n        restart: always\n        env_file: .env\n        volumes:\n          - .:/app\n        networks:\n          bp-network:\n            ipv4_address: 172.25.0.2\n        ports:\n          - '${BACKEND_PORT}:${BACKEND_PORT}'\n        depends_on:\n          - bp-pg-db\n        links:\n          - bp-pg-db\n      bp-pg-db:\n        image: postgres:12-alpine\n        restart: always\n        container_name: bp-pg-db\n        env_file:\n          - .env\n        environment:\n          POSTGRES_PASSWORD: ${DB_PASSWORD}\n          PGDATA: /var/lib/postgresql/data\n          POSTGRES_USER: ${DB_USER}\n          POSTGRES_DB: ${DB_NAME}\n        ports:\n          - '${DB_PORT}:${DB_PORT}'\n        volumes:\n          - pgdata:/var/lib/postgresql/data\n        networks:\n          bp-network:\n            ipv4_address: 172.25.0.5\n      pgadmin-portal:\n        image: dpage/pgadmin4\n        restart: always\n        container_name: pgadmin-portal\n        env_file:\n          - .env\n        environment:\n          PGADMIN_DEFAULT_PASSWORD: '${PGADMIN_DEFAULT_PASSWORD}'\n          PGADMIN_DEFAULT_EMAIL: '${PGADMIN_DEFAULT_EMAIL}'\n        volumes:\n          - pgadmin:/root/.pgadmin\n        ports:\n          - '${PGADMIN_PORT}:80'\n        depends_on:\n          - bp-pg-db\n        networks:\n          bp-network:\n            ipv4_address: 172.25.0.6\n    volumes:\n      pgdata:\n      pgadmin:\n    networks:\n      bp-network:\n        driver: bridge\n        ipam:\n          config:\n            - subnet: 172.25.0.0/16\n    \n</code></pre>\n<ol>\n<li><code>Services</code>: 每个服务代表一个将要创建的 Docker 容器</li>\n</ol>\n<ul>\n<li>frontend: 基于前端项目的 Dockerfile.local 构建镜像以及容器. 此容器将会控制前端服务的启停.</li>\n<li>backend: 基于后端项目的 Dockerfile.local 构建镜像以及容器. 此容器将会控制后端服务的启停.</li>\n<li>bp-pg-db: 基于镜像 postgres:12-alpine 构建的 postgres 数据库容器.</li>\n<li>pgadmin-portal: 基于镜像 dpage/pgadmin4 构建的 postgres 可视化界面操作服务.</li>\n</ul>\n</li>\n<li>\n<p>添加 Makefile 用来启动:</p>\n<pre><code class=\"language-Makefile\">local: \n   docker-compose stop &#x26;&#x26; docker-compose up --build -d --remove-orphans\n</code></pre>\n</li>\n</ol>\n<p>使用 <code>make local</code> 命令后, 将构建镜像并启动容器服务, 此时便能通过配置中暴露出的端口号来正常的访问到前端、后端以及数据库服务. 同时, 得益于 <code>VOlUME</code>, 我们在本地修改代码后能及时的映射到容器的挂卷中, 通过项目的热更新来开发项目.</p>\n<h2 id=\"生产环境部署\"><a aria-hidden=\"true\" tabindex=\"-1\" href=\"#生产环境部署\"><span class=\"icon icon-link\"></span></a>生产环境部署</h2>\n<p>todo...</p>","theme":"orange","tag":["Docker","Docker Compose","React","Nest","Monorepo","Pnpm","Nginx","Jenkins","PostgreSQL"]}},"__N_SSG":true}