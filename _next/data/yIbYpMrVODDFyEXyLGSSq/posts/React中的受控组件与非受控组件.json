{"pageProps":{"post":{"title":"React中的受控组件与非受控组件","date":"2022-09-14","slug":"React中的受控组件与非受控组件","author":"LZS_911","content":"<h2 id=\"什么是受控组件和非受控组件\"><a aria-hidden=\"true\" tabindex=\"-1\" href=\"#什么是受控组件和非受控组件\"><span class=\"icon icon-link\"></span></a>什么是受控组件和非受控组件?</h2>\n<ol>\n<li>\n<p>非受控组件</p>\n<pre><code class=\"hljs language-jsx\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">Input</span>: <span class=\"hljs-variable constant_\">FC</span> = <span class=\"hljs-function\">() =></span> {\n  <span class=\"hljs-keyword\">const</span> [value, setValue] = <span class=\"hljs-title function_\">useState</span>(<span class=\"hljs-string\">''</span>);\n\n  <span class=\"hljs-keyword\">return</span> <span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">{value}</span> <span class=\"hljs-attr\">onChange</span>=<span class=\"hljs-string\">{(e)</span> =></span> setValue(e.target.value)} /></span>;\n};\n</code></pre>\n<p>首先我们看一段代码, 代码定义了一个自定义 <code>Input</code> 组件, 并且不接收任何 <code>props</code>. 所以该组件的 <code>value</code> 只能通过用户的操作来更改, 而不能通过代码去控制, 所以叫做 <strong>非受控组件</strong>.</p>\n</li>\n<li>\n<p>受控组件</p>\n<blockquote>\n<p>在 HTML 中, 表单元素 (如&#x3C;input>、 &#x3C;textarea> 和 &#x3C;select>)通常自己维护 state, 并根据用户输入进行更新.而在 React 中, 可变状态 (mutable state)通常保存在组件的 state 属性中, 并且只能通过使用 setState()来更新.\n我们可以把两者结合起来, 使 React 的 state 成为“唯一数据源”.渲染表单的 React 组件还控制着用户输入过程中表单发生的操作.被 React 以这种方式控制取值的表单输入元素就叫做“受控组件”.</p>\n</blockquote>\n<pre><code class=\"hljs language-tsx\"> <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">Input</span>:<span class=\"hljs-variable constant_\">FC</span> = <span class=\"hljs-function\">(<span class=\"hljs-params\">{value:<span class=\"hljs-built_in\">string</span>,  onChange:(val:<span class=\"hljs-built_in\">string</span>) => <span class=\"hljs-built_in\">void</span>}</span>) =></span> {\n   <span class=\"hljs-keyword\">return</span> <span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">{value}</span> <span class=\"hljs-attr\">onChange</span>=<span class=\"hljs-string\">{e</span> =></span> onChange(e.target.value)}/></span>\n }\n</code></pre>\n<p>对之前的非受控 <code>Input</code> 组件的代码稍微做一点调整, 将它内部的状态改为 <code>props</code> 传入, 它就变成了受控组件, 因为此时 <code>Input</code> 组件的值取决于外部传递进来的 <code>props</code>.</p>\n</li>\n</ol>\n<p>了解了这两个概念后, 我们思考一个问题, <code>ant-design</code> 中的 <code>Input</code> 组件是受控组件还是非受控组件?</p>\n<p>答案是它既可以是受控组件, 也可以是非受控组件, 完全取决于项目中怎么去使用.</p>\n<h2 id=\"如何实现\"><a aria-hidden=\"true\" tabindex=\"-1\" href=\"#如何实现\"><span class=\"icon icon-link\"></span></a>如何实现?</h2>\n<h3 id=\"最简单的方案-内外两个状态-手动同步\"><a aria-hidden=\"true\" tabindex=\"-1\" href=\"#最简单的方案-内外两个状态-手动同步\"><span class=\"icon icon-link\"></span></a>最简单的方案: 内外两个状态, 手动同步</h3>\n<p>考虑到实现成本的复杂度, 我们需要让组件逻辑在两种模式下, 尽可能的保持一致, 减少逻辑分支意味着更好的可维护性和可读性. 所以, 自然而然的, 我们可以很容易想到这个方案:</p>\n<p><code>Child</code> 组件内部始终存在一个状态, 不管它处于哪种模式, 它都直接使用自己内部的状态. 而当它处于受控模式时, 我们让它的内部状态和 <code>Parent</code> 组件中的状态手动保持同步.</p>\n<p>代码如下:</p>\n<pre><code class=\"hljs language-tsx\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">Input</span>: <span class=\"hljs-title class_\">React</span>.<span class=\"hljs-property\">FC</span>&#x3C;{ <span class=\"hljs-attr\">value</span>?: <span class=\"hljs-built_in\">string</span>; <span class=\"hljs-attr\">onChange</span>?: <span class=\"hljs-function\">(<span class=\"hljs-params\"><span class=\"hljs-attr\">val</span>: <span class=\"hljs-built_in\">string</span></span>) =></span> <span class=\"hljs-built_in\">void</span> }> = <span class=\"hljs-function\">(<span class=\"hljs-params\">{\n  value,\n  onChange,\n}</span>) =></span> {\n  <span class=\"hljs-keyword\">const</span> isControlled = value !== <span class=\"hljs-literal\">undefined</span>;\n\n  <span class=\"hljs-keyword\">const</span> [innerValue, setInnerValue] = <span class=\"hljs-title function_\">useState</span>(value);\n\n  <span class=\"hljs-title function_\">useEffect</span>(<span class=\"hljs-function\">() =></span> {\n    <span class=\"hljs-keyword\">if</span> (isControlled) {\n      <span class=\"hljs-title function_\">setInnerValue</span>(value);\n    }\n  });\n\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">input</span>\n      <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">{innerValue}</span>\n      <span class=\"hljs-attr\">onChange</span>=<span class=\"hljs-string\">{(e)</span> =></span> {\n        if (!isControlled) {\n          setInnerValue(e.target.value);\n        }\n        onChange(e.target.value);\n      }}\n    /></span>\n  );\n};\n</code></pre>\n<p>仔细看上面的代码, 我们会发现在受控模式下存在两个问题:</p>\n<p>原子性: <code>Child</code> 内部状态的更新会比 <code>Parent</code> 组件晚一个渲染周期, 存在 <code>tearing</code> 的问题\n性能:因为是在 <code>useEffect</code> 中通过 <code>setState</code> 来做的状态同步, 所以会额外的触发一次渲染, 存在性能问题\n明确问题之后, 我们来逐个解决:</p>\n<h3 id=\"原子性\"><a aria-hidden=\"true\" tabindex=\"-1\" href=\"#原子性\"><span class=\"icon icon-link\"></span></a>原子性</h3>\n<p>这个问题其实很好解决, 我们其实并不需要 Child 和 Parent 的状态保持非常严格的每时每刻都一致, 我们只需要判断, 如果组件此时处于受控模式, 那么直接使用来自外部的状态就可以了:</p>\n<p>这样, 即便状态的同步是存在延迟的, 但是 Child 组件所真正使用到的值一定是最新的.</p>\n<p>代码如下:</p>\n<pre><code class=\"hljs language-tsx\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">Input</span>: <span class=\"hljs-title class_\">React</span>.<span class=\"hljs-property\">FC</span>&#x3C;{ <span class=\"hljs-attr\">value</span>?: <span class=\"hljs-built_in\">string</span>; <span class=\"hljs-attr\">onChange</span>?: <span class=\"hljs-function\">(<span class=\"hljs-params\"><span class=\"hljs-attr\">val</span>: <span class=\"hljs-built_in\">string</span></span>) =></span> <span class=\"hljs-built_in\">void</span> }> = <span class=\"hljs-function\">(<span class=\"hljs-params\">{\n  value,\n  onChange,\n}</span>) =></span> {\n  <span class=\"hljs-keyword\">const</span> isControlled = value !== <span class=\"hljs-literal\">undefined</span>;\n\n  <span class=\"hljs-keyword\">const</span> [innerValue, setInnerValue] = <span class=\"hljs-title function_\">useState</span>(value);\n\n  <span class=\"hljs-title function_\">useEffect</span>(<span class=\"hljs-function\">() =></span> {\n    <span class=\"hljs-keyword\">if</span> (isControlled) {\n      <span class=\"hljs-title function_\">setInnerValue</span>(value);\n    }\n  });\n\n  <span class=\"hljs-keyword\">const</span> finalValue = isControlled ? value : innerValue;\n\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">input</span>\n      <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">{finalValue}</span>\n      <span class=\"hljs-attr\">onChange</span>=<span class=\"hljs-string\">{(e)</span> =></span> {\n        setInnerValue(e.target.value);\n        onChange(e.target.value);\n      }}\n    /></span>\n  );\n};\n</code></pre>\n<h3 id=\"性能\"><a aria-hidden=\"true\" tabindex=\"-1\" href=\"#性能\"><span class=\"icon icon-link\"></span></a>性能</h3>\n<p>因为我们是在 <code>useEffect</code> 去做状态同步的, 所以自然会额外的多触发一次 <code>Child</code> 组件的重渲染.如果 <code>Child</code> 组件比较简单的话, 那出现的性能影响可以忽略不计.但是对于一些复杂的组件 (例如 <code>Picker</code>), 多渲染一次带来的性能问题是比较严重的.</p>\n<p>那有没有办法在 <code>Child</code> 组件的 <code>render</code> 阶段就直接更新 <code>value</code> 状态呢?</p>\n<p>我们重新考虑一下这行 <code>useState</code> 的代码:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> [innerValue, setInnerValue] = <span class=\"hljs-title function_\">useState</span>(value);\n</code></pre>\n<p>当我们创建这个 <code>State</code> 时? 我们的目的是什么? <code>State</code> 的本质是什么?</p>\n<p>如果比较简单粗暴的分析, 我们可以把 <code>State</code> 拆成两部分:</p>\n<p><code>State</code> 是用来存放数据的, 它让我们在组件的渲染函数之外, 可以“持久化”一些数据\n<code>State</code> 的更新可以触发重新渲染, 因为 <code>React</code> 会感知 <code>State</code> 的更新\n如果写一个公式的话, 可以写成:</p>\n<p><code>State = 存放数据 + 触发重新渲染</code></p>\n<p>而但就存放数据来看, 我们可以直接使用 Ref；同样, 如果只是需要触发重新渲染, 我们可以使用类似于 <code>setFlag({})</code> 或者 <code>setCount(v => v + 1)</code> 这样的强制方式 (虽然很蠢, 但想必 90% 的 React 开发者都曾经这么写过).</p>\n<p>那我们根据这个推断来调整一下上面的公式:</p>\n<p><code>State = Ref + forceUpdate()</code></p>\n<p>我们已经非常接近了, 根据这个公式, 我们可以把 <code>Child</code> 组件中的 <code>State</code> 拆成一个 <code>Ref</code> 和一个 <code>forceUpdate</code> 函数:</p>\n<p>这样一来, 我们就可以直接在 <code>render</code> 阶段直接更新 <code>ref</code> 的值了:</p>\n<pre><code class=\"hljs language-tsx\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">Input</span>: <span class=\"hljs-title class_\">React</span>.<span class=\"hljs-property\">FC</span>&#x3C;{ <span class=\"hljs-attr\">value</span>: <span class=\"hljs-built_in\">string</span>; <span class=\"hljs-attr\">onChange</span>: <span class=\"hljs-function\">(<span class=\"hljs-params\"><span class=\"hljs-attr\">val</span>: <span class=\"hljs-built_in\">string</span></span>) =></span> <span class=\"hljs-built_in\">void</span> }> = <span class=\"hljs-function\">(<span class=\"hljs-params\">{\n  value,\n  onChange,\n}</span>) =></span> {\n  <span class=\"hljs-keyword\">const</span> isControlled = value !== <span class=\"hljs-literal\">undefined</span>;\n\n  <span class=\"hljs-keyword\">const</span> stateRef = useRef&#x3C;T | <span class=\"hljs-literal\">undefined</span>>(value);\n\n  <span class=\"hljs-keyword\">const</span> [, setFlag] = <span class=\"hljs-title function_\">useState</span>({});\n\n  <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">forceUpdate</span> = (<span class=\"hljs-params\"></span>) => {\n    <span class=\"hljs-title function_\">setFlag</span>({});\n  };\n\n  <span class=\"hljs-keyword\">const</span> finalValue = isControlled ? value : stateRef.<span class=\"hljs-property\">current</span>;\n\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">input</span>\n      <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">{finalValue}</span>\n      <span class=\"hljs-attr\">onChange</span>=<span class=\"hljs-string\">{(e)</span> =></span> {\n        stateRef.current = e.target.value;\n        forceUpdate();\n        onChange(e.target.value);\n      }}\n    /></span>\n  );\n};\n</code></pre>\n<p>再回头看下代码, 会发现, 为什么还需要判断根据受控和非受控模式来使用不同的值呢? 既然 <code>stateRef.current</code> 一定是最新的值, 那么完全可以简化成 <code>Child</code> 组件永远使用内部存放的数据 (<code>Ref</code>):</p>\n<pre><code class=\"hljs language-tsx\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">Input</span>: <span class=\"hljs-title class_\">React</span>.<span class=\"hljs-property\">FC</span>&#x3C;{ <span class=\"hljs-attr\">value</span>: <span class=\"hljs-built_in\">string</span>; <span class=\"hljs-attr\">onChange</span>: <span class=\"hljs-function\">(<span class=\"hljs-params\"><span class=\"hljs-attr\">val</span>: <span class=\"hljs-built_in\">string</span></span>) =></span> <span class=\"hljs-built_in\">void</span> }> = <span class=\"hljs-function\">(<span class=\"hljs-params\">{\n  value,\n  onChange,\n}</span>) =></span> {\n  <span class=\"hljs-keyword\">const</span> isControlled = value !== <span class=\"hljs-literal\">undefined</span>;\n\n  <span class=\"hljs-keyword\">const</span> stateRef = useRef&#x3C;T | <span class=\"hljs-literal\">undefined</span>>(value);\n\n  <span class=\"hljs-keyword\">if</span> (isControlled) {\n    stateRef.<span class=\"hljs-property\">current</span> = props.<span class=\"hljs-property\">value</span>;\n  }\n  <span class=\"hljs-keyword\">const</span> [, setFlag] = <span class=\"hljs-title function_\">useState</span>({});\n\n  <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">forceUpdate</span> = (<span class=\"hljs-params\"></span>) => {\n    <span class=\"hljs-title function_\">setFlag</span>({});\n  };\n\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">input</span>\n      <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">{finalValue}</span>\n      <span class=\"hljs-attr\">onChange</span>=<span class=\"hljs-string\">{(e)</span> =></span> {\n        stateRef.current = e.target.value;\n        forceUpdate();\n        onChange(e.target.value);\n      }}\n    /></span>\n  );\n};\n</code></pre>\n<h3 id=\"抽象与复用-usepropsvalue\"><a aria-hidden=\"true\" tabindex=\"-1\" href=\"#抽象与复用-usepropsvalue\"><span class=\"icon icon-link\"></span></a>抽象与复用: usePropsValue</h3>\n<p>上述代码仅实现了一个 <code>Input</code> 组件, 当需要定义其他组件时, 仍需要重复上述中的某些代码, 所以我们把核心代码抽离成一个自定义 <code>Hooks</code>, 同时完善一些细节. 代码如下:</p>\n<pre><code class=\"hljs language-ts\"><span class=\"hljs-keyword\">import</span> { useUpdate } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'ahooks'</span>;\n<span class=\"hljs-keyword\">import</span> { isFunction } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'lodash-es'</span>;\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">SetStateAction</span>, useRef } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'react'</span>;\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">type</span> usePropsValueOptions&#x3C;T> = {\n  <span class=\"hljs-attr\">value</span>?: T;\n  <span class=\"hljs-attr\">defaultValue</span>?: T;\n  <span class=\"hljs-attr\">onChange</span>?: <span class=\"hljs-function\">(<span class=\"hljs-params\"><span class=\"hljs-attr\">value</span>?: T</span>) =></span> <span class=\"hljs-built_in\">void</span>;\n};\n\n<span class=\"hljs-keyword\">const</span> usePropsValue = &#x3C;T>({\n  value,\n  defaultValue,\n  onChange,\n}: usePropsValueOptions&#x3C;T>): [\n  T | <span class=\"hljs-literal\">undefined</span>,\n  <span class=\"hljs-function\">(<span class=\"hljs-params\"><span class=\"hljs-attr\">v</span>: <span class=\"hljs-title class_\">SetStateAction</span>&#x3C;T | <span class=\"hljs-literal\">undefined</span>></span>) =></span> <span class=\"hljs-built_in\">void</span>\n] => {\n  <span class=\"hljs-keyword\">const</span> isControlled = value !== <span class=\"hljs-literal\">undefined</span>;\n  <span class=\"hljs-keyword\">const</span> update = <span class=\"hljs-title function_\">useUpdate</span>();\n  <span class=\"hljs-keyword\">const</span> stateRef = useRef&#x3C;T | <span class=\"hljs-literal\">undefined</span>>(isControlled ? value : defaultValue);\n\n  <span class=\"hljs-keyword\">if</span> (isControlled) {\n    stateRef.<span class=\"hljs-property\">current</span> = value;\n  }\n\n  <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">setState</span> = (<span class=\"hljs-params\"><span class=\"hljs-attr\">v</span>: <span class=\"hljs-title class_\">SetStateAction</span>&#x3C;T | <span class=\"hljs-literal\">undefined</span>></span>) => {\n    <span class=\"hljs-keyword\">const</span> nextValue = <span class=\"hljs-title function_\">isFunction</span>(v) ? <span class=\"hljs-title function_\">v</span>(stateRef.<span class=\"hljs-property\">current</span>) : v;\n\n    <span class=\"hljs-keyword\">if</span> (nextValue === stateRef.<span class=\"hljs-property\">current</span>) {\n      <span class=\"hljs-keyword\">return</span>;\n    }\n\n    stateRef.<span class=\"hljs-property\">current</span> = nextValue;\n    <span class=\"hljs-title function_\">update</span>();\n    onChange?.(nextValue);\n  };\n  <span class=\"hljs-keyword\">return</span> [stateRef.<span class=\"hljs-property\">current</span>, setState];\n};\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> usePropsValue;\n</code></pre>\n<p>这样, 在各种组件中, 我们可以直接使用 <code>usePropsValue</code>, 用法和 <code>useState</code> 非常接近:</p>\n<pre><code class=\"hljs language-ts\"><span class=\"hljs-keyword\">const</span> [internalValue, setInternalValue] = usePropsValue&#x3C;<span class=\"hljs-built_in\">string</span>>({\n  defaultValue,\n  value,\n  onChange,\n});\n\n<span class=\"hljs-keyword\">return</span> (\n  <span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">input</span>\n    <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">{internalValue}</span>\n    <span class=\"hljs-attr\">onChange</span>=<span class=\"hljs-string\">{(e)</span> =></span> {\n      setInternalValue(e.target.value);\n    }}\n  /></span>\n);\n</code></pre>","ogImage":{"url":"/assets/blog/image/cover.jpg"},"coverImage":"/assets/blog/image/cover.jpg","theme":"jzman","tag":["React"]}},"__N_SSG":true}