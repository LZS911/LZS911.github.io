{"pageProps":{"post":{"title":"Docker化一个React+Nest的Monorepo应用","date":"2023-04-25","slug":"Docker化一个React+Nest的Monorepo应用","author":"Ai.Haibara","content":"<h2 id=\"目标\"><a aria-hidden=\"true\" tabindex=\"-1\" href=\"#目标\"><span class=\"icon icon-link\"></span></a>目标</h2>\n<p>使用 <code>Docker</code> 和 <code>Docker Compose</code> 将一个使用 <a href=\"https://react.dev/\">React</a> + <a href=\"https://nestjs.com/\">NestJS</a> + <a href=\"https://www.postgresql.org/\">PostgreSQL</a> + <a href=\"https://www.prisma.io/\">prisma</a> 构建的 Web 应用程序 <strong>Dockerize</strong>。</p>\n<h2 id=\"前置准备\"><a aria-hidden=\"true\" tabindex=\"-1\" href=\"#前置准备\"><span class=\"icon icon-link\"></span></a>前置准备</h2>\n<ul>\n<li>安装 <a href=\"https://nodejs.org/en\">Node.js</a>, 且保证 Node.js 版本为 v14.17.0 或者更高版本.</li>\n<li>安装 <a href=\"https://docs.nestjs.com/cli/overview\">Nest.js CLI</a></li>\n<li>安装 <a href=\"https://pnpm.io/\">Pnpm</a></li>\n<li>安装 <a href=\"https://docs.docker.com/engine/install/\">Docker Engine</a></li>\n<li>安装 <a href=\"https://docs.docker.com/compose/install/\">Docker Compose</a></li>\n<li>安装 <a href=\"https://opensource.com/article/18/8/what-how-makefile\">Make</a></li>\n</ul>\n<h2 id=\"项目结构\"><a aria-hidden=\"true\" tabindex=\"-1\" href=\"#项目结构\"><span class=\"icon icon-link\"></span></a>项目结构</h2>\n<h3 id=\"使用-pnpm-的-workspace-功能构建一个-monorepo\"><a aria-hidden=\"true\" tabindex=\"-1\" href=\"#使用-pnpm-的-workspace-功能构建一个-monorepo\"><span class=\"icon icon-link\"></span></a>使用 Pnpm 的 <a href=\"https://pnpm.io/workspaces\">Workspace</a> 功能构建一个 Monorepo</h3>\n<p>对于一个 <code>Monorepo</code>, 我们需要创建在项目根路径创建一个 <code>packages</code> 文件夹. <code>packages</code> 里面包含了由 <a href=\"https://www.npmjs.com/package/create-vite\">create-vite</a> 创建的 <code>React</code> 项目以及由 <code>Nest.js CLI</code> 创建的后端服务. 当然, 在项目根路径也需要创建一些全局的配置文件.</p>\n<p>具体操作步骤如下:</p>\n<ul>\n<li>\n<p>在根目录初始化一个新的 git 仓库并创建以下文件:</p>\n<pre><code class=\"language-sh\">.dockerignore\n.gitignore\n.env\n.docker-compose.yaml\nMakefile\n</code></pre>\n</li>\n<li>\n<p>创建 packages 文件用于存放前后端项目:</p>\n<pre><code class=\"language-sh\">mkdir packages &#x26;&#x26; cd packages\n</code></pre>\n</li>\n<li>\n<p>创建前端项目, 并添加 Dockerfile.local 以及 Dockerfile.production 文件</p>\n<pre><code class=\"language-sh\">pnpm create vite\n</code></pre>\n</li>\n<li>\n<p>创建后端项目, 并且在执行完后手动删除 node_modules, 同时也添加 Dockerfile.local 以及 Dockerfile.production 文件</p>\n<pre><code class=\"language-sh\">nest new backend\n</code></pre>\n</li>\n<li>\n<p>重新配置 tsconfig.json:</p>\n<p>首先在项目根目录执行: <code>tsc --init</code>, 初始化一份 <code>tsconfig.json</code>, 并且将文件内容修改至以下内容:</p>\n<pre><code class=\"language-json\">  {\n   \"compilerOptions\": {\n     \"module\": \"commonjs\",\n     \"declaration\": true,\n     \"removeComments\": true,\n     \"emitDecoratorMetadata\": true,\n     \"experimentalDecorators\": true,\n     \"allowSyntheticDefaultImports\": true,\n     \"target\": \"es2017\",\n     \"sourceMap\": true,\n     \"outDir\": \"./dist\",\n     \"baseUrl\": \"./\",\n     \"incremental\": true,\n     \"skipLibCheck\": true,\n     \"strictNullChecks\": false,\n     \"noImplicitAny\": false,\n     \"strictBindCallApply\": false,\n     \"forceConsistentCasingInFileNames\": true,\n     \"noFallthroughCasesInSwitch\": false,\n     \"strict\": true,\n     \"jsx\": \"react-jsx\"\n   },\n   \"include\": [\"packages/*/src\"]\n  }\n</code></pre>\n<p>最后将前后端项目中由工具创建的 <code>tsconfig.json</code> 文件内容修改至以下内容:</p>\n<pre><code class=\"language-json\">  {\n   \"extends\": \"../../tsconfig.json\",\n   \"include\": [\"./src\"]\n  }\n</code></pre>\n</li>\n<li>\n<p>创建 pnpm-workspace.yml, 填充以下内容:</p>\n<pre><code class=\"language-yml\">  packages:\n - 'packages/**'\n</code></pre>\n</li>\n<li>\n<p>在根目录创建 package.json 文件, 并且将前后端相同的依赖项提取至其中. 执行 <code>pnpm install -r</code> , 完成依赖的安装.</p>\n</li>\n</ul>\n<p>最后, 得到的项目结构应如下图所示</p>\n<p><img src=\"/assets/docker-react-nest/example1.png\" alt=\"alt\"></p>\n<h2 id=\"dockerize\"><a aria-hidden=\"true\" tabindex=\"-1\" href=\"#dockerize\"><span class=\"icon icon-link\"></span></a>Dockerize</h2>\n<h3 id=\"backend-dockerfile\"><a aria-hidden=\"true\" tabindex=\"-1\" href=\"#backend-dockerfile\"><span class=\"icon icon-link\"></span></a>Backend Dockerfile</h3>\n<p>回到本文主题, 现在, 我们的 Backend 文件夹中包含了两个 Dockerfile 文件. 其中一个用于在本地运行项目, 它用于docker-compose.yaml 文件, 而另一个用于生产环境.</p>\n<p>现在将以下内容填充至 Dockerfile.local:</p>\n<pre><code class=\"language-dockerfile\">#获取node镜像源\nFROM node:16.16.0-alpine\n\n#设置工作目录\nWORKDIR /projects\n\n# 将 pnpm-lock.yaml 拷贝至工作目录, 为后续的 pnpm fetch 做准备\nCOPY ./pnpm-lock.yaml ./\n\n# 安装 pnpm, 并且固定版本, 也可以考虑在获取node镜像源时直接获取带有pnpm的镜像, 这样就能省略这一步了\nRUN npm install -g pnpm@8.3.1\n\n# pnpm fetch 通过提供仅使用锁定文件中的信息将包加载到虚拟存储中的能力，完美地解决了上述问题. 具体见: https://pnpm.io/cli/fetch\nRUN pnpm fetch\n\nCOPY . .\n\n# 安装依赖, 关于 --offline 见: https://pnpm.io/cli/fetch\nRUN pnpm install -r --offline\n\n# https://zhuanlan.zhihu.com/p/89335014\nVOLUME [\"/projects/node_modules/\", \"/projects/packages/backend/node_modules/\", \"/projects/.pnpm-store/\"]\n\n# https://yeasy.gitbook.io/docker_practice/image/dockerfile/expose\nEXPOSE $BACKEND_PORT\n\n# 启动后端服务\nCMD rm -rf dist &#x26;&#x26; cd packages/backend &#x26;&#x26; pnpm start:debug\n</code></pre>\n<h3 id=\"frontend-dockerfile\"><a aria-hidden=\"true\" tabindex=\"-1\" href=\"#frontend-dockerfile\"><span class=\"icon icon-link\"></span></a>Frontend Dockerfile</h3>\n<p>前端文件夹下的 Dockerfile:</p>\n<pre><code class=\"language-dockerfile\">#获取node镜像源\nFROM node:16.16.0-alpine\n\n#设置工作目录\nWORKDIR /app\n\n# 将 pnpm-lock.yaml 拷贝至工作目录, 为后续的 pnpm fetch 做准备\nCOPY ./pnpm-lock.yaml ./\n\n# 安装 pnpm, 并且固定版本, 也可以考虑在获取node镜像源时直接获取带有pnpm的镜像, 这样就能省略这一步了\nRUN npm install -g pnpm@8.3.1\n\n# pnpm fetch 通过提供仅使用锁定文件中的信息将包加载到虚拟存储中的能力，完美地解决了上述问题. 具体见: https://pnpm.io/cli/fetch\nRUN pnpm fetch\n\nCOPY . .\n\n# 安装依赖, 关于 --offline 见: https://pnpm.io/cli/fetch\nRUN pnpm install -r --offline\n\n# https://zhuanlan.zhihu.com/p/89335014\nVOLUME [\"/app/node_modules/\", \"/app/packages/frontend/node_modules/\", \"/app/.pnpm-store/\"]\n\n# 启动前端服务\nCMD cd packages/frontend &#x26;&#x26; pnpm start\n\n</code></pre>\n<h3 id=\"创建-docker-compose-文件并运行项目\"><a aria-hidden=\"true\" tabindex=\"-1\" href=\"#创建-docker-compose-文件并运行项目\"><span class=\"icon icon-link\"></span></a>创建 Docker Compose 文件并运行项目</h3>\n<ol>\n<li>\n<p>配置环境变量: 将以下内容填充至 <code>&#x3C;rootDir>/.env</code></p>\n<pre><code class=\"language-sh\">   NODE_ENV=development\n   FRONTEND_PORT=7879\n   BACKEND_PORT=7878\n   JWT_SECRET=jwt_secret_key_here\n   JWT_EXPIRES_IN=30d\n   DB_HOST=bp-pg-db\n   DB_NAME=bp-pg-db\n   DB_USER=postgres\n   DB_PASSWORD=root\n   DB_PORT=5432\n   PGADMIN_DEFAULT_EMAIL=admin@backend.com\n   PGADMIN_DEFAULT_PASSWORD=pass@123\n   PGADMIN_PORT=5055\n</code></pre>\n</li>\n<li>\n<p>将以下内容填充至 <code>&#x3C;rootDIr>/docker-compose.yml</code></p>\n<pre><code class=\"language-yml\">    version: '3.9'\n    services:\n      frontend:\n        container_name: frontend\n        build:\n          context: ./\n          dockerfile: ./packages/frontend/Dockerfile.local\n        restart: always\n        env_file: .env\n        ports:\n          - '${FRONTEND_PORT}:${FRONTEND_PORT}'\n        volumes:\n          - .:/app\n        networks:\n          bp-network:\n            ipv4_address: 172.25.0.3\n      backend:\n        container_name: backend\n        build:\n          context: ./\n          dockerfile: ./packages/backend/Dockerfile.local\n        restart: always\n        env_file: .env\n        volumes:\n          - .:/app\n        networks:\n          bp-network:\n            ipv4_address: 172.25.0.2\n        ports:\n          - '${BACKEND_PORT}:${BACKEND_PORT}'\n        depends_on:\n          - bp-pg-db\n        links:\n          - bp-pg-db\n      bp-pg-db:\n        image: postgres:12-alpine\n        restart: always\n        container_name: bp-pg-db\n        env_file:\n          - .env\n        environment:\n          POSTGRES_PASSWORD: ${DB_PASSWORD}\n          PGDATA: /var/lib/postgresql/data\n          POSTGRES_USER: ${DB_USER}\n          POSTGRES_DB: ${DB_NAME}\n        ports:\n          - '${DB_PORT}:${DB_PORT}'\n        volumes:\n          - pgdata:/var/lib/postgresql/data\n        networks:\n          bp-network:\n            ipv4_address: 172.25.0.5\n      pgadmin-portal:\n        image: dpage/pgadmin4\n        restart: always\n        container_name: pgadmin-portal\n        env_file:\n          - .env\n        environment:\n          PGADMIN_DEFAULT_PASSWORD: '${PGADMIN_DEFAULT_PASSWORD}'\n          PGADMIN_DEFAULT_EMAIL: '${PGADMIN_DEFAULT_EMAIL}'\n        volumes:\n          - pgadmin:/root/.pgadmin\n        ports:\n          - '${PGADMIN_PORT}:80'\n        depends_on:\n          - bp-pg-db\n        networks:\n          bp-network:\n            ipv4_address: 172.25.0.6\n    volumes:\n      pgdata:\n      pgadmin:\n    networks:\n      bp-network:\n        driver: bridge\n        ipam:\n          config:\n            - subnet: 172.25.0.0/16\n    \n</code></pre>\n<ol>\n<li><code>Services</code>: 每个服务代表一个将要创建的 Docker 容器</li>\n</ol>\n<ul>\n<li>frontend: 基于前端项目的 Dockerfile.local 构建镜像以及容器. 此容器将会控制前端服务的启停.</li>\n<li>backend: 基于后端项目的 Dockerfile.local 构建镜像以及容器. 此容器将会控制后端服务的启停.</li>\n<li>bp-pg-db: 基于镜像 postgres:12-alpine 构建的 postgres 数据库容器.</li>\n<li>pgadmin-portal: 基于镜像 dpage/pgadmin4 构建的 postgres 可视化界面操作服务.</li>\n</ul>\n</li>\n<li>\n<p>添加 Makefile 用来启动:</p>\n<pre><code class=\"language-Makefile\">local: \n   docker-compose stop &#x26;&#x26; docker-compose up --build -d --remove-orphans\n</code></pre>\n</li>\n</ol>\n<p>使用 <code>make local</code> 命令后, 将构建镜像并启动容器服务, 此时便能通过配置中暴露出的端口号来正常的访问到前端、后端以及数据库服务. 同时, 得益于 <code>VOlUME</code>, 我们在本地修改代码后能及时的映射到容器的挂卷中, 通过项目的热更新来开发项目.</p>\n<h2 id=\"生产环境部署\"><a aria-hidden=\"true\" tabindex=\"-1\" href=\"#生产环境部署\"><span class=\"icon icon-link\"></span></a>生产环境部署</h2>\n<h3 id=\"frontend-项目\"><a aria-hidden=\"true\" tabindex=\"-1\" href=\"#frontend-项目\"><span class=\"icon icon-link\"></span></a>frontend 项目</h3>\n<p><strong>目标: 利用 github webhook 在项目push代码后自动触发 jenkins 流水线用来构建项目</strong></p>\n<p>环境准备:</p>\n<ol>\n<li>\n<p>创建以下文件夹:</p>\n<ul>\n<li>jenkins/jenkins/home: 用来存放 jenkins 配置文件以及插件和 jenkins 的工作区等内容.</li>\n<li>nginx/default.conf: nginx 的配置文件</li>\n<li>webserver/static/jenkins/dist: 存放前端项目打包后的产物</li>\n<li>docker-compose.yml: docker-compose 的配置文件</li>\n</ul>\n<p>default.conf 内容如下(本文不涉及 nginx 配置知识, 所以这里使用一个最基本的配置文件):</p>\n<pre><code class=\"language-conf\">  server{\n    listen  80;\n    server_name localhost;\n    root /usr/share/nginx/html;\n    index index.html;\n  \n    location / {\n       try_files $uri $uri/ /index.html =404;\n    }\n          \n  # location /v {\n  # 根据项目配置反向代理  \n  #   proxy_pass &#x3C;http://localhost:7878>\n  # }\n}\n</code></pre>\n</li>\n<li>\n<p>编写 <code>docker-compose.yml</code> 来构建 jenkins 容器以及部署前端项目的 nginx 容器, 内容如下:</p>\n<pre><code class=\"language-yml\">   version: \"3.9\"\n     services:                                      \n       docker_jenkins:\n         environment:\n           - TZ=Asia/Shanghai\n         user: root                                \n         restart: always                           \n         image: jenkins/jenkins:lts              \n         container_name: cicd-jenkins                 \n         ports:                                \n           - 8077:8080                             \n           - 50000:50000                          \n         volumes:                               \n           - ./jenkins/jenkins_home/:/var/jenkins_home  \n           - /var/run/docker.sock:/var/run/docker.sock\n           - /usr/bin/docker:/usr/bin/docker              \n           - /usr/local/bin/docker-compose:/usr/local/bin/docker-compose\n       docker_nginx:\n         environment:\n           - TZ=Asia/Shanghai\n         restart: always\n         image: nginx:stable-alpine               \n         container_name: cicd-nginx\n         ports:\n           - 7070:80                             \n         volumes:\n           - ./nginx/:/etc/nginx/conf.d/\n           - ./webserver/static/jenkins/dist/:/usr/share/nginx/html/\n</code></pre>\n</li>\n<li>\n<p>执行 <code>docker-compose up --build -d --remove-orphans</code> 后, 此时应该会成功启动两个容器, 可以使用 <code>docker container ls</code> 查看:, 大致内容如下:</p>\n<p><img src=\"/assets/docker-react-nest/example2.png\" alt=\"alt\"></p>\n<p>此时在本地访问 <code>http://ip(容器的宿主主机ip地址):8077</code> 应该能够正常访问 jenkins 服务, 初始化界面应该如下:</p>\n<p><img src=\"/assets/docker-react-nest/example3.png\" alt=\"alt\"></p>\n<p>在宿主主机上执行 <code>docker logs [container_id]</code>, 从 log 信息从获取管理源密码, 然后进入插件安装页面, 这里安装推荐插件即可.</p>\n</li>\n<li>\n<p>插件安装完成且创建用户进入 jenkins 后点击 <strong>Manage Jenkins</strong>, 然后再点击进入<strong>Manage Plugins</strong>. 这里需要安装 <code>Node</code> 插件以及 <code>Publish over SSH</code>.</p>\n<p>前者为构建流程提供 <code>NodeJs</code> 环境, 后者将构建完成后得到的前端产物压缩包上传至目标服务器.</p>\n<p><img src=\"/assets/docker-react-nest/example4.png\" alt=\"alt\"></p>\n</li>\n<li>\n<p>配置 <code>NodeJs</code> 环境. 点击 <strong>系统管理</strong>, 然后再点击进入<strong>全局工具配置</strong>, 找到 NodeJS, 点击 <strong>新增NodeJS</strong>. 最后根据项目的需求进行选择 <code>Node</code> 版本以及是否要安装全局工具即可.</p>\n<p><img src=\"/assets/docker-react-nest/example5.png\" alt=\"alt\"></p>\n</li>\n<li>\n<p>点击系统管理中的<strong>Credentials</strong>, 然后添加 github 的凭据. 可以添加 github 的 token、账号密码以及公私钥三种类型的凭据.</p>\n</li>\n<li>\n<p>配置 github-webhook. 点击系统管理中的<strong>系统配置</strong>, 找到 Github, 然后点击<strong>添加Github</strong>服务器, 在凭据一栏添加在上一步添加的 Github 凭据.</p>\n<p><img src=\"/assets/docker-react-nest/example6.png\" alt=\"alt\"></p>\n<p>找到最下方的更多按钮, 点击后会出现覆盖 Hook URL的选项, 将这里的地址绑定到 github 项目上的 webhook 即可.\n当然, 如果 jenkins 容器宿主主机为本地主机或者为内网主机, 可使用 <a href=\"https://dashboard.ngrok.com/\">ngrok</a> 实现内网穿透, 来保证 github 能访问到 jenkins.</p>\n<p>注意事项:</p>\n<ol>\n<li>github-webhook地址前缀需与 jenkins 配置中的 <strong>Jenkins URL</strong> 保持一致.</li>\n<li>关于 <a href=\"https://docs.github.com/en/webhooks-and-events/webhooks/about-webhooks\">github webhook</a>.</li>\n</ol>\n</li>\n<li>\n<p>添加服务器信息. 在系统配置中找到<strong>Publish over SSH</strong>, 在 Passphrase 一栏填入服务器密码, 然后点击<strong>新增</strong>, 填入服务器信息.</p>\n<p><img src=\"/assets/docker-react-nest/example7.png\" alt=\"alt\"></p>\n</li>\n<li>\n<p>创建任务</p>\n<ul>\n<li>\n<p>点击新建任务, 输入任务名称后选择<strong>构建一个自由风格的软件项目</strong>\n<img src=\"/assets/docker-react-nest/example8.png\" alt=\"alt\"></p>\n</li>\n<li>\n<p>源码管理里输入项目地址、添加 Github 凭据, 选择项目分支.\n<img src=\"/assets/docker-react-nest/example9.png\" alt=\"alt\"></p>\n</li>\n<li>\n<p>构建触发器里选择 <strong>GitHub hook trigger for GITScm polling</strong>\n<img src=\"/assets/docker-react-nest/example10.png\" alt=\"alt\"></p>\n</li>\n<li>\n<p>选择构建环境\n<img src=\"/assets/docker-react-nest/example11.png\" alt=\"alt\"></p>\n</li>\n<li>\n<p>添加构建步骤. 这里可以将步骤放在 <code>Makefile</code> 文件中或者 <code>sh</code> 脚本中, 这样每次更新步骤只需要更新配置文件, 而不用修改 jenkins 配置. 当然这一步也可以用 <a href=\"https://www.jenkins.io/zh/doc/book/pipeline/jenkinsfile/\">Jenkinsfile</a>替代.\n<img src=\"/assets/docker-react-nest/example12.png\" alt=\"alt\"></p>\n<p><code>build.sh</code>:</p>\n<pre><code class=\"language-sh\"> pnpm fetch\n pnpm install -r --offline\n \n # frontend\n pnpm build:frontend\n cd ./packages/frontend\n tar zcf frontend.tar.gz ./dist\n mv ./frontend.tar.gz ../../frontend.tar.gz\n</code></pre>\n</li>\n<li>\n<p>添加构建后的操作. 这里选择 <strong>Send build artifacts over SSH</strong>, 填入以下内容:\n<img src=\"/assets/docker-react-nest/example13.png\" alt=\"alt\">\n其中 SSH Server Name 为上一步添加的服务器名称.</p>\n</li>\n</ul>\n</li>\n</ol>\n<p>到这里, 一个前端项目的自动化部署基本完成了. 在提交项目代码后, 便会自动触发任务, 进行项目构建, 并将构建后的产物上传至目标服务器. 然后将文件内容映射到 nginx 容器中.</p>\n<p>关于 <code>NestJs</code> 服务的部署, 将构建开发环境中的 <code>docker-compose.yml</code>稍微进行改造即可, 内容如下:</p>\n<pre><code class=\"language-yml\">version: '3.9'\nservices:\n  backend-prod:\n    container_name: backend-prod\n    user: root\n    build:\n      context: ./\n      dockerfile: ./packages/backend/Dockerfile.prod\n    image: webserver-backend-prod\n    restart: always\n    env_file: .env\n    networks:\n      bp-network:\n        ipv4_address: 172.25.0.2\n    ports:\n      - '${BACKEND_PORT}:3535'\n    depends_on:\n      - bp-pg-db-prod\n    command: [sh, -c, \"cd packages/backend &#x26;&#x26; pnpm migrate:postgres &#x26;&#x26; pnpm prisma:gen &#x26;&#x26; pnpm build &#x26;&#x26; pnpm start:prod\"]\n  bp-pg-db-prod:\n    image: postgres:12-alpine\n    restart: always\n    container_name: bp-pg-db-prod\n    env_file:\n      - .env\n    environment:\n      POSTGRES_PASSWORD: ${DB_PASSWORD}\n      PGDATA: /var/lib/postgresql/data\n      POSTGRES_USER: ${DB_USER}\n      POSTGRES_DB: ${DB_NAME}\n    ports:\n      - '${DB_PORT}:${DB_PORT}'\n    volumes:\n      - pgdata:/var/lib/postgresql/data\n    networks:\n      bp-network:\n        ipv4_address: 172.25.0.5\n  pgadmin-portal-prod:\n    image: dpage/pgadmin4\n    restart: always\n    container_name: pgadmin-portal-prod\n    env_file:\n      - .env\n    environment:\n      PGADMIN_DEFAULT_PASSWORD: '${PGADMIN_DEFAULT_PASSWORD}'\n      PGADMIN_DEFAULT_EMAIL: '${PGADMIN_DEFAULT_EMAIL}'\n    volumes:\n      - pgadmin:/root/.pgadmin\n    ports:\n      - '${PGADMIN_PORT}:80'\n    depends_on:\n      - bp-pg-db-prod\n    networks:\n      bp-network:\n        ipv4_address: 172.25.0.6\nvolumes:\n  pgdata:\n  pgadmin:\nnetworks:\n  bp-network:\n    driver: bridge\n    ipam:\n      config:\n        - subnet: 172.25.0.0/16\n\n</code></pre>\n<p>Dockerfile.prod:</p>\n<pre><code class=\"language-dockerfile\">FROM node:16.16.0-alpine\n\n\nWORKDIR /app\n\nCOPY ./pnpm-lock.yaml ./\n\nRUN npm install -g pnpm@8.3.1\n\nRUN pnpm fetch\n\nCOPY . .\n\nRUN pnpm install -r --offline\n\nVOLUME [\"/app/node_modules/\", \"/app/packages/backend/node_modules/\", \"/app/.pnpm-store/\"]\n</code></pre>\n<p>由于本文所构建项目为一个 Monorepo, 所以在提交前端代码时同时会触发后端项目的构建, 所以我们仅需将以下内容添加至前端构建流程中的 <code>./scripts/build.sh</code>即可:</p>\n<pre><code class=\"language-sh\">docker-compose -f docker-compose.server.yaml stop &#x26;&#x26; docker-compose -f docker-compose.server.yaml up --build -d --remove-orphans\n</code></pre>\n<p>注意事项:</p>\n<ol>\n<li>需要移除 docker-compose 中后端服务的 volume. 由于jenkins在构建完成后会清空工作区, 所以这里不需要同构建开发环境一样进行文件映射.</li>\n<li>NestJS 项目中开发环境以及生产环境中环境变量的区分.</li>\n</ol>\n<p>最后, 构建完成后, 宿主主机上容器列表如下:</p>\n<p><img src=\"/assets/docker-react-nest/example14.png\" alt=\"alt\"></p>\n<p>通过 http:[ip]:7878 即可正常访问后端服务, http:[ip]:5055 可访问 pgadmin.</p>\n<p>项目地址: <a href=\"https://github.com/LZS911/todo-react-nest-docker\">https://github.com/LZS911/todo-react-nest-docker</a>\njenkins+nginx容器构建: <a href=\"https://github.com/LZS911/jenkins-nginx-docker\">https://github.com/LZS911/jenkins-nginx-docker</a></p>","theme":"orange","tag":["Docker","Docker Compose","React","Nest","Monorepo","Pnpm","Nginx","Jenkins","PostgreSQL"]}},"__N_SSG":true}