{"pageProps":{"post":{"title":"Next.js 学习记录","date":"2022-09-28","slug":"Next.js 学习记录","author":"LZS_911","content":"<p><code>Next.js</code> 是一个 <code>React</code> 应用框架, 使用它可以快速上手开发 <code>React</code> 应用. <code>React</code> 作为一个用来构建 <code>UI</code> 的库, 对于开发一个完整的 <code>React</code> 应用是远远不够的.我们还需要构建、打包和运行等开发工具, 比如使用 <code>Babel</code> 转换使用了新特性的 <code>JavaScript</code> 代码、处理 <code>SASS</code> 和 <code>LESS</code> 样式文件等.开发功能时, 除了构建界面, 还需要处理页面路由、获取服务端数据、管理应用状态等.为了让应用对搜索引擎友好, 最好支持服务端渲染.如果自己从零去安装配置各种开发工具, 需要花费许多时间和精力, 因此 <code>React</code> 官方提供了 <code>Create React App</code>（简称 <code>CRA</code> ）工具来降低上手开发 <code>React</code> 应用的门槛. <code>Next.js</code> 可以看作是 <code>CRA</code> 的升级版.</p>\n<h3 id=\"初始化-nextjs-app\"><a aria-hidden=\"true\" tabindex=\"-1\" href=\"#初始化-nextjs-app\"><span class=\"icon icon-link\"></span></a>初始化 Next.js APP</h3>\n<p>进入项目文件夹后执行:</p>\n<p><code>npx create-next-app Next.js-blog --use-npm --example \"https://github.com/vercel/next-learn/tree/master/basics/learn-starter\"</code></p>\n<p>关于 <code>npx</code>: <a href=\"https://medium.com/itsems-frontend/whats-npx-e83400efe7f8\">https://medium.com/itsems-frontend/whats-npx-e83400efe7f8</a></p>\n<p><code>--example \"https://github.com/vercel/next-learn/tree/master/basics/learn-starter\"</code> 指定链接地址作为初始化项目的模板</p>\n<h3 id=\"项目目录结构\"><a aria-hidden=\"true\" tabindex=\"-1\" href=\"#项目目录结构\"><span class=\"icon icon-link\"></span></a>项目目录结构</h3>\n<ol>\n<li><code>pages</code>(必需):<code>pages</code> 目录是 <code>Next.js</code> 中最重要的一个目录, 这个目录的每一个文件都会对应到每一个页面, 可以根据地址栏的路由进行跳转.若 <code>pages</code> 下的 <code>js</code> 文件在一个目录下, 那么 <code>Next.js</code> 默认会将这个目录也当作路由的路径.</li>\n<li><code>components</code>(非必需): <code>components</code> 目录存放的是一些公用的组件, 这些代码不能放在 <code>pages</code> 下, 不然的话就会以页面的形式进行导出.</li>\n<li><code>lib</code>(非必需):<code>lib</code> 目录存放一些工具方法, 比如 <code>util</code> 等等.</li>\n<li><code>static</code>(非必需):<code>static</code> 目录存放一些静态资源文件.</li>\n</ol>\n<h3 id=\"默认文件\"><a aria-hidden=\"true\" tabindex=\"-1\" href=\"#默认文件\"><span class=\"icon icon-link\"></span></a>默认文件</h3>\n<p><code>index.js</code>: <code>Next.js</code> 的 <code>pages</code> 下默认入口文件, 这个文件会对应浏览器地址栏为根路径的那个页面.</p>\n<h3 id=\"内置组件\"><a aria-hidden=\"true\" tabindex=\"-1\" href=\"#内置组件\"><span class=\"icon icon-link\"></span></a>内置组件</h3>\n<ol>\n<li>\n<p><code>Link</code>: 网页中两个页面之间的跳转一般使用 <code>a</code> 标签. 在 <code>Next.js</code> 中, 可以使用 <code>Link</code> 组件 <code>next/link</code> 在应用程序中的页面之间进行链接. <code>Link</code> 允许进行客户端导航并接受一些属性.</p>\n<pre><code class=\"language-JavaScript\">//index.js\nimport Link from 'next/link';\n\n\n// href=\"/posts/first-post\" : 跳转至 pages 目录下的 posts/first-post.js\n&#x3C;h1 className=\"title\">\n  Read &#x3C;Link href=\"/posts/first-post\">this page!&#x3C;/Link>\n&#x3C;/h1>\n</code></pre>\n<p>在 pages 目录下新建 posts/first-post.js</p>\n<pre><code class=\"language-JavaScript\">//posts/first-post.js\nimport Link from 'next/link';\n\nexport default function FirstPost() {\n  return (\n    &#x3C;>\n      &#x3C;h1>First Post&#x3C;/h1>\n      &#x3C;h2>\n        &#x3C;Link href=\"/\">Back to home&#x3C;/Link>\n      &#x3C;/h2>\n    &#x3C;/>\n  );\n}\n</code></pre>\n</li>\n<li>\n<p><code>Image</code>: 提供对图片资源自动进行优化的功能.</p>\n<p>使用常规 HTML 添加个人资料图片如下所示:</p>\n<pre><code class=\"language-HTML\">  &#x3C;img src=\"/images/profile.jpg\" alt=\"Your Name\" />\n</code></pre>\n<p>这种情况下必须手动处理:</p>\n<ul>\n<li>确保您的图像在不同的屏幕尺寸上响应</li>\n<li>使用第三方工具或库优化您的图像</li>\n<li>仅在图像进入视口时加载图像</li>\n</ul>\n<p>使用图像组件</p>\n<pre><code class=\"language-JavaScript\">import Image from 'next/image';\n\nconst YourComponent = () => (\n  &#x3C;Image\n    src=\"/images/profile.jpg\" // Route of the image file\n    height={144} // Desired size with correct aspect ratio\n    width={144} // Desired size with correct aspect ratio\n    alt=\"Your Name\"\n  />\n);\n</code></pre>\n<p><code>Next.js</code> 不是在构建时优化图像, 而是在用户请求时按需优化图像.与静态站点生成器和纯静态解决方案不同, 构建时间不会增加, 无论是发送 10 个图像还是 1000 万个图像.</p>\n<p>默认情况下, 图像是延迟加载的.这意味着您的页面速度不会因视口之外的图像而受到惩罚.图像在滚动到视口时加载.</p>\n</li>\n<li>\n<p><code>Head</code>: 代替 <code>Html5</code> 中的 <code>&#x3C;head></code> 标签</p>\n<pre><code class=\"language-Html\"> &#x3C;Head>\n   &#x3C;title>Create Next App&#x3C;/title>\n   &#x3C;link rel=\"icon\" href=\"/favicon.ico\" />\n &#x3C;/Head>\n</code></pre>\n</li>\n</ol>\n<h3 id=\"关于-css\"><a aria-hidden=\"true\" tabindex=\"-1\" href=\"#关于-css\"><span class=\"icon icon-link\"></span></a>关于 CSS</h3>\n<ol>\n<li>\n<p><code>css</code> 模块. <code>css</code> 模块允许通过自动创建唯一的类名来在组件级别本地限定 <code>css</code>. 这允许您在不同的文件中使用相同的 <code>css</code> 类名, 而不必担心类名冲突</p>\n<p><code>utils.module.cs</code></p>\n<pre><code class=\"language-css\">.maxW100{\n  max-width:100rem;\n}\n``\npages/index.j\n```jsx\nimport utilStyles from \"../styles/utils.module.css\";\n\n&#x3C;div className={utilStyles.maxW100}>test style&#x3C;/div>\n``\n\n</code></pre>\n</li>\n<li>\n<p>通过其他方式来设置 <code>Next.js</code> 应用程序的样式</p>\n<ul>\n<li><code>SASS</code></li>\n<li><code>PostCss</code> 库, 例如 <a href=\"https://tailwindcss.com/docs/installation\">TailwindCss</a></li>\n<li><code>CSS-in-JS</code> 库, 例如 <a href=\"https://nextjs.org/blog/styling-next-with-styled-jsx\">styled-jsx</a>、<a href=\"https://styled-components.com/\">styled-components</a> 和 [Emotion](<a href=\"https://github.com/emotion-js/emotion\">https://github.com/emotion-js/emotion</a></li>\n</ul>\n</li>\n<li>\n<p>添加全局样式时, 需要创建一个名为 <code>pages/_app.js</code> 的文件, 其内容如下</p>\n<pre><code class=\"language-jsx\">import '../styles/global.css';\nexport default function App({ Component, pageProps }) {\n  return &#x3C;Component {...pageProps} />;\n}\n</code></pre>\n<p>该 <code>App</code> 组件是所有不同页面通用的顶级组件.</p>\n</li>\n</ol>\n<h3 id=\"预渲染与数据获取\"><a aria-hidden=\"true\" tabindex=\"-1\" href=\"#预渲染与数据获取\"><span class=\"icon icon-link\"></span></a>预渲染与数据获取</h3>\n<ol>\n<li>\n<p><code>Next.js</code> 的预渲染功能</p>\n<ul>\n<li>\n<p>什么是预渲染</p>\n<p>默认情况下, <code>Next.js</code> 预渲染每个页面.这意味着 <code>Next.js</code> 会提前为每个页面生成 <code>HTML</code>, 而不是全部由客户端 <code>JavaScript</code> 完成.预渲染可以带来更好的性能和 <a href=\"https://zh.wikipedia.org/wiki/%E6%90%9C%E5%B0%8B%E5%BC%95%E6%93%8E%E6%9C%80%E4%BD%B3%E5%8C%96\">SEO</a>.</p>\n<p>每个生成的 HTML 都与该页面所需的最少 <code>JavaScript</code> 代码相关联.当浏览器加载页面时, 其 <code>JavaScript</code> 代码将运行并使页面完全交互.(这个过程称为水合作用.)</p>\n</li>\n<li>\n<p>两种形式的预渲染</p>\n<ol>\n<li><code>SSR</code>: 服务器端渲染是在每个请求上生成 <code>HTML</code> 的预渲染方法.</li>\n<li><code>SSG</code>: 静态生成是在构建时生成 <code>HTML</code> 的预渲染方法.然后在每个请求上重用预呈现的 HTML</li>\n</ol>\n</li>\n<li>\n<p><code>SSG</code>: 静态生成\n<code>Next.js</code> 提供了 <code>getStaticProps</code> 这样一个方法, 将其定义在需要获取数据的页面组件中, 并将其导出.\n两个注意点:</p>\n<ol>\n<li><code>dev</code> 环境中, <code>getStaticProps</code> 会在每一个请求上运行, <code>product</code> 环境会在构建时运行</li>\n<li>在函数内部可以获取外部的数据并将其以 <code>props</code> 的形式传递至组件中</li>\n</ol>\n<pre><code class=\"language-jsx\">const Home = (props) => { ... }\nexport const getStaticProps = async () => {\n  const data = [];\n\n  return {\n    props: data\n  }\n}\nexport default Home\n</code></pre>\n</li>\n<li>\n<p><code>SSR</code>: 服务端渲染\n如果需要在请求时而不是构建时获取数据, 可以使用服务端渲染. <code>Next.js</code> 同样提供了一个名为 <code>getServerSideProps</code> 的函数.</p>\n<pre><code class=\"language-JavaScript\">export const getServerSideProps = (context) => {\n  return {\n    props:{}\n  }\n}\n</code></pre>\n<p>因为 <code>getServerSideProps</code> 是在请求时调用的, 所以它的参数 <code>context</code> 包含了请求特定的参数.</p>\n</li>\n</ul>\n</li>\n</ol>","ogImage":{"url":"/assets/blog/image/cover.jpg"},"coverImage":"/assets/blog/image/cover.jpg","theme":"condensed-night-purple","tag":["next.js","react"]}},"__N_SSG":true}