{"pageProps":{"post":{"title":"Typescript性能探究","date":"2024-12-05","slug":"Typescript性能探究","author":"Ai.Haibara","content":"<h2 id=\"为什么-typescript-性能很重要\"><a aria-hidden=\"true\" tabindex=\"-1\" href=\"#为什么-typescript-性能很重要\"><span class=\"icon icon-link\"></span></a>为什么 TypeScript 性能很重要</h2>\n<p>TypeScript 性能问题会严重影响开发体验，尤其是在 IDE 响应能力可能受到影响的大型项目中。理解和实施性能优化​​策略对于保持顺畅的开发工作流程至关重要。</p>\n<h2 id=\"关键优化策略\"><a aria-hidden=\"true\" tabindex=\"-1\" href=\"#关键优化策略\"><span class=\"icon icon-link\"></span></a>关键优化策略</h2>\n<blockquote>\n<p>原文地址：<a href=\"https://github.com/microsoft/TypeScript/wiki/Performance#preferring-interfaces-over-intersections\">https://github.com/microsoft/TypeScript/wiki/Performance#preferring-interfaces-over-intersections</a></p>\n</blockquote>\n<h3 id=\"优先选择-interface-而不是-intersection-types\"><a aria-hidden=\"true\" tabindex=\"-1\" href=\"#优先选择-interface-而不是-intersection-types\"><span class=\"icon icon-link\"></span></a>优先选择 Interface 而不是 Intersection Types</h3>\n<p>大多数时候，对象类型的简单类型别名的作用与接口非常相似。</p>\n<pre><code>interface Foo { prop: string }\n\ntype Bar = { prop: string };\n</code></pre>\n<p>但是，一旦您需要组合两个或多个类型，您就可以选择使用接口扩展这些类型，或者在类型别名中将它们相交，此时差异就开始变得重要了。</p>\n<ol>\n<li>\n<p>interface 创建了一个单一的平面对象类型，可以检测属性冲突，这通常是需要解决的重要问题！ 另一方面，intersections 只是递归合并属性，在某些情况下永远不会产生属性冲突。\n<img src=\"https://github.com/user-attachments/assets/65b15da2-9a72-4ece-adf2-4346eb86d947\" alt=\"image\">\n<img src=\"https://github.com/user-attachments/assets/f8d16d70-92bf-491f-88c9-70f485249327\" alt=\"image\"></p>\n</li>\n<li>\n<p>interface 的显示效果也更好，而 intersections 的类型别名不能显示为其他交集的一部分。 interface 之间的类型关系也会被缓存，而 intersections 类型则不会被整体缓存。</p>\n</li>\n<li>\n<p>最后一个值得注意的区别是，在针对目标交叉类型进行检查时，在针对 \"有效\"/\"扁平化 \"类型进行检查之前，会先检查每个类型。</p>\n</li>\n</ol>\n<p>因此，建议使用interfaces/ extends来扩展类型，而不是创建交集类型。</p>\n<pre><code>- type Foo = Bar &#x26; Baz &#x26; {\n-     someProp: string;\n- }\n+ interface Foo extends Bar, Baz {\n+     someProp: string;\n+ }\n</code></pre>\n<h3 id=\"显示标注类型而不是依赖类型推断\"><a aria-hidden=\"true\" tabindex=\"-1\" href=\"#显示标注类型而不是依赖类型推断\"><span class=\"icon icon-link\"></span></a>显示标注类型而不是依赖类型推断</h3>\n<p>添加类型注解，尤其是返回类型，可以为编译器节省大量工作。 部分原因是命名类型往往比匿名类型（编译器可能会推断出匿名类型）更紧凑，这就减少了读写声明文件（例如增量编译）所花费的时间。 类型推断非常方便，因此没有必要普遍使用，但如果你发现代码中有一段运行速度较慢，可以尝试使用。</p>\n<pre><code>- import { otherFunc } from \"other\";\n+ import { otherFunc, OtherType } from \"other\";\n\n- export function func() {\n+ export function func(): OtherType {\n      return otherFunc();\n  }\n</code></pre>\n<h3 id=\"优先选择基本类型而不是联合类型\"><a aria-hidden=\"true\" tabindex=\"-1\" href=\"#优先选择基本类型而不是联合类型\"><span class=\"icon icon-link\"></span></a>优先选择基本类型而不是联合类型</h3>\n<p>联合类型很棒 - 它们可以让您表达类型的可能值的范围。</p>\n<pre><code>interface WeekdaySchedule {\n  day: \"Monday\" | \"Tuesday\" | \"Wednesday\" | \"Thursday\" | \"Friday\";\n  wake: Time;\n  startWork: Time;\n  endWork: Time;\n  sleep: Time;\n}\n\ninterface WeekendSchedule {\n  day: \"Saturday\" | \"Sunday\";\n  wake: Time;\n  familyMeal: Time;\n  sleep: Time;\n}\n\ndeclare function printSchedule(schedule: WeekdaySchedule | WeekendSchedule);\n</code></pre>\n<p>然而，它们也是有代价的。每次将参数传递给printSchedule时，都必须将其与并集的每个元素进行比较。对于二元联合来说，这是微不足道且廉价的。\n但是，如果您的联合体有十多个元素，则可能会导致编译速度出现实际问题。\n例如，为了从联合中消除冗余成员，必须将元素进行成对比较，这是二次的。当与大型联合相交时，可能会发生这种检查，其中对每个联合成员进行相交可能会产生巨大的类型，然后需要减少这些类型。避免这种情况的一种方法是使用子类型，而不是联合。</p>\n<pre><code>interface Schedule {\n  day: \"Monday\" | \"Tuesday\" | \"Wednesday\" | \"Thursday\" | \"Friday\" | \"Saturday\" | \"Sunday\";\n  wake: Time;\n  sleep: Time;\n}\n\ninterface WeekdaySchedule extends Schedule {\n  day: \"Monday\" | \"Tuesday\" | \"Wednesday\" | \"Thursday\" | \"Friday\";\n  startWork: Time;\n  endWork: Time;\n}\n\ninterface WeekendSchedule extends Schedule {\n  day: \"Saturday\" | \"Sunday\";\n  familyMeal: Time;\n}\n\ndeclare function printSchedule(schedule: Schedule);\n</code></pre>\n<p>当尝试对每个内置 DOM 元素类型进行建模时，可能会出现一个更现实的示例。在这种情况下，最好创建一个具有DivElement 、 ImgElement等所有扩展的通用成员的基本HtmlElement类型，而不是创建一个详尽的联合，例如 DivElement | /<em>...</em>/ | ImgElement | /<em>...</em>/ 。</p>\n<h3 id=\"命名复杂类型\"><a aria-hidden=\"true\" tabindex=\"-1\" href=\"#命名复杂类型\"><span class=\"icon icon-link\"></span></a>命名复杂类型</h3>\n<p>可以在允许类型注释的任何地方编写复杂类型。</p>\n<pre><code>interface SomeType&#x3C;T> {\n    foo&#x3C;U>(x: U):\n        U extends TypeA&#x3C;T> ? ProcessTypeA&#x3C;U, T> :\n        U extends TypeB&#x3C;T> ? ProcessTypeB&#x3C;U, T> :\n        U extends TypeC&#x3C;T> ? ProcessTypeC&#x3C;U, T> :\n        U;\n}\n</code></pre>\n<p>这很方便，但现在，每次调用foo时，TypeScript 都必须重新运行条件类型。此外，关联SomeType的任何两个实例需要重新关联foo返回类型的结构。</p>\n<p>如果此示例中的返回类型被提取到类型别名，则编译器可以缓存更多信息：</p>\n<pre><code>type FooResult&#x3C;U, T> =\n    U extends TypeA&#x3C;T> ? ProcessTypeA&#x3C;U, T> :\n    U extends TypeB&#x3C;T> ? ProcessTypeB&#x3C;U, T> :\n    U extends TypeC&#x3C;T> ? ProcessTypeC&#x3C;U, T> :\n    U;\n\ninterface SomeType&#x3C;T> {\n    foo&#x3C;U>(x: U): FooResult&#x3C;U, T>;\n}\n</code></pre>\n<h3 id=\"项目拆分\"><a aria-hidden=\"true\" tabindex=\"-1\" href=\"#项目拆分\"><span class=\"icon icon-link\"></span></a>项目拆分</h3>\n<p>当使用 TypeScript 构建任何规模不小的代码库时，将代码库组织成几个独立的项目会很有帮助。每个项目都有自己的tsconfig.json ，它依赖于其他项目。这有助于避免在一次编译中加载太多文件，并且还使某些代码库布局策略更容易组合在一起。</p>\n<p>有一些非常基本的方法可以将代码库组织到项目中。例如，一个程序可能包含一个客户端项目、一个服务器项目以及一个在两者之间共享的项目。</p>\n<pre><code>              ------------\n              |          |\n              |  Shared  |\n              ^----------^\n             /            \\\n            /              \\\n------------                ------------\n|          |                |          |\n|  Client  |                |  Server  |\n-----^------                ------^-----\n</code></pre>\n<p>测试也可以分解到自己的项目中。</p>\n<pre><code>              ------------\n              |          |\n              |  Shared  |\n              ^-----^----^\n             /      |     \\\n            /       |      \\\n------------  ------------  ------------\n|          |  |  Shared  |  |          |\n|  Client  |  |  Tests   |  |  Server  |\n-----^------  ------------  ------^-----\n     |                            |\n     |                            |\n------------                ------------\n|  Client  |                |  Server  |\n|  Tests   |                |  Tests   |\n------------                ------------\n</code></pre>\n<h3 id=\"指定文件\"><a aria-hidden=\"true\" tabindex=\"-1\" href=\"#指定文件\"><span class=\"icon icon-link\"></span></a>指定文件</h3>\n<p>您应该始终确保您的配置文件不会同时包含太多文件。</p>\n<p>在tsconfig.json中，有两种方法可以指定项目中的文件。</p>\n<ol>\n<li>files列表</li>\n<li>include和exclude列表</li>\n</ol>\n<p>两者之间的主要区别在于files需要源文件的文件路径列表，并且include / exclude使用通配模式来匹配文件。</p>\n<p>虽然指定files将允许 TypeScript 直接快速加载文件，但如果您的项目中有很多文件而只有几个顶级入口点，则可能会很麻烦。此外，很容易忘记将新文件添加到tsconfig.json中，这意味着您最终可能会遇到奇怪的编辑器行为，其中这些新文件被错误地分析。所有这些都可能很麻烦。</p>\n<p>include / exclude有助于避免需要指定这些文件，但代价是：必须通过遍历包含的目录来发现文件。当运行大量文件夹时，这可能会减慢编译速度。此外，有时编译会包含大量不必要的.d.ts文件和测试文件，这会增加编译时间和内存开销。\n最后，虽然exclude有一些合理的默认值，但某些配置（如 mono-repos）意味着“重”文件夹（如node_modules仍然可以被包含在内。</p>\n<p>对于最佳实践，我们建议如下：</p>\n<ol>\n<li>仅指定项目中的输入文件夹（即要包含其源代码以进行编译/分析的文件夹）。</li>\n<li>不要在同一文件夹中混合来自其他项目的源文件。</li>\n<li>如果将测试与其他源文件保存在同一文件夹中，请为它们指定一个不同的名称，以便可以轻松排除它们。</li>\n<li>避免大型构建工件和依赖项文件夹，例如源目录中的node_modules 。</li>\n</ol>\n<p><strong>注意：如果没有exclude列表，则默认排除node_modules ；一旦添加，将node_modules显式添加到列表中非常重要。</strong></p>\n<h3 id=\"控制types范围\"><a aria-hidden=\"true\" tabindex=\"-1\" href=\"#控制types范围\"><span class=\"icon icon-link\"></span></a>控制@types范围</h3>\n<p>默认情况下，TypeScript 会自动包含它在node_modules文件夹中找到的每个@types包，无论您是否导入它。这是为了让某些事情在使用 Node.js、Jasmine、Mocha、Chai 等时“正常工作”，因为这些工具/包不是导入的 - 它们只是加载到全局环境中。</p>\n<p>有时，这种逻辑会在编译和编辑场景中减慢程序构建时间，甚至可能导致多个声明冲突的全局包出现问题，从而导致诸如</p>\n<pre><code>Duplicate identifier 'IteratorResult'.\nDuplicate identifier 'it'.\nDuplicate identifier 'define'.\nDuplicate identifier 'require'.\n</code></pre>\n<p>在不需要全局包的情况下，修复就像在tsconfig.json / jsconfig.json中为\"types\"选项指定一个空字段一样简单</p>\n<pre><code>// src/tsconfig.json\n{\n   \"compilerOptions\": {\n       // ...\n\n       // Don't automatically include anything.\n       // Only include `@types` packages that we need to import.\n       \"types\" : []\n   },\n   \"files\": [\"foo.ts\"]\n}\n</code></pre>\n<p>如果您仍然需要一些全局包，请将它们添加到types字段。</p>\n<pre><code>// tests/tsconfig.json\n{\n   \"compilerOptions\": {\n       // ...\n\n       // Only include `@types/node` and `@types/mocha`.\n       \"types\" : [\"node\", \"mocha\"]\n   },\n   \"files\": [\"foo.test.ts\"]\n}\n</code></pre>\n<h3 id=\"跳过dts检查\"><a aria-hidden=\"true\" tabindex=\"-1\" href=\"#跳过dts检查\"><span class=\"icon icon-link\"></span></a>跳过.d.ts检查</h3>\n<p>默认情况下，TypeScript 会重新检查项目中的所有 .d.ts 文件，以查找问题和不一致之处；但这通常是不必要的。 在大多数情况下，.d.ts 文件已知已经正常工作--类型之间相互扩展的方式已经验证过一次，重要的声明无论如何都会被检查。</p>\n<p>TypeScript 提供了使用skipDefaultLibCheck标志跳过对其附带的.d.ts文件（例如lib.d.ts ）的类型检查的选项。</p>\n<p>或者，您还可以启用skipLibCheck标志来跳过检查编译中的所有.d.ts文件。</p>\n<p>这两个选项通常会隐藏.d.ts文件中的错误配置和冲突，因此我们建议仅将它们用于更快的构建。</p>","theme":"orange","tag":["Typescript"]}},"__N_SSG":true}