{"pageProps":{"post":{"title":"Webpack与Vite学习记录01","date":"2022-03-10","slug":"webpack与vite学习记录01","author":"LZS_911","content":"<h2>Webpack Tree Shaking</h2>\n<h3>来自于 <code>Webpack</code> 中文官方文档描述</h3>\n<blockquote>\n<p>tree shaking 是一个术语，通常用于描述移除 JavaScript 上下文中的未引用代码(dead-code)。它依赖于 ES2015 模块语法的 静态结构 特性，例如 import 和 export。这个术语和概念实际上是由 ES2015 模块打包工具 rollup 普及起来的。\nWebpack 2 正式版本内置支持 ES2015 模块（也叫做 harmony modules）和未使用模块检测能力。新的 Webpack 4 正式版本扩展了此检测能力，通过 package.json 的 \"sideEffects\" 属性作为标记，向 compiler 提供提示，表明项目中的哪些文件是 \"pure(纯正 ES2015 模块)\"，由此可以安全地删除文件中未使用的部分。</p>\n</blockquote>\n<p>上述描述可能有点抽象, 举个栗子:</p>\n<h3>关于 lodash 的 import</h3>\n<p>众所周知, <code>lodash</code> 是一个工具函数库, 在平时开发中能够为我们提供很多便利. 但因为 <code>lodash</code> 在 2012 年便开源, 历史较为久远, 可能有多种缘故, 导致目前 <code>lodash</code> 本身并不是使用的 <code>es module</code>. 所以在使用 <code>Webpack Tree Shaking</code> 时, 会出现一些问题.</p>\n<p>前置作业:</p>\n<p>这里先配置一个 <code>Webpack</code> + <code>react</code> 的最基本环境.</p>\n<p><code>package.json:</code></p>\n<pre><code class=\"language-json\">{\n  \"name\": \"lodash_test_Webpack\",\n  \"version\": \"1.0.0\",\n  \"main\": \"index.js\",\n  \"license\": \"MIT\",\n  \"scripts\": {\n    \"start\": \"Webpack serve --mode=development\",\n    \"build\": \"Webpack --mode=production\"\n  },\n  \"dependencies\": {\n    \"lodash\": \"^4.17.21\",\n    \"lodash-es\": \"^4.17.21\",\n    \"react\": \"^17.0.2\",\n    \"react-dom\": \"^17.0.2\"\n  },\n  \"devDependencies\": {\n    \"@babel/core\": \"^7.17.7\",\n    \"@babel/preset-react\": \"^7.16.7\",\n    \"babel-loader\": \"^8.2.3\",\n    \"Webpack\": \"^5.70.0\",\n    \"Webpack-bundle-analyzer\": \"^4.5.0\",\n    \"Webpack-cli\": \"^4.9.2\",\n    \"Webpack-dev-server\": \"^4.7.4\"\n  }\n}\n</code></pre>\n<p>入口文件 <code>main.js:</code></p>\n<pre><code class=\"language-javascript\">import { render } from 'react-dom';\nimport App from './app.jsx';\n\nconst mountNode = document.getElementById('app');\nrender(&#x3C;App />, mountNode);\n</code></pre>\n<p><code>app.jsx:</code></p>\n<pre><code class=\"language-jsx\">const App = () => {\n  return &#x3C;div>hello react&#x3C;/div>;\n};\n\nexport default App;\n</code></pre>\n<p><code>Webpack.config.js</code></p>\n<pre><code class=\"language-javascript\">const BundleAnalyzerPlugin =\n  require('Webpack-bundle-analyzer').BundleAnalyzerPlugin;\n\nmodule.exports = {\n  entry: './main.js',\n  output: {\n    filename: '[name].js',\n    path: __dirname + '/dist',\n  },\n  module: {\n    rules: [\n      {\n        test: /\\.(js|jsx|ts|tsx)$/,\n        exclude: /node_modules/,\n        use: [\n          {\n            loader: 'babel-loader',\n          },\n        ],\n      },\n    ],\n  },\n  plugins: [new BundleAnalyzerPlugin()],\n};\n</code></pre>\n<p><code>.babelrc:</code></p>\n<pre><code class=\"language-json\">{\n  \"presets\": [\n    [\n      \"@babel/preset-react\",\n      {\n        \"runtime\": \"automatic\"\n      }\n    ]\n  ]\n}\n</code></pre>\n<p>可以看到在 <code>Webpack</code> 配置中使用了 <code>BundleAnalyzerPlugin</code> 这样一个插件, 简单说明下该插件作用.</p>\n<p><strong><a href=\"https://www.npmtrends.com/Webpack-bundle-analyzer\">Webpack bundle analyzer</a></strong></p>\n<p>该工具是一个可以分析打包后文件结果的视觉化套件, 有了该工具后就可以清楚的从视觉化的图案了解到每次打包后的文件大小, 用来分析 <code>Webpack Tree Shaking</code> 后的结果.</p>\n<h3>分析使用不同的方式 import lodash 的结果</h3>\n<h4>第一种方式: 不指定 <code>function</code> 的路径</h4>\n<p>修改 <code>app.jsx</code>, 在组件中引入 <code>lodash</code></p>\n<pre><code class=\"language-jsx\">import { isEqual } from 'lodash';\nconst App = () => {\n  console.log(isEqual({ a: 'b' }, { c: 'd' }));\n  return &#x3C;div>hello react&#x3C;/div>;\n};\n\nexport default App;\n</code></pre>\n<p>打包后的文件结构:\n<img src=\"../assets/images/webpack-build-result-size/webpack_build_result_1.png\" alt=\"alt\"></p>\n<p>可以看到, 明明在项目中只使用了 <code>isEqual</code> 这一个 <code>function</code>, 结果 <code>lodash</code> 打包后的文件大小却足足有 <code>531kb</code>, 不禁让人怀疑, <code>isEqual</code> 是一个多么伟大的函数...</p>\n<h4>第二种方式: 指定 <code>function</code> 的路径</h4>\n<pre><code class=\"language-jsx\">import isEqual from 'lodash/isEqual';\n</code></pre>\n<p>打包后的文件结构:\n<img src=\"../assets/images/webpack-build-result-size/webpack_build_result_2.png\" alt=\"alt\"></p>\n<p>可以看到这个时候打包后的 <code>lodash</code> 仅有 <code>61kb</code> 了.</p>\n<h4>为什么两种 import 的方式会导致 bundle size 不一样</h4>\n<p><code>lodash</code> 是一个使用 <code>UMD</code> 为模块的构建的, 这意味着 <code>lodash</code> 并不满足在 <code>webpack</code> 中的 <code>tree-shaking</code> 必须是 <code>es module</code> 的条件. 所以第一种方式实际上会导入完整的 <code>lodash</code>, 最终导致 <code>bundle size</code> 莫名的巨大. 而第二种方法就是只导入了一个文件, 再从文件中拿出我们需要的 <code>isEqual</code>, 如此一来最后打包处的文件大小便是正常的.</p>\n<p>可是如果都要这样写代码会很麻烦, 毕竟 <code>vscode</code> 自动导入会按照第一种方式导入. 当然 <code>lodash</code> 官方也有考虑到这个问题, 推出了 <code>es module</code> 版本的 <code>lodash-es</code>.</p>\n<h3>为什么 webpack tree-shaking 使用的是 es module?</h3>\n<p>因为在 <code>CommonJS</code>、<code>AMD</code> 、<code>UMD</code> 中的导入都可能是非确定性的, 因此无法静态分析以有效消除死代码.</p>\n<p>举个栗子:</p>\n<pre><code class=\"language-javascript\">const flag = false;\nif (flag) {\n  const lodash = require('lodash');\n}\n</code></pre>\n<h2>vite tree-shaking</h2>\n<p><code>vite</code> 的构建生产环境使用的是 <code>rollup</code>, 相比于 <code>webpack</code>, <code>rollup</code> 总是能够打出更小、更快的宝. 并且 rollup 也是基于 <code>es module</code>, 相比于 <code>webpack</code> 使用的 <code>CommonJS</code> 更加的高效.</p>","ogImage":{"url":"/assets/blog/image/cover.jpg"},"coverImage":"/assets/blog/image/cover.jpg","theme":"scrolls-light","tag":["Webpack","javascript","node.js","vite","babel"]}},"__N_SSG":true}