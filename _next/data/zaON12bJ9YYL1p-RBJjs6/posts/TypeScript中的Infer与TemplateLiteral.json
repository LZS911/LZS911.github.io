{"pageProps":{"post":{"title":"TypeScript中的 infer 与 TemplateLiteral","date":"2022-11-21","slug":"TypeScript中的Infer与TemplateLiteral","author":"LZS_911","content":"<h2>infer</h2>\n<p>在介绍 <code>infer</code> 之前, 我们需要先了解一个前置知识点: <code>extends</code>, 也就是条件类型.</p>\n<p>来自 <code>Typescript</code> 官网的介绍:</p>\n<blockquote>\n<p>大多数有效程序的核心是，我们必须依据输入做出一些决定。 JavaScript 程序也是如此，但是由于值可以很容易地被内省，这些决定也是基于输入的类型。 条件类型 有助于描述输入和输出类型之间的关系。</p>\n</blockquote>\n<pre><code class=\"language-Typescript\">interface Animal {\n  live(): void;\n}\ninterface Dog extends Animal {\n  woof(): void;\n}\n \ntype Example1 = Dog extends Animal ? number : string;\n        \n// type Example1 = number\n \ntype Example2 = RegExp extends Animal ? number : string;\n        \n// type Example2 = string\n</code></pre>\n<p>可以看到 <code>extends</code> 的用法与 <code>javascript</code> 中的三元表达式没有太多的区别. 接下来, 回到文章的主题 --- <code>infer</code> 关键字.</p>\n<p>首先, 我们先来实现一个工具类型: 判断接受的泛型是否为一个函数, 如果是, 则返回函数的返回值类型, 否则返回泛型它自己.</p>\n<pre><code class=\"language-Typescript\">type f1 = () => void;\ntype f2 = (arg: string, arg2: number) => number;\ntype f3 = (arg: number) => string;\ntype t4 = { name: string };\n\ntype Example1&#x3C;T> = T extends ((...arg: any) => infer ResultType) ? ResultType : T;\n\ntype r1 = Example1&#x3C;f1> // type r1 = void;\ntype r2 = Example1&#x3C;f2> // type r2 = number\ntype r3 = Example1&#x3C;f3> // type r3 = string;\ntype r4 = Example1&#x3C;t4> // type t4 = { name: string }\n</code></pre>\n<p>在这里, 我们通过 <code>infer</code> 关键字引入了类型一个名为 <code>ResultType</code> 的新泛型类型变量, 或者可以理解为一个占位符, 当条件类型成立时, <code>ResultType</code> 会替换为满足条件类型时所需的类型, 在这个栗子中 <code>ResultType</code> 代表的是函数的返回类型, 也就完成了我们需要的工具类型.</p>\n<h2>Template Literal</h2>\n<p>我们先看下基础的字符串文字类型:</p>\n<pre><code class=\"language-Typescript\">type Demo = 'demo';\n</code></pre>\n<p>模版文字类型是建立在字符串文字类型上的, 举个栗子</p>\n<pre><code class=\"language-Typescript\">type Hello = 'hello';\ntype HelloWorld = `${Hello} world`; //type HelloWorld = \"hello world\"\n</code></pre>\n<p>单从语法上来说, 也是和 <code>javascript</code> 中的模版字符串大同小异.</p>\n<p>配合联合类型时, 会生成出每个联合成员可以表示的每个可能的字符串文字的集合.</p>\n<pre><code class=\"language-Typescript\">type EmailLocaleIDs = \"welcome_email\" | \"email_heading\";\ntype FooterLocaleIDs = \"footer_title\" | \"footer_sendoff\";\n \ntype AllLocaleIDs = `${EmailLocaleIDs | FooterLocaleIDs}_id`; \n//type AllLocaleIDs = \"welcome_email_id\" | \"email_heading_id\" | \"footer_title_id\" | \"footer_sendoff_id\"\n</code></pre>\n<p>就概念来说, <code>infer</code> 与 <code>Template Literal</code> 并不是很复杂, 最重要的还是在了解基本概念后能灵活的将其应用到实践中.</p>\n<p>对实践感兴趣的可以转到: <a href=\"https://lzs911.github.io/posts/Typescript%20%E4%BD%93%E6%93%8D%E7%BB%83%E4%B9%A0\">https://lzs911.github.io/posts/Typescript%20%E4%BD%93%E6%93%8D%E7%BB%83%E4%B9%A0</a></p>","ogImage":{"url":"/assets/blog/image/cover.jpg"},"coverImage":"/assets/blog/image/cover.jpg","theme":"fancy","tag":[null]}},"__N_SSG":true}