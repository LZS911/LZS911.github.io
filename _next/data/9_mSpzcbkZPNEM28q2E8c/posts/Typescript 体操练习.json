{"pageProps":{"post":{"title":"Typescript 体操练习","date":"2022-09-26","slug":"Typescript 体操练习","author":"LZS_911","content":"<p><strong>注: Typescript 使用最新版本号 v4.94</strong></p>\n<h2 id=\"1-将下划线模式的-string-类型转化成驼峰类型\"><a aria-hidden=\"true\" tabindex=\"-1\" href=\"#1-将下划线模式的-string-类型转化成驼峰类型\"><span class=\"icon icon-link\"></span></a>1. 将下划线模式的 string 类型转化成驼峰类型</h2>\n<pre><code class=\"language-Typescript\">type TransformToCamelCase&#x3C;T extends string> =\n  T extends `${infer Left}_${infer Rest}`\n    ? `${Left}${TransformToCamelCase&#x3C;Capitalize&#x3C;Rest>>}`\n    : T;\n\n</code></pre>\n<p><img src=\"/assets/typescript/example-1.png\" alt=\"alt\"></p>\n<p>注意点:</p>\n<p>需要递归继续处理剩余的部分.</p>\n<h3 id=\"应用-当服务端定义的实体中的-key-的模式为下环线-但前端代码中需要使用驼峰模式时\"><a aria-hidden=\"true\" tabindex=\"-1\" href=\"#应用-当服务端定义的实体中的-key-的模式为下环线-但前端代码中需要使用驼峰模式时\"><span class=\"icon icon-link\"></span></a>应用: 当服务端定义的实体中的 <code>key</code> 的模式为下环线, 但前端代码中需要使用驼峰模式时</h3>\n<p>实现:</p>\n<pre><code class=\"language-Typescript\">type CamelCase&#x3C;T extends Record&#x3C;string, any>> = T extends any\n  ? {\n      [key in keyof T as TransformToCamelCase&#x3C;\n        key &#x26; string\n      >]: T[key] extends Array&#x3C;infer Element>\n        ? Array&#x3C;\n            Element extends string\n              ? TransformToCamelCase&#x3C;Element>\n              : CamelCase&#x3C;Element>\n          >\n        : T[key] extends Record&#x3C;string, any>\n        ? CamelCase&#x3C;T[key]>\n        : T[key];\n    }\n  : never;\n</code></pre>\n<p><img src=\"/assets/typescript/example-2.png\" alt=\"alt\"></p>\n<p>注意点:</p>\n<ol>\n<li>当某项 <code>key</code> 的类型仍然满足 <code>Record&#x3C;string, any></code> 时, 需要递归继续.</li>\n<li>因为 <code>Typescript</code> 不会去计算递归中的表达式, 所以需要加上一个一定为 <code>true</code> 的判断, 让他去执行, 也就是 <code>T extends any</code>.</li>\n<li>需要注意 <code>Array</code> 的情况.</li>\n</ol>\n<h2 id=\"2-将索引类型转化为联合类型\"><a aria-hidden=\"true\" tabindex=\"-1\" href=\"#2-将索引类型转化为联合类型\"><span class=\"icon icon-link\"></span></a>2. 将索引类型转化为联合类型</h2>\n<ul>\n<li>索引类型是一个聚合了多个元素的类型，对象、类、元组等都是索引类型, 举个栗子:</li>\n</ul>\n<pre><code class=\"language-Typescript\">type ExampleType = {\n  name: string;\n  sex: boolean;\n  age: number;\n  hobbies: string[];\n}\n</code></pre>\n<ul>\n<li>联合类型. 顾名思义, 它是一个联合了多种类型的集合, 取值可以取其中任意一种类型.</li>\n</ul>\n<pre><code class=\"language-Typescript\">type UnionTypes = { name: string } | { sex: boolean } | { age: number} | { hobbies: string[] };\n</code></pre>\n<ul>\n<li>\n<p>需求: 实现一个工具类, 将 <code>ExampleType</code> 转化为 <code>UnionTypes</code></p>\n</li>\n<li>\n<p>实现:</p>\n<pre><code class=\"language-Typescript\">type SpiltObj&#x3C;T> = {\n  [key in keyof T]: {\n    [key2 in key]:T[key2]\n  }\n}[keyof T]\n</code></pre>\n</li>\n<li>\n<p>拆分, 先看第一部分</p>\n<pre><code class=\"language-Typescript\">type SpiltObj&#x3C;T> = {\n  [key in keyof T]: {\n    [key2 in key]:T[key2]\n  }\n}\n</code></pre>\n<pre><code class=\"language-Typescript\">  type Res1 = SpiltObj&#x3C;ExampleType>\n</code></pre>\n<p><img src=\"/assets/typescript/example-3.png\" alt=\"alt\"></p>\n<p>第二部分</p>\n<pre><code class=\"language-Typescript\">  type ExampleType = {\n    name: string;\n    sex: boolean;\n    age: number;\n    hobbies: string[];\n  }\n\n  type Res2 = ExampleType[keyof ExampleType]\n</code></pre>\n<p><img src=\"/assets/typescript/example-4.png\" alt=\"alt\"></p>\n</li>\n<li>\n<p>拓展, 实现一个工具类, 拿到索性类型键值路径的联合类型</p>\n<pre><code class=\"language-Typescript\">type Template = {\n  aa: {\n    bb: string;\n  };\n  cc: number;\n  dd: {\n    ee: {\n      ff: string;\n    }\n  };\n  gg: {\n    hh: number\n  };\n}\n\ntype TemplateKeyPath&#x3C;T> ={\n   [key in keyof T]: key extends string ? T[key] extends Record&#x3C;string, any> ? key | `${key}.${TemplateKeyPath&#x3C;T[key]>}` : key : never;\n}[keyof T]\n\ntype Res3 = TemplateKeyPath&#x3C;Template>\n</code></pre>\n<p><img src=\"/assets/typescript/example-5.png\" alt=\"alt\"></p>\n</li>\n</ul>\n<h2 id=\"3-使用数组长度进行数值计算\"><a aria-hidden=\"true\" tabindex=\"-1\" href=\"#3-使用数组长度进行数值计算\"><span class=\"icon icon-link\"></span></a>3. 使用数组长度进行数值计算</h2>\n<p>Typescript 本身是没有加减乘除运算符的, 所以需要取巧来处理数值的计算.</p>\n<p>利用构造数组, 然后获取它的 <code>length</code>.</p>\n<p><strong>注: 因为数组长度不会为负数, 所以这里做的数值计算只包含正整数</strong></p>\n<p><img src=\"/assets/typescript/example-6.png\" alt=\"alt\"></p>\n<p>实现运算方法之前, 先实现一个构造数组的工具类</p>\n<pre><code class=\"language-Typescript\">type BuildArray&#x3C;\n  Length extends number,\n  Element = unknown,\n  Array extends unknown[] = []\n> = Array['length'] extends Length\n  ? Array\n  : BuildArray&#x3C;Length, Element, [Element, ...Array]>;\n\n</code></pre>\n<p><img src=\"/assets/typescript/example-7.png\" alt=\"alt\"></p>\n<p><code>BuildArray</code> 接收三个泛形, 其中第一个参数 <code>Length</code> 为需要构造出来的数组长度, <code>Element</code> 为数组类的元素类型, 默认值为 <code>unknown</code>, <code>Array</code> 为返回结果, 用来递归处理. 如果将其转化为 <code>javascript</code> 代码, 大致如下:</p>\n<pre><code class=\"language-javascript\">const buildArray = (length, element, arr = []) => {\n  if (length === arr.length) {\n    return arr;\n  }\n\n  return buildArray(length, element, [element, ...arr]);\n};\n</code></pre>\n<h3 id=\"加法运算\"><a aria-hidden=\"true\" tabindex=\"-1\" href=\"#加法运算\"><span class=\"icon icon-link\"></span></a>加法运算</h3>\n<pre><code class=\"language-typescript\">type Add&#x3C;Num1 extends number, Num2 extends number> = [...BuildArray&#x3C;Num1>, ...BuildArray&#x3C;Num2>]['length']\n</code></pre>\n<p><img src=\"/assets/typescript/example-8.png\" alt=\"alt\"></p>\n<p><img src=\"/assets/typescript/example-9.png\" alt=\"alt\"></p>\n<h3 id=\"减法运算\"><a aria-hidden=\"true\" tabindex=\"-1\" href=\"#减法运算\"><span class=\"icon icon-link\"></span></a>减法运算</h3>\n<pre><code class=\"language-typescript\">type Subtract&#x3C;\n  Num1 extends number,\n  Num2 extends number\n> = BuildArray&#x3C;Num1> extends [...arr1: BuildArray&#x3C;Num2>, ...arr2: infer Rest]\n  ? Rest['length']\n  : never;\n\n</code></pre>\n<p><img src=\"/assets/typescript/example-10.png\" alt=\"alt\"></p>\n<p><img src=\"/assets/typescript/example-11.png\" alt=\"alt\"></p>\n<h3 id=\"乘法运算\"><a aria-hidden=\"true\" tabindex=\"-1\" href=\"#乘法运算\"><span class=\"icon icon-link\"></span></a>乘法运算</h3>\n<pre><code class=\"language-typescript\">type Multiply&#x3C;\n  Num1 extends number,\n  Num2 extends number,\n  ResultArray extends unknown[] = []\n> = Num2 extends 0\n  ? ResultArray['length']\n  : Multiply&#x3C;Num1, Subtract&#x3C;Num2, 1>, [...BuildArray&#x3C;Num1>, ...ResultArray]>;\n</code></pre>\n<p><img src=\"/assets/typescript/example-12.png\" alt=\"alt\"></p>\n<p><img src=\"/assets/typescript/example-13.png\" alt=\"alt\"></p>\n<h3 id=\"除法运算\"><a aria-hidden=\"true\" tabindex=\"-1\" href=\"#除法运算\"><span class=\"icon icon-link\"></span></a>除法运算</h3>\n<pre><code class=\"language-typescript\">type Divide&#x3C;\n  Num1 extends number,\n  Num2 extends number,\n  ResultArray extends unknown[] = []\n> = Num1 extends 0\n  ? ResultArray['length']\n  : Divide&#x3C;Subtract&#x3C;Num1, Num2>, Num2, [unknown, ...ResultArray]>; \n  // [unknown, ...ResultArray] => [...BuildArray&#x3C;Add&#x3C;ResultArray['length'], 1> &#x26; number>]\n\n</code></pre>\n<p><img src=\"/assets/typescript/example-14.png\" alt=\"alt\"></p>\n<p><img src=\"/assets/typescript/example-15.png\" alt=\"alt\"></p>\n<h2 id=\"4-判断两个正整数的大小\"><a aria-hidden=\"true\" tabindex=\"-1\" href=\"#4-判断两个正整数的大小\"><span class=\"icon icon-link\"></span></a>4. 判断两个正整数的大小</h2>\n<h3 id=\"比较是否相等\"><a aria-hidden=\"true\" tabindex=\"-1\" href=\"#比较是否相等\"><span class=\"icon icon-link\"></span></a>比较是否相等</h3>\n<pre><code class=\"language-typescript\">type NumberIsEqual&#x3C;Num1 extends number, Num2 extends number> = Num1 extends Num2 ? true : false;\n</code></pre>\n<p><img src=\"/assets/typescript/example-16.png\" alt=\"alt\"></p>\n<p><img src=\"/assets/typescript/example-17.png\" alt=\"alt\"></p>\n<h3 id=\"判断是否大于\"><a aria-hidden=\"true\" tabindex=\"-1\" href=\"#判断是否大于\"><span class=\"icon icon-link\"></span></a>判断是否大于</h3>\n<p>大致思路: 利用构造数组, 递归对构造出来的数组进行 Pop 操作, 通过判断数组的长度是否为 0 来确定大小.</p>\n<p>在开始实现钱先实现几个工具类, 减少重复代码和提高可读性.</p>\n<p><strong>注: 后续使用到同名工具类时默认为这几个类型</strong></p>\n<pre><code class=\"language-typescript\">type Or&#x3C;Case1 extends boolean, Case2 extends boolean> = Case1 extends true\n  ? true\n  : Case2 extends true\n  ? true\n  : false;\n\ntype ArrayPop&#x3C;Arr extends unknown[]> = Arr extends [...infer Left, infer Last]\n  ? Left\n  : never;\n\ntype NumberIsZero&#x3C;Num extends number> = Num extends 0 ? true : false;\n</code></pre>\n<p>最终代码</p>\n<pre><code class=\"language-typescript\">type NumberIsCompare&#x3C;\n  Num1 extends number,\n  Num2 extends number,\n  Arr1 extends unknown[] = BuildArray&#x3C;Num1>,\n  Arr2 extends unknown[] = BuildArray&#x3C;Num2>\n> = NumberIsEqual&#x3C;Num1, Num2> extends false\n  ? Or&#x3C;NumberIsZero&#x3C;Arr1['length']>, NumberIsZero&#x3C;Arr2['length']>> extends true\n    ? NumberIsZero&#x3C;Arr1['length']> extends true\n      ? false\n      : true\n    : NumberIsCompare&#x3C;ArrayPop&#x3C;Arr1>['length'], ArrayPop&#x3C;Arr2>['length']>\n  : false;\n\n</code></pre>\n<p><img src=\"/assets/typescript/example-18.png\" alt=\"alt\">\n<img src=\"/assets/typescript/example-19.png\" alt=\"alt\">\n<img src=\"/assets/typescript/example-20.png\" alt=\"alt\">\n<img src=\"/assets/typescript/example-21.png\" alt=\"alt\">\n<img src=\"/assets/typescript/example-22.png\" alt=\"alt\"></p>\n<h3 id=\"判断是否小与\"><a aria-hidden=\"true\" tabindex=\"-1\" href=\"#判断是否小与\"><span class=\"icon icon-link\"></span></a>判断是否小与</h3>\n<p>过滤掉相等情况后对大于取反就好了.</p>\n<pre><code class=\"language-typescript\">type NumberIsLess&#x3C;Num1 extends number, Num2 extends number> = NumberIsEqual&#x3C;\n  Num1,\n  Num2\n> extends false\n  ? NumberIsCompare&#x3C;Num1, Num2> extends true\n    ? false\n    : true\n  : false;\n</code></pre>\n<h2 id=\"5-实现-indexof---从左往右查找子串的位置\"><a aria-hidden=\"true\" tabindex=\"-1\" href=\"#5-实现-indexof---从左往右查找子串的位置\"><span class=\"icon icon-link\"></span></a>5. 实现 IndexOf - 从左往右查找子串的位置</h2>\n<p>核心原理</p>\n<p><img src=\"/assets/typescript/example-23.png\" alt=\"alt\"></p>\n<p>最后实现一个获取字符串长度的工具类型即可获得最终结果</p>\n<p><strong>注意: <code>['a']['length']的值为数组长度, 而 'aa'['length']</code> 的值为 number</strong></p>\n<p>所以我们可以将字符串切割为数组, 然后来获取长度.</p>\n<pre><code class=\"language-typescript\">type Split&#x3C;\n  S extends string,\n  Element extends string = '',\n  ResultArray extends string[] = []\n> = S extends ''\n  ? []\n  : S extends `${infer Left}${Element}${infer Rest}`\n  ? Rest extends ''\n    ? [...ResultArray, Left]\n    : Split&#x3C;Rest, Element, [...ResultArray, Left]>\n  : never;\n</code></pre>\n<p><img src=\"/assets/typescript/example-24.png\" alt=\"alt\">\n<img src=\"/assets/typescript/example-25.png\" alt=\"alt\">\n<img src=\"/assets/typescript/example-26.png\" alt=\"alt\"></p>\n<pre><code class=\"language-typescript\">type GetStringLength&#x3C;S extends string> =  Split&#x3C;S> extends never ? never : Split&#x3C;S>['length']\n</code></pre>\n<p>最后结果</p>\n<pre><code class=\"language-typescript\">type IndexOf&#x3C;\n  S1 extends string,\n  S2 extends string,\n  Len1 extends number = GetStringLength&#x3C;S1>,\n  Len2 extends number = GetStringLength&#x3C;S2>\n> = Or&#x3C;NumberIsCompare&#x3C;Len1, Len2>, NumberIsEqual&#x3C;Len1, Len2>> extends false\n  ? -1\n  : S1 extends `${infer Left}${S2}${infer Rest}`\n  ? GetStringLength&#x3C;Left>\n  : -1;\n</code></pre>\n<p><img src=\"/assets/typescript/example-27.png\" alt=\"alt\">\n<img src=\"/assets/typescript/example-28.png\" alt=\"alt\">\n<img src=\"/assets/typescript/example-29.png\" alt=\"alt\">\n<img src=\"/assets/typescript/example-30.png\" alt=\"alt\"></p>\n<h2 id=\"6-实现字符串的-replace-与-replaceall\"><a aria-hidden=\"true\" tabindex=\"-1\" href=\"#6-实现字符串的-replace-与-replaceall\"><span class=\"icon icon-link\"></span></a>6. 实现字符串的 Replace 与 ReplaceAll</h2>\n<ol>\n<li>\n<p><code>Replace</code></p>\n<pre><code class=\"language-typescript\">type Replace&#x3C;\n  Str extends string,\n  MatchStr extends string,\n  ReplaceStr extends string\n> = Str extends `${infer Left}${MatchStr}${infer Rest}`\n  ? `${Left}${ReplaceStr}${Rest}`\n  : Str;\n</code></pre>\n<p><img src=\"/assets/typescript/example-31.png\" alt=\"alt\">\n<img src=\"/assets/typescript/example-32.png\" alt=\"alt\">\n<img src=\"/assets/typescript/example-33.png\" alt=\"alt\"></p>\n</li>\n<li>\n<p><code>ReplaceAll</code></p>\n<pre><code class=\"language-typescript\">type ReplaceAll&#x3C;\n  Str extends string,\n  MatchStr extends string,\n  ReplaceStr extends string\n> = Str extends `${infer Left}${MatchStr}${infer Rest}`\n  ? Rest extends `${infer Left2}${MatchStr}${infer Rest2}`\n    ? ReplaceAll&#x3C;`${Left}${ReplaceStr}${Rest}`, MatchStr, ReplaceStr>\n    : `${Left}${ReplaceStr}${Rest}`\n  : Str;\n</code></pre>\n<p><img src=\"/assets/typescript/example-34.png\" alt=\"alt\">\n<img src=\"/assets/typescript/example-35.png\" alt=\"alt\"></p>\n</li>\n</ol>\n<h2 id=\"7-实现类似-vue-的类型支持的简化版本\"><a aria-hidden=\"true\" tabindex=\"-1\" href=\"#7-实现类似-vue-的类型支持的简化版本\"><span class=\"icon icon-link\"></span></a>7. 实现类似 Vue 的类型支持的简化版本</h2>\n<p>通过提供一个函数SimpleVue（类似于Vue.extend或defineComponent），它应该正确地推断出 computed 和 methods 内部的this类型。</p>\n<p>在此挑战中，我们假设SimpleVue接受只带有data，computed和methods字段的Object作为其唯一的参数，</p>\n<p>data是一个简单的函数，它返回一个提供上下文this的对象，但是你无法在data中获取其他的计算属性或方法。</p>\n<p>computed是将this作为上下文的函数的对象，进行一些计算并返回结果。在上下文中应暴露计算出的值而不是函数。</p>\n<p>methods是函数的对象，其上下文也为this。函数中可以访问data，computed以及其他methods中的暴露的字段。 computed与methods的不同之处在于methods在上下文中按原样暴露为函数。</p>\n<p>SimpleVue的返回值类型可以是任意的。</p>\n<pre><code class=\"language-JavaScript\">const instance = SimpleVue({\n  data() {\n    return {\n      firstname: 'Type',\n      lastname: 'Challenges',\n      amount: 10,\n    }\n  },\n  computed: {\n    fullname() {\n      return this.firstname + ' ' + this.lastname\n    }\n  },\n  methods: {\n    hi() {\n      alert(this.fullname.toLowerCase())\n    }\n  }\n})\n\n</code></pre>\n<p>实现:</p>\n<pre><code class=\"language-TypeScript\">type Computed&#x3C;C extends Record&#x3C;PropertyKey, () => any>> = {\n  [CK in keyof C]: ReturnType&#x3C;C[CK]>;\n};\n\ntype SimpleVueType&#x3C;D extends Record&#x3C;PropertyKey, any>, C extends Record&#x3C;PropertyKey, any>, M extends Record&#x3C;PropertyKey, any>> = (arg: {\n  data:() => D;\n  computed:C &#x26; ThisType&#x3C;D>;\n  methods: M &#x26; ThisType&#x3C;D &#x26; M &#x26; Computed&#x3C;C>>;\n}) => any\n</code></pre>\n<h2 id=\"8-函数柯里化\"><a aria-hidden=\"true\" tabindex=\"-1\" href=\"#8-函数柯里化\"><span class=\"icon icon-link\"></span></a>8. 函数柯里化</h2>\n<p>Currying 是一种将带有多个参数的函数转换为每个带有一个参数的函数序列的技术。</p>\n<p>例如：</p>\n<pre><code class=\"language-TypeScript\">const add = (a: number, b: number) => a + b\nconst three = add(1, 2)\n\nconst curriedAdd = Currying(add)\nconst five = curriedAdd(2)(3)\n</code></pre>\n<p>传递给 Currying 的函数可能有多个参数，您需要正确键入它。\n在此挑战中，curried 函数一次仅接受一个参数。分配完所有参数后，它应返回其结果。</p>\n<p>实现:</p>\n<pre><code class=\"language-TypeScript\">type CurryingType&#x3C;T> = T extends (...args: [infer Left, ...infer Rest]) => infer R\n    ? Rest['length'] extends 0\n        ? T\n        : (arg: Left) => CurryingType&#x3C;(...args: Rest) => R>\n    : never\n</code></pre>","theme":"fancy","tag":["Typescript"]}},"__N_SSG":true}