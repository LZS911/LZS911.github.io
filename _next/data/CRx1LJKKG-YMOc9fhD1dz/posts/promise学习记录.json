{"pageProps":{"post":{"title":"promise学习记录","date":"2022-03-01","slug":"promise学习记录","author":"LZS_911","content":"<h2>1. 一些相关的概念</h2>\n<h3>1.1 JavaScript 中的异步</h3>\n<p>在 <code>JavaScript</code> 中, 程序中将来执行的部分并不一定在现在运行的部分执行完之后立即执行. 换句话说, 现在无法完成的任务将会异步完成, 因此并不会出现阻塞行为.</p>\n<p>来看一段代码:</p>\n<pre><code class=\"language-javascript\">//现在执行的\nconst url = 'http://some.url.1';\n//将来执行的\nconst data = ajax(url);\n//接着现在执行的\nconsole.log(data);\n</code></pre>\n<p>这里的 <code>data</code> 通常是不会包含 <code>ajax</code> 请求所返回的数据的. 因为用户在请求网络资源时并不希望阻塞所有的 UI 交互.</p>\n<h3>1.2 回调函数</h3>\n<p>从现在到将来的等待, 最简单的办法(并不唯一, 甚至不是最优办法)是使用一个通常称为回调函数的函数.\n来看一段代码:</p>\n<pre><code class=\"language-javascript\">const url = 'http://some.url.1';\najax(url, (data) => {\n  console.log(data);\n});\n</code></pre>\n<p>为什么说 回调不是最优的解决办法, 还是先来看一段代码:</p>\n<pre><code class=\"language-javascript\">listen('click', (evt) => {\n  setTimeout(() => {\n    ajax('http://some.url.1', (text) => {\n      if (text === 'hello') {\n        handle();\n      } else {\n        request();\n      }\n    });\n  }, 500);\n});\n\n//node 范式的回调\nreadFile('hello.txt', (err, data) => {\n  if (err) {\n    throw Error(err);\n  }\n  if (data.toString() === 'hello') {\n    writeFile('hello.txt', 'hello world!', (err, data) => {\n      if (err) {\n        throw Error(err);\n      }\n      //todo...\n    });\n  }\n});\n</code></pre>\n<p>上面这段代码常常被称为 “回调地狱”, 虽然已经使用箭头函数来减少复杂度了, 但是看起来却还是不太优雅. 当然, 这仅仅是一个小问题. 上述这段代码的执行顺序还是比较好理解的, 往往在业务开发中, 会产生一些更严重的问题. 来看下面一段伪代码:</p>\n<pre><code class=\"language-javascript\">doA(() => {\n  doB();\n  doC(() => {\n    doD();\n  });\n  doE();\n});\ndoF();\n</code></pre>\n<p>上述代码的执行顺序便会更加复杂一点了, 实际运行顺序是:</p>\n<p><code>doA() -> doF() -> doB() -> doC() -> doE() -> doD()</code></p>\n<p>所以, 我们需要比回调更好的机制, 需要一种更同步、更顺序、更阻塞的方式来表达异步.</p>\n<h2>2. Promise</h2>\n<p>抛砖引玉结束, 现在回到本文的主题, 来好好了解 <code>Promise</code> 吧.</p>\n<h3>2.1 什么是 <code>Promise</code></h3>\n<p>Promise 是抽象异步处理对象以及对其进行各种操作的组件. Promise 最初被提出是在 E 语言中, 它是基于并列/并行处理设计的一种编程语言.</p>\n<h4>2.1.1 Constructor</h4>\n<p><code>Promise</code> 类似于 <code>XMLHttpRequest</code>, 从构造函数 <code>Promise</code> 来创建一个新建新 <code>promise</code> 对象作为接口.</p>\n<p>要想创建一个 <code>promise</code> 对象、可以使用 <code>new</code> 来调用 <code>Promise</code> 的构造器来进行实例化。</p>\n<pre><code class=\"language-javascript\">const promise = new Promise(function (resolve, reject) {\n  // 异步处理\n  // 处理结束后、调用resolve 或 reject\n});\n</code></pre>\n<h4>2.1.2 Instance Method</h4>\n<p>对通过 <code>new</code> 生成的 <code>promise</code> 对象为了设置其值在 <code>resolve(成功)</code> / <code>reject(失败)</code> 时调用的回调函数, 可以使用<code>promise.then()</code> 实例方法。</p>\n<pre><code class=\"language-javascript\">promise.then(onFulfilled, onRejected),\n</code></pre>\n<p><code>resolve</code> (成功)时 <code>onFulfilled</code> 会被调用</p>\n<p><code>reject</code>(失败)时 <code>onRejected</code> 会被调用</p>\n<p><code>onFulfilled、onRejected</code> 两个都为可选参数.</p>\n<p><code>promise.then</code> 成功和失败时都可以使用。 另外在只想对异常进行处理时可以采用 <code>promise.then(undefined, onRejected)</code> 这种方式，只指定 <code>reject</code> 时的回调函数即可. 不过这种情况下 <code>promise.catch(onRejected)</code> 应该是个更好的选择.</p>\n<pre><code class=\"language-javascript\">promise.catch(onRejected);\n</code></pre>\n<h3>2.1.3 Static Method</h3>\n<p>像 <code>Promise</code> 这样的全局对象还拥有一些静态方法.</p>\n<p>包括 <code>Promise.all()</code> 还有 <code>Promise.resolve()</code> 等在内，主要都是一些对 <code>Promise</code> 进行操作的辅助方法.</p>\n<h3>2.2 Promise 工作流程与状态</h3>\n<p>看一下下面的示例代码:</p>\n<pre><code class=\"language-javascript\">const asyncFn = () => {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      resolve('async hello world!');\n    }, 500);\n  });\n};\n\nasyncFn\n  .then((res) => {\n    console.log(res); //async hello world!\n  })\n  .catch((err) => {\n    console.log(err);\n  });\n</code></pre>\n<p>我们已经大概了解了 <code>Promise</code> 的处理流程，接下来让我们来稍微整理一下 <code>Promise</code> 的状态.</p>\n<p>用 <code>new Promise</code> 实例化的 <code>promise</code> 对象有以下三个状态.</p>\n<p><code>\"has-resolution\"</code> - Fulfilled\nresolve(成功)时, 此时会调用 onFulfilled</p>\n<p><code>\"has-rejection\"</code> - Rejected\nreject(失败)时, 此时会调用 onRejected</p>\n<p><code>\"unresolved\"</code> - Pending\n既不是 resolve 也不是 reject 的状态, 也就是 promise 对象刚被创建后的初始化状态等.</p>\n<p><code>promise</code>对象的状态</p>\n<p>从 <code>Pending</code> 转换为 <code>Fulfilled</code> 或 <code>Rejected</code> 之后, 这个 <code>promise</code> 对象的状态就不会再发生任何变化.</p>\n<p>也就是说, Promise 与 Event 等不同, 在.then 后执行的函数可以肯定地说只会被调用一次.</p>\n<p>另外, Fulfilled 和 Rejected 这两个中的任一状态都可以表示为 Settled(不变的).</p>\n<h3>2.3 实现上述工作流与状态控制</h3>\n<pre><code class=\"language-typescript\">type TGlPromiseStatus = \"pending\" | \"fulfilled\" | \"rejected\";\n\ninterface PromiseLike&#x3C;T> {\n  then&#x3C;TResult1 = T, TResult2 = never>(\n    onfulfilled?: ((value: T) => TResult1 | PromiseLike&#x3C;TResult1>) | null,\n    onrejected?: ((reason: any) => TResult2 | PromiseLike&#x3C;TResult2>) | null\n  ): PromiseLike&#x3C;TResult1 | TResult2>;\n}\ninterface IGlPromise&#x3C;T> {\n  then&#x3C;TResult1 = T, TResult2 = never>(\n    onfulfilled?: ((value: T) => TResult1 | PromiseLike&#x3C;TResult1>) | null,\n    onrejected?: ((reason: any) => TResult2 | PromiseLike&#x3C;TResult2>) | null\n  ): GlPromise&#x3C;TResult1 | TResult2>;\n  catch&#x3C;TResult = never>(\n    onrejected?: ((reason: any) => TResult | PromiseLike&#x3C;TResult>) | null\n  ): GlPromise&#x3C;T | TResult>;\n}\n\nexport default class GlPromise&#x3C;T> implements IGlPromise&#x3C;T> {\n  /**\n   * 构造函数\n   * @param executor 初始化 Promise 时传入的 callback, 类型为 : (resolve, reject) => void\n   */\n  constructor(\n    executor: (\n      resolve: (value: T) => void,\n      reject: (reason: any) => void\n    ) => void\n  ) {\n    // 执行传入的callback, 将 resolve, reject作为参数执行\n    executor(this.resolve, this.reject);\n  }\n\n  //状态\n  private PromiseStatus: TGlPromiseStatus = \"pending\";\n\n  //最终结果\n  private PromiseResult: T = undefined as any;\n\n  /**\n   * resolve函数,\n   *  构造函数中的回调函数的第一个参数\n   * 进行操作:\n   * 0. 判断状态时候为  pending, 不为 pending 代表该 promise 已经有结果了, 无法更改状态, 直接 return\n   * 1. 将 PromiseStatus 从 pending ===> fulfilled, 状态改变后, then中的成功回调才会执行\n   * 2. 将参数赋值给 PromiseResult\n   * @param: value: T\n   * @returns: void\n   **/\n  private resolve = (value: T) => {\n    if (this.PromiseStatus !== \"pending\") return;\n    this.PromiseResult = value;\n    this.PromiseStatus = \"fulfilled\";\n    while (this.onfulfilledCallbacks.length) {\n      this.onfulfilledCallbacks.shift()!(this.PromiseResult);\n    }\n  };\n\n  /**\n   * reject函数,\n   * 构造函数中的回调函数的第二个参数\n   * 进行操作:\n   * 0. 判断状态时候为  pending, 不为 pending 代表该 promise 已经有结果了, 无法更改状态, 直接 return\n   * 1. 将 PromiseStatus 从 pending ===> rejected, 状态改变后, catch中的成功回调才会执行\n   * 2. 将参数赋值给 PromiseResult\n   * @param reason:any\n   * @returns void\n   */\n  private reject = (reason: any) => {\n    if (this.PromiseStatus !== \"pending\") return;\n    this.PromiseResult = reason;\n    this.PromiseStatus = \"rejected\";\n    while (this.onrejectedCallbacks.length) {\n      this.onrejectedCallbacks.shift()!(this.PromiseResult);\n    }\n  };\n\n  private onfulfilledCallbacks: Array&#x3C;((value?: T) => void) | null> = [];\n\n  private onrejectedCallbacks: Array&#x3C;((value?: T) => void) | null> = [];\n\n  /**\n   * 核心: then 函数\n   */\n  public then = &#x3C;TResult1 = T, TResult2 = never>(\n    onfulfilled?: ((value: T) => TResult1 | PromiseLike&#x3C;TResult1>) | null,\n    onrejected?: ((reason: any) => TResult2 | PromiseLike&#x3C;TResult2>) | null\n  ) =>\n    new GlPromise&#x3C;TResult1 | TResult2>((resolve, reject) => {\n      const thenPromise = (\n        cb: (\n          values: T\n        ) => PromiseLike&#x3C;TResult1 | TResult2> | TResult1 | TResult2\n      ) => {\n        //模拟微任务\n        setTimeout(() => {\n          try {\n            const val = cb(this.PromiseResult);\n            if (val instanceof GlPromise) {\n              val.then(resolve, reject);\n            } else {\n              this.resolve(val as any);\n            }\n          } catch (error) {\n            this.reject(error);\n          }\n        });\n      };\n\n      if (this.PromiseStatus === \"fulfilled\") {\n        onfulfilled &#x26;&#x26; thenPromise(onfulfilled);\n      } else if (this.PromiseStatus === \"rejected\") {\n        onrejected &#x26;&#x26; thenPromise(onrejected);\n      } else if (this.PromiseStatus === \"pending\") {\n        onfulfilled &#x26;&#x26;\n          this.onfulfilledCallbacks.push(thenPromise.bind(this, onfulfilled));\n        onrejected &#x26;&#x26;\n          this.onrejectedCallbacks.push(thenPromise.bind(this, onrejected));\n      }\n    });\n\n  public catch = &#x3C;TResult = never>(\n    onrejected?: ((reason: any) => TResult | PromiseLike&#x3C;TResult>) | null\n  ) => this.then(null, onrejected);\n</code></pre>\n<h3>2.3 静态方式的使用与实现</h3>\n<h4>2.3.1 Promise.resolve</h4>\n<p>静态方法 <code>Promise.resolve(value)</code> 可以认为是 <code>new Promise()</code> 方法的快捷方式.</p>\n<p>比如 <code>Promise.resolve(42);</code> 可以认为是以下代码的语法糖:</p>\n<pre><code class=\"language-javascript\">new Promise(function (resolve) {\n  resolve(42);\n});\n</code></pre>\n<p>在这段代码中的 <code>resolve(42);</code> 会让这个 <code>promise</code> 对象立即进入确定（即 <code>resolved</code> ）状态, 并将 42 传递给后面<code>then</code>里所指定的 <code>onFulfilled</code> 函数.</p>\n<p>方法 <code>Promise.resolve(value);</code> 的返回值也是一个 <code>promise</code> 对象, 所以我们可以像下面那样接着对其返回值进行 <code>.then</code> 调用.</p>\n<pre><code class=\"language-javascript\">Promise.resolve(42).then(function (value) {\n  console.log(value);\n});\n</code></pre>\n<p>实现:</p>\n<pre><code class=\"language-typescript\">  public static resolve = &#x3C;T>(value: T) => {\n    return new GlPromise((resolve) => {\n      resolve(value);\n    });\n  };\n</code></pre>\n<h4>2.3.2 Promise.reject</h4>\n<p>基本类似与 Promise.resolve</p>\n<h4>2.3.3 Promise.all</h4>\n<p>Promise.all() 方法接收一个 promise 的 iterable 类型（注：Array，Map，Set 都属于 ES6 的 iterable 类型）的输入，并且只返回一个 Promise 实例， 那个输入的所有 promise 的 resolve 回调的结果是一个数组。这个 Promise 的 resolve 回调执行是在所有输入的 promise 的 resolve 回调都结束，或者输入的 iterable 里没有 promise 了的时候。它的 reject 回调执行是，只要任何一个输入的 promise 的 reject 回调执行或者输入不合法的 promise 就会立即抛出错误，并且 reject 的是第一个抛出的错误信息。</p>\n<p>基本使用方式:</p>\n<pre><code class=\"language-javascript\">const p1 = new Promise((resolve, reject) => {\n  setTimeout(() => {\n    resolve(2);\n  }, 2000);\n});\nconst p2 = new Promise((resolve, reject) => {\n  setTimeout(() => {\n    resolve(4);\n  }, 1000);\n});\nconst p3 = new Promise((resolve, reject) => {\n  setTimeout(() => {\n    reject(4);\n  }, 1000);\n});\nPromise.all([p1, p2]).then((res) => {\n  console.log(res);\n}); //[2, 4]\nPromise.all([p1, p2, p3])\n  .then((res) => {\n    console.log(res);\n  })\n  .catch((err) => {\n    console.log(err);\n  }); //4\n</code></pre>\n<p>实现:</p>\n<pre><code class=\"language-typescript\">  public static all = &#x3C;T>(promises: Array&#x3C;PromiseLike&#x3C;T>>) => {\n    const result: T[] = [];\n    let count = 0;\n    return new GlPromise((resolve, reject) => {\n      const addData = (index: number, value: T) => {\n        result[index] = value;\n        count++;\n        if (count === promises.length) {\n          resolve(result);\n        }\n      };\n      promises.forEach((promise, index) => {\n        if (promise instanceof GlPromise) {\n          promise.then((res) => {\n            addData(index, res);\n          }, (err) => {\n            reject(err);\n          });\n        } else {\n          addData(index, promise as any);\n        }\n      });\n    });\n  }\n</code></pre>\n<h3>2.3.4 Promise.any</h3>\n<p>Promise.any() 接收一个 Promise 可迭代对象，只要其中的一个 promise 成功，就返回那个已经成功的 promise 。如果可迭代对象中没有一个 promise 成功（即所有的 promises 都失败/拒绝），就返回一个失败的 promise 和 AggregateError 类型的实例，它是 Error 的一个子类，用于把单一的错误集合在一起。本质上，这个方法和 Promise.all()是相反的。</p>\n<pre><code class=\"language-javascript\">const pErr = new Promise((resolve, reject) => {\n  reject('总是失败');\n});\n\nconst pSlow = new Promise((resolve, reject) => {\n  setTimeout(resolve, 500, '最终完成');\n});\n\nconst pFast = new Promise((resolve, reject) => {\n  setTimeout(resolve, 100, '很快完成');\n});\n\nPromise.any([pErr, pSlow, pFast]).then((value) => {\n  console.log(value); // \"很快完成\"\n});\n</code></pre>\n<p>实现:</p>\n<pre><code class=\"language-typescript\">  public static any = &#x3C;T>(promises: Array&#x3C;PromiseLike&#x3C;T>>) => new GlPromise((resolve, reject) => {\n    let count = 0;\n    promises.forEach((promise) => {\n      if (promise instanceof GlPromise) {\n        promise.then((res) => resolve(res), () => {\n          count++;\n          if (count === promises.length) {\n            reject('All promises were rejected');\n          }\n        });\n      } else {\n        resolve(promise as any);\n      }\n    });\n  })\n\n</code></pre>\n<h3>2.3.5 Promise.race</h3>\n<p>Promise.race(iterable) 方法返回一个 promise，一旦迭代器中的某个 promise 解决或拒绝，返回的 promise 就会解决或拒绝。</p>\n<pre><code class=\"language-javascript\">const promise1 = new Promise((resolve, reject) => {\n  setTimeout(resolve, 500, 'one');\n});\n\nconst promise2 = new Promise((resolve, reject) => {\n  setTimeout(resolve, 100, 'two');\n});\n\nPromise.race([promise1, promise2])\n  .then((value) => {\n    console.log(value); // two\n  })\n  .catch((err) => {\n    console.log(err);\n  });\n</code></pre>\n<p>实现:</p>\n<pre><code class=\"language-typescript\">  public static race = &#x3C;T>(promises: Array&#x3C;PromiseLike&#x3C;T>>) => new GlPromise((resolve, reject) => {\n    promises.forEach((promise) => {\n      if (promise instanceof GlPromise) {\n        promise.then((res) => resolve(res), (err) => reject(err));\n      } else {\n        resolve(promise);\n      }\n    });\n  })\n</code></pre>\n<h3>2.3.6 Promise.allSettled</h3>\n<p>该 Promise.allSettled()方法返回一个在所有给定的 promise 都已经 fulfilled 或 rejected 后的 promise，并带有一个对象数组，每个对象表示对应的 promise 结果。</p>\n<p>当有多个彼此不依赖的异步任务成功完成时，或者总是想知道每个 promise 的结果时，通常使用它。</p>\n<p>相比之下，Promise.all() 更适合彼此相互依赖或者在其中任何一个 reject 时立即结束。</p>\n<pre><code class=\"language-javascript\">const promise1 = Promise.resolve(3);\nconst promise2 = new Promise((resolve, reject) =>\n  setTimeout(reject, 100, 'foo')\n);\nconst promises = [promise1, promise2];\n\nPromise.allSettled(promises).then((results) =>\n  results.forEach((result) => console.log(result.status))\n);\n\n// \"fulfilled\"\n// \"rejected\"\n</code></pre>\n<p>实现:</p>\n<pre><code class=\"language-typescript\"> public static allSettled = &#x3C;T>(promises: Array&#x3C;PromiseLike&#x3C;T>>) => new GlPromise((resolve, reject) => {\n    const result: Array&#x3C;{ status: 'fulfilled' | 'rejected', value: T }> = [];\n    let count = 0;\n\n    const addData = (index: number, value: T, status: 'fulfilled' | 'rejected') => {\n      result[index] = {\n        status, value\n      };\n      count++;\n      if (count === promises.length) resolve(result);\n    };\n\n    promises.forEach((promise, index) => {\n      if (promise instanceof GlPromise) {\n        promise.then((res) => addData(index, res, 'fulfilled'), (err) => addData(index, err, 'rejected'));\n      } else {\n        addData(index, promise as any, 'fulfilled');\n      }\n    });\n  })\n</code></pre>","ogImage":{"url":"/assets/blog/image/cover.jpg"},"coverImage":"/assets/blog/image/cover.jpg","theme":"simplicity-green","tag":["javascript","promise"]}},"__N_SSG":true}