{"pageProps":{"post":{"title":"TypeScript中的 infer 与 TemplateLiteral","date":"2022-11-21","slug":"TypeScript中的Infer与TemplateLiteral","author":"LZS_911","content":"<h2 id=\"infer\"><a aria-hidden=\"true\" tabindex=\"-1\" href=\"#infer\"><span class=\"icon icon-link\"></span></a>infer</h2>\n<p>在介绍 infer 之前, 我们需要先了解一个前置知识点: extends, 也就是条件类型.</p>\n<p>来自 Typescript 官网的介绍:</p>\n<blockquote>\n<p>大多数有效程序的核心是，我们必须依据输入做出一些决定。 JavaScript 程序也是如此，但是由于值可以很容易地被内省，这些决定也是基于输入的类型。 条件类型 有助于描述输入和输出类型之间的关系。</p>\n</blockquote>\n<pre><code class=\"language-Typescript\">interface Animal {\n  live(): void;\n}\ninterface Dog extends Animal {\n  woof(): void;\n}\n \ntype Example1 = Dog extends Animal ? number : string;\n        \n// type Example1 = number\n \ntype Example2 = RegExp extends Animal ? number : string;\n        \n// type Example2 = string\n</code></pre>\n<p>可以看到 extends 的用法与 javascript 中的三元表达式没有太多的区别. 接下来, 回到文章的主题 --- infer 关键字.</p>\n<p>首先, 我们先来实现一个工具类型: <em>判断接受的泛型是否为一个函数, 如果是, 则返回函数的返回值类型, 否则返回它自己</em></p>\n<pre><code class=\"language-Typescript\">type f1 = () => void;\ntype f2 = (arg: string, arg2: number) => number;\ntype f3 = (arg: number) => string;\ntype t4 = { name: string };\n\ntype Example1&#x3C;T> = T extends ((...arg: infer params) => infer ResultType) ? ResultType : T;\n</code></pre>\n<p><img src=\"/assets/infer_templateLiteral/example-1.png\" alt=\"alt\">\n<img src=\"/assets/infer_templateLiteral/example-2.png\" alt=\"alt\">\n<img src=\"/assets/infer_templateLiteral/example-3.png\" alt=\"alt\">\n<img src=\"/assets/infer_templateLiteral/example-4.png\" alt=\"alt\"></p>\n<p>在这里, 我们通过 infer 关键字引入了类型一个名为 ResultType 的新泛型类型变量, 或者可以理解为一个占位符, 当条件类型成立时, ResultType 会替换为满足条件类型时所需的类型, 在这个栗子中 ResultType 代表的是函数的返回类型, 也就完成了我们需要的工具类型.</p>\n<p>同样, 我们也可以实现一个 <em>提取元组类型中最后一个元素的类型</em></p>\n<pre><code class=\"language-Typescript\">type lastArrType&#x3C;T extends unknown[]> = T extends [\n  ...infer rest,\n  infer ResultType\n]\n  ? ResultType\n  : never;\n</code></pre>\n<p><img src=\"/assets/infer_templateLiteral/example-5.png\" alt=\"alt\"></p>\n<h2 id=\"template-literal\"><a aria-hidden=\"true\" tabindex=\"-1\" href=\"#template-literal\"><span class=\"icon icon-link\"></span></a>Template Literal</h2>\n<p>我们先看下基础的字符串文字类型:</p>\n<pre><code class=\"language-Typescript\">type Demo = 'demo';\n</code></pre>\n<p>模版文字类型是建立在字符串文字类型上的, 举个栗子</p>\n<pre><code class=\"language-Typescript\">type Hello = 'hello';\ntype HelloWorld = `${Hello} world`; //type HelloWorld = \"hello world\"\n</code></pre>\n<p>单从语法上来说, 也是和 javascript 中的模版字符串大同小异.</p>\n<p>配合联合类型时, 会生成出每个联合成员可以表示的每个可能的字符串文字的集合.</p>\n<pre><code class=\"language-Typescript\">type EmailLocaleIDs = \"welcome_email\" | \"email_heading\";\ntype FooterLocaleIDs = \"footer_title\" | \"footer_sendoff\";\n</code></pre>\n<p><img src=\"/assets/infer_templateLiteral/example-6.png\" alt=\"alt\"></p>\n<h2 id=\"实践\"><a aria-hidden=\"true\" tabindex=\"-1\" href=\"#实践\"><span class=\"icon icon-link\"></span></a>实践</h2>\n<p>结合 infer 以及 Template Literal 实现一个类似 <code>String.replace</code> 的工具类型</p>\n<pre><code class=\"language-Typescript\">type ReplaceStr&#x3C;\n  Str extends string,\n  From extends string,\n  To extends string\n> = Str extends `${infer Prefix}${From}${infer Suffix}`\n  ? `${Prefix}${To}${Suffix}`\n  : Str;\n</code></pre>\n<p><img src=\"/assets/infer_templateLiteral/example-7.png\" alt=\"alt\"></p>\n<p>对更多实践感兴趣的可以转到: <a href=\"https://lzs911.github.io/posts/Typescript%20%E4%BD%93%E6%93%8D%E7%BB%83%E4%B9%A0\">https://lzs911.github.io/posts/Typescript%20%E4%BD%93%E6%93%8D%E7%BB%83%E4%B9%A0</a></p>","ogImage":{"url":"/assets/blog/image/cover.jpg"},"coverImage":"/assets/blog/image/cover.jpg","theme":"fancy","tag":[null]}},"__N_SSG":true}