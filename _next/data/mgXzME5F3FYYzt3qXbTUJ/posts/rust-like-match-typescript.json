{"pageProps":{"post":{"title":"rust-like-match","date":"2023-02-24","slug":"rust-like-match-typescript","author":"Ai.Haibara","content":"<h2 id=\"简介\"><a aria-hidden=\"true\" tabindex=\"-1\" href=\"#简介\"><span class=\"icon icon-link\"></span></a>简介</h2>\n<p><code>rust-like-match</code> 提供了在 javascript 或 typescript 中使用 <code>Rust-Like</code> 的模式匹配. 并且在 typescript 环境下, <code>rust-like-match</code> 能够利用类型校验来实现 rust 中 <code>match</code> 的穷尽匹配以及提供优秀的类型提示.</p>\n<h2 id=\"什么是-rust-like-的模式匹配\"><a aria-hidden=\"true\" tabindex=\"-1\" href=\"#什么是-rust-like-的模式匹配\"><span class=\"icon icon-link\"></span></a>什么是 <code>Rust-Like</code> 的模式匹配?</h2>\n<p>在说到模式匹配之前, 我们先来看下 rust 中的枚举功能.</p>\n<pre><code class=\"language-rust\">enum Message {\n    Quit,\n    Move { x: i32, y: i32 },\n    Write(String),\n    ChangeColor(i32, i32, i32),\n}\n</code></pre>\n<p>这里定义了一个名为 <code>Message</code> 的枚举类型, 包含了四个成员. 成员后的 <code>{}</code> 或者 <code>()</code> 代表着可以将什么类型的数据附加到该枚举成员上.</p>\n<p>初始化枚举成员:</p>\n<pre><code class=\"language-rust\"> let msg1 = Message::Quit;\n let msg2 = Message::Move { x: 10, y: 20 };\n let msg3 = Message::Write(\"hello rust\".to_string());\n let mgs3 = Message::ChangeColor(255, 255, 255);\n</code></pre>\n<p>接下来回到主题, 来看下 rust 中的 <code>match</code> 关键字.</p>\n<pre><code class=\"language-rust\"> match msg1 {\n   Message::Quit => quit(),\n   Message::Move { x, y } => move_item(x, y),\n   Message::Write(msg) => println!(\"{}\", msg),\n   Message::ChangeColor(r, g, b) => change_color(r, g, b),\n }\n</code></pre>\n<p><code>match</code> 关键字后跟一个表达式, 在这个栗子中是变量 <code>msg1</code> 的值. 接下来是一对大括号, 里面包含了 <code>match</code> 的分支. 一个分支由两部分组成: 一个模式和一些代码. 第一个分支的模式是枚举成员 <code>Message::Quit</code>, 之后的 <code>=></code> 运算符将模式和需要执行的代码分开, 这里的代码是执行函数 <code>quit</code>. 同时, 在匹配上附加了额外数据的枚举成员时, 可以将其作为参数传递给后续需要执行的代码. 这里的代码结构有点类型 javascript 中的箭头函数.</p>\n<p><code>match</code> 也支持通配模式:</p>\n<pre><code class=\"language-rust\"> match msg1 {\n   Message::Quit => quit(),\n   _ => other()\n }\n</code></pre>\n<p>上述代码中当匹配上 <code>Message::Quit</code> 之外的成员时, 都将执行 <code>other</code> 函数, 其中 <code>_</code> 为 rust 特定的占位符.</p>\n<h2 id=\"typescript-中的模式匹配\"><a aria-hidden=\"true\" tabindex=\"-1\" href=\"#typescript-中的模式匹配\"><span class=\"icon icon-link\"></span></a>Typescript 中的模式匹配</h2>\n<p>接下来我们使用 <code>switch</code> 来模仿下 <code>match</code>:</p>\n<pre><code class=\"language-typescript\">\ntype Message =\n  | {\n      key: 'Quit';\n    }\n  | { key: 'Move'; value: { x: number; y: number } }\n  | { key: 'Write'; message: string }\n  | { key: 'ChangeColor'; r: number; g: number; b: number };\n\n\n\nlet msg!: Message;\n\nswitch (msg.key) {\n  case 'Quit': {\n    quit();\n    break;\n  }\n  case 'Move': {\n    move(msg.value);\n    break;\n  }\n  case 'Write': {\n    console.log(msg.message);\n    break;\n  }\n\n  case 'ChangeColor': {\n    change_color(msg.r, msg.g, msg.b);\n    break;\n  }\n}\n</code></pre>\n<h2 id=\"match-的优势\"><a aria-hidden=\"true\" tabindex=\"-1\" href=\"#match-的优势\"><span class=\"icon icon-link\"></span></a>Match 的优势</h2>\n<p>在我看来, <code>match</code> 主要的优势有以下三点:</p>\n<ol>\n<li><strong>当 <code>match</code> 中没有使用通配模式时, 其中的分支必须覆盖了所有的可能性, 否则编译将不会通过</strong>.</li>\n<li><code>switch</code> 是一个语句, 而不是一个表达式, 无法使用类似 <code>const value = switch(...){...}</code> 的操作, 只能在每一个 <code>case</code> 里面去执行赋值语句, 而 <code>match</code> 为一个表达式, 其返回值为分支中执行的代码的返回值.</li>\n<li>优秀的多模式匹配机制. <code>switch</code> 中的多模式匹配需要移除 <code>case</code> 中的 <code>break</code> 语句, 也就是说对于每一个独立 <code>case</code> 都需要在尾部添加 <code>break</code> 语句, 但也容易因为 <code>break</code> 的丢失导致出现一些“误会”. 而 <code>match</code> 中的多模式采用类似 <code>Message::Quit | Message::Start => doSomething()</code> 的语法, 且每一个独立的分支不需要添加任何额外的语句.</li>\n</ol>\n<h2 id=\"使用方式\"><a aria-hidden=\"true\" tabindex=\"-1\" href=\"#使用方式\"><span class=\"icon icon-link\"></span></a>使用方式</h2>\n<p>在了解了 <code>match</code> 的具体语法以及优势后, 我们回到主题 <code>rust-like-match</code> 中, 我们首先来看下具体的使用方式:</p>\n<ol>\n<li>\n<p>初始化</p>\n<pre><code class=\"language-typescript\">import { defineMatchObject, none } from \"rust-like-match\";\n\nconst Message = defineMatchObject({\n  Quit: none,\n  Move: (x: number, y: number) => ({ x, y }),\n  Write: (msg: string) => msg,\n  ChangeColor: (r: number, g: number, b: number) => ({ r, g, b }),\n});\n//or\nconst obj = {\n  Quit: none,\n  Move: (x: number, y: number) => ({ x, y }),\n  Write: (msg: string) => msg,\n  ChangeColor: (r: number, g: number, b: number) => ({ r, g, b }),\n} as const;\nconst Message = defineMatchObject(msg);\n</code></pre>\n<p>首先从 <code>rust-like-match</code> 中导出函数 <code>defineMatchObject</code> 以及变量 <code>none</code>. 由于 typescript 中已经存在 <code>enum</code> 的概念. 所以, 这里将初始化过程命名为 <strong>定义一个具有Match功能的对象</strong>, 也就是 <code>defineMatchObject</code>. 该函数接收一个字面量类型的对象, <code>key</code> 值对应 <code>rust</code> 中的枚举成员名, <code>value</code> 值的类型为 <code>None (typeof none)</code> 或者为一个函数. <code>None</code> 的情况对应着未给枚举成员附加额外数据, 相应的, 值为函数即代表着附加额外数据的情况.</p>\n</li>\n<li>\n<p>赋值</p>\n<p>我们来看下得到的 <code>Message</code> 的具体格式:</p>\n<p><img src=\"/assets/rust-like-match/example-1.png\" alt=\"alt\"></p>\n<p><img src=\"/assets/rust-like-match/example-2.png\" alt=\"alt\"></p>\n<p><img src=\"/assets/rust-like-match/example-3.png\" alt=\"alt\"></p>\n<p><img src=\"/assets/rust-like-match/example-4.png\" alt=\"alt\"></p>\n<p>可以看到, 当初始值为 <code>none</code> 时, <code>Message</code> 的成员值(<code>Quit</code>)为一个拥有 <code>match</code> 属性的对象. 当初始值为函数时, <code>Message</code> 的成员值同样也是一个函数, 且该函数的入参类型与初始的函数入参类型一致. 该函数的返回值为一个拥有 <code>match</code> 属性的对象.</p>\n<p>所以我们这样来进行赋值:</p>\n<pre><code class=\"language-typescript\">let msg;\n\nmsg = Message.Quit;\n//or\nmsg = Message.Move(10, 20);\n//or\nmsg = Message.Write(\"hello rust\");\n//or\nmsg = Message.ChangeColor(255, 255, 255);\n</code></pre>\n</li>\n<li>\n<p>匹配</p>\n<p><code>match</code> 函数接收一个对象作为参数, 对象的每一个 <code>key:value</code> 对应着一条分支, <code>key</code> 值为一个模式, 必须满足穷尽模式或者使用通配模式, <code>value</code> 为一个函数, 该函数能够接收到 <code>defineMatchObject</code> 时定义的函数的返回值, 并将其作为参数. 函数体为分支匹配上后执行的代码.</p>\n<p>接下来主要介绍在 typescript 环境下其拥有的一些特性:</p>\n<ol>\n<li>\n<p>支持通配模式, 当分支中存在 <code>_</code> 时, 此分支涵盖了其他可能的值, 且无需满足全匹配.</p>\n<pre><code class=\"language-typescript\"> msg.match({\n   Quit:() => quit(),\n   _ :() => other(),\n })\n</code></pre>\n</li>\n<li>\n<p>穷尽匹配: 当分支中不存在 <code>_</code> 时, 分支必须覆盖所有的情况, 否则 <code>typescript</code> 将编译失败.</p>\n<pre><code class=\"language-typescript\"> msg.match({\n   Quit: () => quit(),\n   Move: ({ x, y }) => move(x, y),\n   Write: (msg) => console.log(msg),\n   ChangeColor: ({ r, g, b }) => changeColor(r, g, b),\n });\n</code></pre>\n</li>\n<li>\n<p>参数类型自动推导. 每个分支中的函数的入参类型为定义时函数的返回类型.</p>\n</li>\n<li>\n<p>支持泛型.</p>\n</li>\n</ol>\n<pre><code class=\"language-typescript\">  //此时 res 类型将自动推导为 number\n  const res = msg.match({\n    Quit: () => 1,\n    Move: ({ x, y }) => 2,\n    Write: (msg) => 3,\n    ChangeColor: ({ r, g, b }) => 4,\n  });\n\n //由于未标注泛型, 且存在分支的返回类型不一致, 此时 typescript 将会报错\n const res = msg.match({\n    Quit: () => 1,\n    Move: ({ x, y }) => '2',\n    Write: (msg) => 3,\n    ChangeColor: ({ r, g, b }) => 4,\n  });\n\n //res 的类型为 string | number | boolean | Array&#x3C;number>\n const res = msg.match&#x3C;string | number | boolean | Array&#x3C;number>>({\n    Quit: () => 1,\n    Move: ({ x, y }) => [x, y],\n    Write: (msg) => false,\n    ChangeColor: ({ r, g, b }) => `${r}-${g}-${b}`,\n  });\n</code></pre>\n</li>\n</ol>\n<h2 id=\"拓展\"><a aria-hidden=\"true\" tabindex=\"-1\" href=\"#拓展\"><span class=\"icon icon-link\"></span></a>拓展</h2>\n<ol>\n<li>\n<p>在 React 项目中, 怎样在能保证支持类型校验的同时将其设置为一个 <code>state</code>?</p>\n<p><code>rust-like-match</code> 现支持导出类型 <code>MatchObjectType</code>. 具体使用方式如下:</p>\n<pre><code class=\"language-tsx\"> import { defineMatchObject, none, MatchObjectType } from 'rust-like-match';\n\n const statusEnum = {\n    Loading: none,\n    Success: (data?: Item) => data,\n    Error: (err: string) => Error,\n } as const;\n\n const RequestStatus = defineMatchObject(statusEnum);\n\n const [status, setStatus] = useState&#x3C;MatchObjectType&#x3C;typeof statusEnum>>();\n\n useEffect(() => {\n   setStatus(RequestStatus.Loading);\n   api\n     .getData()\n     .then((res) => {\n       if (res.data.code === ResponseCode.SUCCESS) {\n         setStatus(RequestStatus.Success(res.data.data));\n       }\n     })\n     .catch((err) => {\n       setStatus(\n         RequestStatus.Error(err?.toString() ?? \"unknown error\")\n       );\n     });\n }, []);\n\n\n return (\n   //...\n   {\n     status?.match({\n       Loading: () => &#x3C;Spin />,\n       Success: (data) => renderData(data),\n       Error: (err) => renderError(err)\n     })\n   }\n   //...\n )\n</code></pre>\n</li>\n<li>\n<p>新增函数 <code>baseTypeMatch</code>, 支持对基础类型数据进行模式匹配. 具体使用方式如下:</p>\n<ol>\n<li>\n<p>number 类型</p>\n<pre><code class=\"language-typescript\">  const value1 = baseTypeMatch(1, {\n    //val type is 1\n    1: (val) => val + 2,\n    2: (val) => val + 3,\n    _: (val) => val,\n  });\n  expect(value1).toBe(3);\n\n  const value2 = baseTypeMatch(value1, {\n    //val type is number\n    1: (val) => val + 2,\n    2: (val) => val + 3,\n    '3 | 4': (val) => val + 1,\n    _: (val) => val,\n  });\n\n  expect(value2).toBe(4);\n\n  const cases: BaseTypeMatchPatternType&#x3C;number, number> = {\n    '1 | 2': (val) => val + 1,\n    3: (val) => val + 1,\n    _: (val) => val + 1,\n  };\n  const value3 = baseTypeMatch(value2, cases);\n  expect(value3).toBe(5);\n</code></pre>\n</li>\n<li>\n<p>string 类型</p>\n<pre><code class=\"language-typescript\"> const value1 = baseTypeMatch('foo', {\n  //val type is foo\n  foo: (val) => val + 2,\n  bar: (val) => val + 3,\n  _: (val) => val,\n  });\n\n  expect(value1).toBe('foo2');\n\n  const value2 = baseTypeMatch(value1, {\n    //val type is string\n    foo: (val) => val + 2,\n    bar: (val) => val + 3,\n    'foo2 | foo1': (val) => val + 1,\n    _: (val) => val,\n  });\n\n  expect(value2).toBe('foo21');\n\n  const cases: BaseTypeMatchPatternType&#x3C;string, string> = {\n    '1 | 2': (val) => val + 1,\n    bar: (val) => val + 1,\n    _: (val) => val + 1,\n  };\n  const value3 = baseTypeMatch(value2, cases);\n  expect(value3).toBe('foo211');\n</code></pre>\n</li>\n<li>\n<p>boolean 类型</p>\n<pre><code class=\"language-typescript\">   const value1 = baseTypeMatch&#x3C;number>(false, {\n     //val type is false\n      false: (val) => (val ? 1 : 2),\n      true: (val) => (val ? 1 : 2),\n    });\n\n    expect(value1).toBe(2);\n\n    const value2 = baseTypeMatch(value1, {\n      //val type is number\n      2: (val) => true,\n      _: (val) => false,\n    });\n\n    expect(value2).toBeTruthy();\n\n    const cases: BaseTypeMatchPatternType&#x3C;boolean, string> = {\n      'true | false': (val) => 'hello',\n      bar: (val) => 'rust',\n      _: (val) => 'javascript',\n    };\n    const value3 = baseTypeMatch(value2, cases);\n    expect(value3).toBe('hello');\n</code></pre>\n</li>\n<li>\n<p>symbol 类型</p>\n<pre><code class=\"language-typescript\">   const symbol = Symbol();\n   const value1 = baseTypeMatch&#x3C;number | symbol>(Symbol(), {\n     foo: () => 1,\n     bar: () => 2,\n     _: () => symbol,\n   });\n   expect(value1).toBe(symbol);\n\n   const cases: BaseTypeMatchPatternType&#x3C;symbol, string | boolean | number | symbol> = {\n     [value1 as symbol]: (val) => false,\n     'a | b': (val) => 1,\n     1: (val) => val,\n     _: (val) => 'hello',\n   };\n   const value2 = baseTypeMatch(value1 as symbol, cases);\n   expect(value2).toBeFalsy();\n</code></pre>\n</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"未来将会支持的功能\"><a aria-hidden=\"true\" tabindex=\"-1\" href=\"#未来将会支持的功能\"><span class=\"icon icon-link\"></span></a>未来将会支持的功能</h2>\n<ol>\n<li>实现多模式匹配, 预计会以 <code>\"Quit | Start\": () => other()</code> 的形式来实现.</li>\n<li>兼容 typescript 中的 <code>enum</code> (实现方案考虑中).</li>\n</ol>","theme":"jzman","tag":[null]}},"__N_SSG":true}